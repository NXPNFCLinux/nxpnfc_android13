From ef02ada2945a6c49887ece169151ae4a71a67727 Mon Sep 17 00:00:00 2001
From: nxf36764 <kumarnarayan.bhat@nxp.com>
Date: Thu, 28 Oct 2021 13:04:46 +0530
Subject: [PATCH 1/3] [artf905105][T4TEE]T4T Ndef emulation integration

Ported T4T ndef emulation from android 11 7160 nfc stack to android 12 7160 nfc stack
---
 halimpl/tml/NfccTransportFactory.cc           |  79 +++
 halimpl/tml/NfccTransportFactory.h            |  67 +++
 halimpl/tml/transport/NfccI2cTransport.cc     | 533 ++++++++++++++++++
 halimpl/tml/transport/NfccI2cTransport.h      | 266 +++++++++
 halimpl/tml/transport/NfccSpiTransport.cc     | 533 ++++++++++++++++++
 halimpl/tml/transport/NfccSpiTransport.h      | 266 +++++++++
 halimpl/tml/transport/NfccTransport.cc        |  50 ++
 halimpl/tml/transport/NfccTransport.h         | 246 ++++++++
 intf/nxpnfc/1.0/manifest.xml                  |  10 +-
 pn8x/1.1/Nfc.h                                |   4 +-
 pn8x/Android.bp                               |   6 +-
 pn8x/extns/impl/Nxp_Features.h                |  21 +-
 pn8x/extns/impl/hal_nxpnfc.h                  |  14 +-
 pn8x/halimpl/common/phNfcCommon.h             |   7 +
 pn8x/halimpl/dnld/phDnldNfc.cc                |   4 +-
 pn8x/halimpl/dnld/phDnldNfc.h                 |   4 +-
 pn8x/halimpl/dnld/phNxpNciHal_Dnld.cc         |   4 +-
 pn8x/halimpl/hal/phNxpNciHal.cc               | 201 ++++++-
 pn8x/halimpl/hal/phNxpNciHal.h                |  17 +
 pn8x/halimpl/hal/phNxpNciHal_ext.cc           |  76 ++-
 pn8x/halimpl/libnfc-nxp-PN548AD_example.conf  |   4 +
 pn8x/halimpl/libnfc-nxp-PN66T_example.conf    |   4 +
 pn8x/halimpl/src/adaptation/EseAdaptation.cpp |   4 +-
 pn8x/halimpl/tml/NfccTransportFactory.cc      |  79 +++
 pn8x/halimpl/tml/NfccTransportFactory.h       |  67 +++
 pn8x/halimpl/tml/phTmlNfc.cc                  |  75 ++-
 pn8x/halimpl/tml/phTmlNfc.h                   |  12 +-
 pn8x/halimpl/tml/spi_spm.cc                   |  14 +-
 .../halimpl/tml/transport/NfccI2cTransport.cc | 533 ++++++++++++++++++
 pn8x/halimpl/tml/transport/NfccI2cTransport.h | 266 +++++++++
 .../halimpl/tml/transport/NfccSpiTransport.cc | 533 ++++++++++++++++++
 pn8x/halimpl/tml/transport/NfccSpiTransport.h | 266 +++++++++
 pn8x/halimpl/tml/transport/NfccTransport.cc   |  50 ++
 pn8x/halimpl/tml/transport/NfccTransport.h    | 246 ++++++++
 pn8x/halimpl/utils/NxpNfcCapability.cpp       |  14 +-
 pn8x/halimpl/utils/phNxpConfig.h              |   8 +-
 pn8x/halimpl/utils/phNxpNciHal_utils.cc       |  16 +-
 37 files changed, 4545 insertions(+), 54 deletions(-)
 create mode 100644 halimpl/tml/NfccTransportFactory.cc
 create mode 100644 halimpl/tml/NfccTransportFactory.h
 create mode 100644 halimpl/tml/transport/NfccI2cTransport.cc
 create mode 100644 halimpl/tml/transport/NfccI2cTransport.h
 create mode 100644 halimpl/tml/transport/NfccSpiTransport.cc
 create mode 100644 halimpl/tml/transport/NfccSpiTransport.h
 create mode 100644 halimpl/tml/transport/NfccTransport.cc
 create mode 100644 halimpl/tml/transport/NfccTransport.h
 create mode 100755 pn8x/halimpl/tml/NfccTransportFactory.cc
 create mode 100755 pn8x/halimpl/tml/NfccTransportFactory.h
 create mode 100755 pn8x/halimpl/tml/transport/NfccI2cTransport.cc
 create mode 100755 pn8x/halimpl/tml/transport/NfccI2cTransport.h
 create mode 100755 pn8x/halimpl/tml/transport/NfccSpiTransport.cc
 create mode 100755 pn8x/halimpl/tml/transport/NfccSpiTransport.h
 create mode 100755 pn8x/halimpl/tml/transport/NfccTransport.cc
 create mode 100755 pn8x/halimpl/tml/transport/NfccTransport.h

diff --git a/halimpl/tml/NfccTransportFactory.cc b/halimpl/tml/NfccTransportFactory.cc
new file mode 100644
index 0000000..b626cf2
--- /dev/null
+++ b/halimpl/tml/NfccTransportFactory.cc
@@ -0,0 +1,79 @@
+/******************************************************************************
+ *
+ *  Copyright 2020-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <NfccI2cTransport.h>
+#include <NfccSpiTransport.h>
+#include <NfccTransportFactory.h>
+#include <phNxpLog.h>
+
+/*******************************************************************************
+ **
+ ** Function         NfccTransportFactory
+ **
+ ** Description      Constructor for transportFactory. This will be private to
+ **                  support singleton
+ **
+ ** Parameters       none
+ **
+ ** Returns          none
+ ******************************************************************************/
+NfccTransportFactory::NfccTransportFactory() {}
+
+/*******************************************************************************
+**
+** Function         getTransport
+**
+** Description      selects and returns transport channel based on the input
+**                  parameter
+**
+** Parameters       Required transport Type
+**
+** Returns          Selected transport channel
+******************************************************************************/
+NfccTransportFactory &NfccTransportFactory::getInstance() {
+  static NfccTransportFactory mTransprtFactoryInstance;
+  return mTransprtFactoryInstance;
+}
+
+/*******************************************************************************
+**
+** Function         getTransport
+**
+** Description      selects and returns transport channel based on the input
+**                  parameter
+**
+** Parameters       Required transport Type
+**
+** Returns          Selected transport channel
+******************************************************************************/
+spTransport NfccTransportFactory::getTransport(transportIntf transportType) {
+  NXPLOG_TML_D("%s Requested transportType: %d\n", __func__, transportType);
+  spTransport mspTransportInterface;
+  switch (transportType) {
+    case I2C:
+    case UNKNOWN:
+      mspTransportInterface = std::make_shared<NfccI2cTransport>();
+      break;
+    case SPI:
+      mspTransportInterface = std::make_shared<NfccSpiTransport>();
+    default:
+      mspTransportInterface = std::make_shared<NfccI2cTransport>();
+      break;
+  }
+  return mspTransportInterface;
+}
diff --git a/halimpl/tml/NfccTransportFactory.h b/halimpl/tml/NfccTransportFactory.h
new file mode 100644
index 0000000..34cec36
--- /dev/null
+++ b/halimpl/tml/NfccTransportFactory.h
@@ -0,0 +1,67 @@
+/******************************************************************************
+ *
+ *  Copyright 2020-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#pragma once
+#include <NfccTransport.h>
+#include <memory>
+
+#define transportFactory (NfccTransportFactory::getInstance())
+typedef std::shared_ptr<NfccTransport> spTransport;
+enum transportIntf { I2C, SPI, UNKNOWN };
+
+extern spTransport gpTransportObj;
+class NfccTransportFactory {
+  /*****************************************************************************
+   **
+   ** Function         NfccTransportFactory
+   **
+   ** Description      Constructor for transportFactory. This will be private to
+   **                  support singleton
+   **
+   ** Parameters       none
+   **
+   ** Returns          none
+   ****************************************************************************/
+  NfccTransportFactory();
+
+public:
+  /*****************************************************************************
+   **
+   ** Function         getInstance
+   **
+   ** Description      returns the static instance of TransportFactory
+   **
+   ** Parameters       none
+   **
+   ** Returns          TransportFactory instance
+   ****************************************************************************/
+  static NfccTransportFactory &getInstance();
+
+  /*****************************************************************************
+  **
+  ** Function         getTransport
+  **
+  ** Description      selects and returns transport channel based on the input
+  **                  parameter
+  **
+  ** Parameters       Required transport Type
+  **
+  ** Returns          Selected transport channel
+  ****************************************************************************/
+  spTransport getTransport(transportIntf transportType);
+};
diff --git a/halimpl/tml/transport/NfccI2cTransport.cc b/halimpl/tml/transport/NfccI2cTransport.cc
new file mode 100644
index 0000000..cc76f11
--- /dev/null
+++ b/halimpl/tml/transport/NfccI2cTransport.cc
@@ -0,0 +1,533 @@
+/******************************************************************************
+ *  Copyright 2020-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <errno.h>
+#include <fcntl.h>
+#include <hardware/nfc.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/select.h>
+#include <termios.h>
+#include <unistd.h>
+
+#include "phNxpNciHal_utils.h"
+#include <NfccI2cTransport.h>
+#include <phNfcStatus.h>
+#include <phNxpLog.h>
+#include <string.h>
+
+#define CRC_LEN 2
+#define NORMAL_MODE_HEADER_LEN 3
+#define FW_DNLD_HEADER_LEN 2
+#define FW_DNLD_LEN_OFFSET 1
+#define NORMAL_MODE_LEN_OFFSET 2
+#define FRAGMENTSIZE_MAX PHNFC_I2C_FRAGMENT_SIZE
+extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
+extern phTmlNfc_Context_t *gpphTmlNfc_Context;
+/*******************************************************************************
+**
+** Function         Close
+**
+** Description      Closes NFCC device
+**
+** Parameters       pDevHandle - device handle
+**
+** Returns          None
+**
+*******************************************************************************/
+void NfccI2cTransport::Close(void *pDevHandle) {
+  if (NULL != pDevHandle) {
+    close((intptr_t)pDevHandle);
+  }
+  sem_destroy(&mTxRxSemaphore);
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         OpenAndConfigure
+**
+** Description      Open and configure NFCC device
+**
+** Parameters       pConfig     - hardware information
+**                  pLinkHandle - device handle
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - open_and_configure operation success
+**                  NFCSTATUS_INVALID_DEVICE - device open operation failure
+**
+*******************************************************************************/
+NFCSTATUS NfccI2cTransport::OpenAndConfigure(pphTmlNfc_Config_t pConfig,
+                                             void **pLinkHandle) {
+  int nHandle;
+
+  NXPLOG_TML_D("%s Opening port=%s\n", __func__, pConfig->pDevName);
+  /* open port */
+  nHandle = open((const char *)pConfig->pDevName, O_RDWR);
+  if (nHandle < 0) {
+    NXPLOG_TML_E("_i2c_open() Failed: retval %x", nHandle);
+    *pLinkHandle = NULL;
+    return NFCSTATUS_INVALID_DEVICE;
+  }
+
+  *pLinkHandle = (void *)((intptr_t)nHandle);
+  if (0 != sem_init(&mTxRxSemaphore, 0, 1)) {
+    NXPLOG_TML_E("%s Failed: reason sem_init : retval %x", __func__, nHandle);
+  }
+  /*Reset PN54X*/
+  NfccReset((void *)((intptr_t)nHandle), MODE_POWER_OFF);
+  usleep(10 * 1000);
+  NfccReset((void *)((intptr_t)nHandle), MODE_POWER_ON);
+
+  return NFCSTATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         Flushdata
+**
+** Description      Reads payload of FW rsp from NFCC device into given buffer
+**
+** Parameters       pDevHandle - valid device handle
+**                  pBuffer    - buffer for read data
+**                  numRead    - number of bytes read by calling function
+**
+** Returns          always returns -1
+**
+*******************************************************************************/
+int NfccI2cTransport::Flushdata(void* pDevHandle, uint8_t* pBuffer, int numRead) {
+  int retRead = 0;
+  uint16_t totalBtyesToRead = pBuffer[FW_DNLD_LEN_OFFSET] + FW_DNLD_HEADER_LEN + CRC_LEN;
+  /* we shall read totalBtyesToRead-1 as one byte is already read by calling function*/
+  retRead = read((intptr_t)pDevHandle, pBuffer + numRead, totalBtyesToRead - 1);
+  if (retRead > 0) {
+    numRead += retRead;
+    phNxpNciHal_print_packet("RECV", pBuffer, numRead);
+  } else if (retRead == 0) {
+    NXPLOG_TML_E("%s _i2c_read() [pyld] EOF", __func__);
+  } else {
+    if (bFwDnldFlag == false) {
+      NXPLOG_TML_D("%s _i2c_read() [hdr] received", __func__);
+      phNxpNciHal_print_packet("RECV", pBuffer - numRead, NORMAL_MODE_HEADER_LEN);
+    }
+    NXPLOG_TML_E("%s _i2c_read() [pyld] errno : %x", __func__, errno);
+  }
+  SemPost();
+  return -1;
+}
+
+/*******************************************************************************
+**
+** Function         Read
+**
+** Description      Reads requested number of bytes from NFCC device into given
+**                  buffer
+**
+** Parameters       pDevHandle       - valid device handle
+**                  pBuffer          - buffer for read data
+**                  nNbBytesToRead   - number of bytes requested to be read
+**
+** Returns          numRead   - number of successfully read bytes
+**                  -1        - read operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::Read(void *pDevHandle, uint8_t *pBuffer,
+                           int nNbBytesToRead) {
+  int ret_Read;
+  int ret_Select;
+  int numRead = 0;
+  struct timeval tv;
+  fd_set rfds;
+  uint16_t totalBtyesToRead = 0;
+
+  UNUSED(nNbBytesToRead);
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+
+  if (bFwDnldFlag == false) {
+    totalBtyesToRead = NORMAL_MODE_HEADER_LEN;
+  } else {
+    totalBtyesToRead = FW_DNLD_HEADER_LEN;
+  }
+
+  /* Read with 2 second timeout, so that the read thread can be aborted
+     when the NFCC does not respond and we need to switch to FW download
+     mode. This should be done via a control socket instead. */
+  FD_ZERO(&rfds);
+  FD_SET((intptr_t)pDevHandle, &rfds);
+  tv.tv_sec = 2;
+  tv.tv_usec = 1;
+
+  ret_Select =
+      select((int)((intptr_t)pDevHandle + (int)1), &rfds, NULL, NULL, &tv);
+  if (ret_Select < 0) {
+    NXPLOG_TML_D("%s errno : %x", __func__, errno);
+    return -1;
+  } else if (ret_Select == 0) {
+    NXPLOG_TML_D("%s Timeout", __func__);
+    return -1;
+  } else {
+    ret_Read = read((intptr_t)pDevHandle, pBuffer, totalBtyesToRead - numRead);
+    if (ret_Read > 0 && !(pBuffer[0] == 0xFF && pBuffer[1] == 0xFF)) {
+      SemTimedWait();
+      numRead += ret_Read;
+    } else if (ret_Read == 0) {
+      NXPLOG_TML_E("%s [hdr]EOF", __func__);
+      return -1;
+    } else {
+      NXPLOG_TML_E("%s [hdr] errno : %x", __func__, errno);
+      NXPLOG_TML_E(" %s pBuffer[0] = %x pBuffer[1]= %x", __func__, pBuffer[0],
+                   pBuffer[1]);
+      return -1;
+    }
+
+    if (bFwDnldFlag == false) {
+      totalBtyesToRead = NORMAL_MODE_HEADER_LEN;
+#if(NXP_EXTNS == TRUE)
+      if (gpphTmlNfc_Context->tReadInfo.pContext != NULL &&
+              !memcmp(gpphTmlNfc_Context->tReadInfo.pContext, "MinOpen", 0x07) &&
+              !pBuffer[0] && pBuffer[1]) {
+        return Flushdata(pDevHandle, pBuffer, numRead);
+      }
+#endif
+    } else {
+      totalBtyesToRead = FW_DNLD_HEADER_LEN;
+    }
+
+    if (numRead < totalBtyesToRead) {
+      ret_Read = read((intptr_t)pDevHandle, (pBuffer + numRead), totalBtyesToRead - numRead);
+
+      if (ret_Read != totalBtyesToRead - numRead) {
+        SemPost();
+        NXPLOG_TML_E("%s [hdr] errno : %x", __func__, errno);
+        return -1;
+      } else {
+        numRead += ret_Read;
+      }
+    }
+    if (bFwDnldFlag == true) {
+      totalBtyesToRead = pBuffer[FW_DNLD_LEN_OFFSET] + FW_DNLD_HEADER_LEN + CRC_LEN;
+    } else {
+      totalBtyesToRead = pBuffer[NORMAL_MODE_LEN_OFFSET] + NORMAL_MODE_HEADER_LEN;
+    }
+    if ((totalBtyesToRead - numRead) != 0) {
+      ret_Read = read((intptr_t)pDevHandle, (pBuffer + numRead), totalBtyesToRead - numRead);
+      if (ret_Read > 0) {
+        numRead += ret_Read;
+      } else if (ret_Read == 0) {
+        SemPost();
+        NXPLOG_TML_E("%s [pyld] EOF", __func__);
+        return -1;
+      } else {
+        if (bFwDnldFlag == false) {
+          NXPLOG_TML_D("_i2c_read() [hdr] received");
+          phNxpNciHal_print_packet("RECV", pBuffer, NORMAL_MODE_HEADER_LEN);
+        }
+        SemPost();
+        NXPLOG_TML_E("%s [pyld] errno : %x", __func__, errno);
+        return -1;
+      }
+    } else {
+      NXPLOG_TML_E("%s _>>>>> Empty packet recieved !!", __func__);
+    }
+  }
+  SemPost();
+  return numRead;
+}
+
+/*******************************************************************************
+**
+** Function         Write
+**
+** Description      Writes requested number of bytes from given buffer into
+**                  NFCC device
+**
+** Parameters       pDevHandle       - valid device handle
+**                  pBuffer          - buffer for read data
+**                  nNbBytesToWrite  - number of bytes requested to be written
+**
+** Returns          numWrote   - number of successfully written bytes
+**                  -1         - write operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::Write(void *pDevHandle, uint8_t *pBuffer,
+                            int nNbBytesToWrite) {
+  int ret;
+  int numWrote = 0;
+  int numBytes = nNbBytesToWrite;
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+  if (fragmentation_enabled == I2C_FRAGMENATATION_DISABLED &&
+      nNbBytesToWrite > FRAGMENTSIZE_MAX) {
+    NXPLOG_TML_D(
+        "%s data larger than maximum I2C  size,enable I2C fragmentation",
+        __func__);
+    return -1;
+  }
+  while (numWrote < nNbBytesToWrite) {
+    if (fragmentation_enabled == I2C_FRAGMENTATION_ENABLED &&
+        nNbBytesToWrite > FRAGMENTSIZE_MAX) {
+      if (nNbBytesToWrite - numWrote > FRAGMENTSIZE_MAX) {
+        numBytes = numWrote + FRAGMENTSIZE_MAX;
+      } else {
+        numBytes = nNbBytesToWrite;
+      }
+    }
+    SemTimedWait();
+    ret = write((intptr_t)pDevHandle, pBuffer + numWrote, numBytes - numWrote);
+    SemPost();
+    if (ret > 0) {
+      numWrote += ret;
+      if (fragmentation_enabled == I2C_FRAGMENTATION_ENABLED &&
+          numWrote < nNbBytesToWrite) {
+        usleep(500);
+      }
+    } else if (ret == 0) {
+      NXPLOG_TML_D("%s EOF", __func__);
+      return -1;
+    } else {
+      NXPLOG_TML_D("%s errno : %x", __func__, errno);
+      if (errno == EINTR || errno == EAGAIN) {
+        continue;
+      }
+      return -1;
+    }
+  }
+
+  return numWrote;
+}
+
+/*******************************************************************************
+**
+** Function         Reset
+**
+** Description      Reset NFCC device, using VEN pin
+**
+** Parameters       pDevHandle     - valid device handle
+**                  eType          - reset level
+**
+** Returns           0   - reset operation success
+**                  -1   - reset operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::NfccReset(void *pDevHandle, NfccResetType eType) {
+  int ret = -1;
+  NXPLOG_TML_D("%s, VEN eType %ld", __func__, eType);
+
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+
+  ret = ioctl((intptr_t)pDevHandle, NFC_SET_PWR, eType);
+  if (ret < 0) {
+    NXPLOG_TML_E("%s :failed errno = 0x%x", __func__, errno);
+  }
+  if ((eType != MODE_FW_DWNLD_WITH_VEN && eType != MODE_FW_DWND_HIGH) &&
+      ret == 0) {
+    EnableFwDnldMode(false);
+  }
+  if ((((eType == MODE_FW_DWNLD_WITH_VEN) || (eType == MODE_FW_DWND_HIGH)) && (ret == 0))) {
+    EnableFwDnldMode(true);
+  }
+
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         EseReset
+**
+** Description      Request NFCC to reset the eSE
+**
+** Parameters       pDevHandle     - valid device handle
+**                  eType          - EseResetType
+**
+** Returns           0   - reset operation success
+**                  else - reset operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::EseReset(void *pDevHandle, EseResetType eType) {
+  int ret = -1;
+  NXPLOG_TML_D("%s, eType %ld", __func__, eType);
+
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+  ret = ioctl((intptr_t)pDevHandle, ESE_SET_PWR, eType);
+  if (ret < 0) {
+    NXPLOG_TML_E("%s :failed errno = 0x%x", __func__, errno);
+  }
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         EseGetPower
+**
+** Description      Request NFCC to reset the eSE
+**
+** Parameters       pDevHandle     - valid device handle
+**                  level          - reset level
+**
+** Returns           0   - reset operation success
+**                  else - reset operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::EseGetPower(void *pDevHandle, long level) {
+  return ioctl((intptr_t)pDevHandle, ESE_GET_PWR, level);
+}
+
+/*******************************************************************************
+**
+** Function         GetPlatform
+**
+** Description      Get platform interface type (i2c or i3c) for common mw
+**
+** Parameters       pDevHandle     - valid device handle
+**
+** Returns           0   - i2c
+**                   1   - i3c
+**
+*******************************************************************************/
+int NfccI2cTransport::GetPlatform(void *pDevHandle) {
+  int ret = -1;
+  NXPLOG_TML_D("%s ", __func__);
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+  ret = ioctl((intptr_t)pDevHandle, NFC_GET_PLATFORM_TYPE);
+  NXPLOG_TML_D("%s :platform = %d", __func__, ret);
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         GetNfcState
+**
+** Description      Get NFC state
+**
+** Parameters       pDevHandle     - valid device handle
+** Returns           0   - unknown
+**                   1   - FW DWL
+**                   2 	 - NCI
+**
+*******************************************************************************/
+int NfccI2cTransport::GetNfcState(void *pDevHandle) {
+  int ret = NFC_STATE_UNKNOWN;
+  NXPLOG_TML_D("%s ", __func__);
+  if (NULL == pDevHandle) {
+    return ret;
+  }
+  ret = ioctl((intptr_t)pDevHandle, NFC_GET_NFC_STATE);
+  NXPLOG_TML_D("%s :nfc state = %d", __func__, ret);
+  return ret;
+}
+/*******************************************************************************
+**
+** Function         EnableFwDnldMode
+**
+** Description      updates the state to Download mode
+**
+** Parameters       True/False
+**
+** Returns          None
+*******************************************************************************/
+void NfccI2cTransport::EnableFwDnldMode(bool mode) { bFwDnldFlag = mode; }
+
+/*******************************************************************************
+**
+** Function         IsFwDnldModeEnabled
+**
+** Description      Returns the current mode
+**
+** Parameters       none
+**
+** Returns           Current mode download/NCI
+*******************************************************************************/
+bool_t NfccI2cTransport::IsFwDnldModeEnabled(void) { return bFwDnldFlag; }
+
+/*******************************************************************************
+**
+** Function         SemPost
+**
+** Description      sem_post 2c_read / write
+**
+** Parameters       none
+**
+** Returns          none
+*******************************************************************************/
+void NfccI2cTransport::SemPost() {
+  int sem_val = 0;
+  sem_getvalue(&mTxRxSemaphore, &sem_val);
+  if (sem_val == 0) {
+    sem_post(&mTxRxSemaphore);
+  }
+}
+
+/*******************************************************************************
+**
+** Function         SemTimedWait
+**
+** Description      Timed sem_wait for avoiding i2c_read & write overlap
+**
+** Parameters       none
+**
+** Returns          Sem_wait return status
+*******************************************************************************/
+int NfccI2cTransport::SemTimedWait() {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  long sem_timedout = 500 * 1000 * 1000;
+  int s = 0;
+  struct timespec ts;
+  clock_gettime(CLOCK_REALTIME, &ts);
+  ts.tv_sec += 0;
+  ts.tv_nsec += sem_timedout;
+  while ((s = sem_timedwait(&mTxRxSemaphore, &ts)) == -1 && errno == EINTR) {
+    continue; /* Restart if interrupted by handler */
+  }
+  if (s != -1) {
+    status = NFCSTATUS_SUCCESS;
+  } else if (errno == ETIMEDOUT && s == -1) {
+    NXPLOG_TML_E("%s :timed out errno = 0x%x", __func__, errno);
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         GetIrqState
+**
+** Description      Get state of IRQ GPIO
+**
+** Parameters       pDevHandle - valid device handle
+**
+** Returns          The state of IRQ line i.e. +ve if read is pending else Zer0.
+**                  In the case of IOCTL error, it returns -ve value.
+**
+*******************************************************************************/
+int NfccI2cTransport::GetIrqState(void *pDevHandle) {
+  int ret = -1;
+
+  NXPLOG_TML_D("%s Enter",__func__);
+  if (NULL != pDevHandle) {
+    ret = ioctl((intptr_t)pDevHandle, NFC_GET_IRQ_STATE);
+  }
+  NXPLOG_TML_D("%s exit: state = %d", __func__, ret);
+  return ret;
+}
diff --git a/halimpl/tml/transport/NfccI2cTransport.h b/halimpl/tml/transport/NfccI2cTransport.h
new file mode 100644
index 0000000..ae684b8
--- /dev/null
+++ b/halimpl/tml/transport/NfccI2cTransport.h
@@ -0,0 +1,266 @@
+/******************************************************************************
+ *
+ *  Copyright 2020-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#pragma once
+#include <NfccTransport.h>
+
+#define NFC_MAGIC 0xE9
+/*
+ * NFCC power control via ioctl
+ * NFC_SET_PWR(0): power off
+ * NFC_SET_PWR(1): power on
+ * NFC_SET_PWR(2): reset and power on with firmware download enabled
+ */
+#define NFC_SET_PWR _IOW(NFC_MAGIC, 0x01, long)
+/*
+ * 1. SPI Request NFCC to enable ESE power, only in param
+ *   Only for SPI
+ *   level 1 = Enable power
+ *   level 0 = Disable power
+ * 2. NFC Request the eSE cold reset, only with MODE_ESE_COLD_RESET
+ */
+#define ESE_SET_PWR _IOW(NFC_MAGIC, 0x02, long)
+
+/*
+ * SPI or DWP can call this ioctl to get the current
+ * power state of ESE
+ */
+#define ESE_GET_PWR _IOR(NFC_MAGIC, 0x03, long)
+
+/*
+ * get platform interface type(i2c or i3c) for common MW
+ * return 0 - i2c, 1 - i3c
+ */
+#define NFC_GET_PLATFORM_TYPE _IO(NFC_MAGIC, 0x04)
+/*
+ * get boot state
+ * return unknown, fw dwl, fw teared, nci
+ */
+#define NFC_GET_NFC_STATE _IO(NFC_MAGIC, 0x05)
+
+/* NFC HAL can call this ioctl to get the current IRQ state */
+#define NFC_GET_IRQ_STATE _IO(NFC_MAGIC, 0x06)
+
+extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
+
+class NfccI2cTransport : public NfccTransport {
+ private:
+  bool_t bFwDnldFlag = false;
+  sem_t mTxRxSemaphore;
+  /*****************************************************************************
+   **
+   ** Function         SemTimedWait
+   **
+   ** Description      Timed sem_wait for avoiding i2c_read & write overlap
+   **
+   ** Parameters       none
+   **
+   ** Returns          Sem_wait return status
+   ****************************************************************************/
+  int SemTimedWait();
+
+  /*****************************************************************************
+   **
+   ** Function         SemPost
+   **
+   ** Description      sem_post 2c_read / write
+   **
+   ** Parameters       none
+   **
+   ** Returns          none
+   ****************************************************************************/
+  void SemPost();
+
+  int Flushdata(void* pDevHandle, uint8_t* pBuffer, int numRead);
+
+ public:
+  /*****************************************************************************
+  **
+  ** Function         Close
+  **
+  ** Description      Closes NFCC device
+  **
+  ** Parameters       pDevHandle - device handle
+  **
+  ** Returns          None
+  **
+  *****************************************************************************/
+  void Close(void *pDevHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         OpenAndConfigure
+   **
+   ** Description      Open and configure NFCC device
+   **
+   ** Parameters       pConfig     - hardware information
+   **                  pLinkHandle - device handle
+   **
+   ** Returns          NFC status:
+   **                  NFCSTATUS_SUCCESS - open_and_configure operation success
+   **                  NFCSTATUS_INVALID_DEVICE - device open operation failure
+   **
+   ****************************************************************************/
+  NFCSTATUS OpenAndConfigure(pphTmlNfc_Config_t pConfig, void **pLinkHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         Read
+   **
+   ** Description      Reads requested number of bytes from NFCC device into
+   *given
+   **                  buffer
+   **
+   ** Parameters       pDevHandle       - valid device handle
+   **                  pBuffer          - buffer for read data
+   **                  nNbBytesToRead   - number of bytes requested to be read
+   **
+   ** Returns          numRead   - number of successfully read bytes
+   **                  -1        - read operation failure
+   **
+   ****************************************************************************/
+  int Read(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToRead);
+
+  /*****************************************************************************
+  **
+  ** Function         Write
+  **
+  ** Description      Writes requested number of bytes from given buffer into
+  **                  NFCC device
+  **
+  ** Parameters       pDevHandle       - valid device handle
+  **                  pBuffer          - buffer for read data
+  **                  nNbBytesToWrite  - number of bytes requested to be written
+  **
+  ** Returns          numWrote   - number of successfully written bytes
+  **                  -1         - write operation failure
+  **
+  *****************************************************************************/
+  int Write(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToWrite);
+
+  /*****************************************************************************
+   **
+   ** Function         Reset
+   **
+   ** Description      Reset NFCC device, using VEN pin
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  level          - reset level
+   **
+   ** Returns           0   - reset operation success
+   **                  -1   - reset operation failure
+   **
+   ****************************************************************************/
+  int NfccReset(void *pDevHandle, NfccResetType eType);
+
+  /*****************************************************************************
+   **
+   ** Function         EseReset
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  eType          - EseResetType
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  int EseReset(void *pDevHandle, EseResetType eType);
+
+  /*****************************************************************************
+   **
+   ** Function         EseGetPower
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  level          - reset level
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  int EseGetPower(void *pDevHandle, long level);
+
+  /*****************************************************************************
+   **
+   ** Function         GetPlatform
+   **
+   ** Description      Get platform interface type (i2c or i3c) for common mw
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **
+   ** Returns           0   - i2c
+   **                   1   - i3c
+   **
+   ****************************************************************************/
+  int GetPlatform(void *pDevHandle);
+
+  /*****************************************************************************
+  **
+  ** Function         GetNfcState
+  **
+  ** Description      Get Nfc state
+  **
+  ** Parameters       pDevHandle     - valid device handle
+  ** Returns           0   - unknown
+  **                   1   - FW DWL
+  **                   2   - NCI
+  **
+  *****************************************************************************/
+  int GetNfcState(void *pDevHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         EnableFwDnldMode
+   **
+   ** Description      updates the state to Download mode
+   **
+   ** Parameters       True/False
+   **
+   ** Returns          None
+   ****************************************************************************/
+  void EnableFwDnldMode(bool mode);
+
+  /*****************************************************************************
+   **
+   ** Function         IsFwDnldModeEnabled
+   **
+   ** Description      Returns the current mode
+   **
+   ** Parameters       none
+   **
+   ** Returns           Current mode download/NCI
+   ****************************************************************************/
+  bool_t IsFwDnldModeEnabled(void);
+
+  /*******************************************************************************
+   **
+   ** Function         GetIrqState
+   **
+   ** Description      Get state of IRQ GPIO
+   **
+   ** Parameters       pDevHandle - valid device handle
+   **
+   ** Returns          The state of IRQ line i.e. +ve if read is pending else Zer0.
+   **                  In the case of IOCTL error, it returns -ve value.
+   **
+   *******************************************************************************/
+  int GetIrqState(void *pDevHandle);
+};
diff --git a/halimpl/tml/transport/NfccSpiTransport.cc b/halimpl/tml/transport/NfccSpiTransport.cc
new file mode 100644
index 0000000..82cf97f
--- /dev/null
+++ b/halimpl/tml/transport/NfccSpiTransport.cc
@@ -0,0 +1,533 @@
+/******************************************************************************
+ *  Copyright 2020-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <errno.h>
+#include <fcntl.h>
+#include <hardware/nfc.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/select.h>
+#include <termios.h>
+#include <unistd.h>
+
+#include "phNxpNciHal_utils.h"
+#include <NfccSpiTransport.h>
+#include <phNfcStatus.h>
+#include <phNxpLog.h>
+#include <string.h>
+
+#define CRC_LEN 2
+#define NORMAL_MODE_HEADER_LEN 3
+#define FW_DNLD_HEADER_LEN 2
+#define FW_DNLD_LEN_OFFSET 1
+#define NORMAL_MODE_LEN_OFFSET 2
+#define FRAGMENTSIZE_MAX PHNFC_I2C_FRAGMENT_SIZE
+extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
+extern phTmlNfc_Context_t *gpphTmlNfc_Context;
+/*******************************************************************************
+**
+** Function         Close
+**
+** Description      Closes NFCC device
+**
+** Parameters       pDevHandle - device handle
+**
+** Returns          None
+**
+*******************************************************************************/
+void NfccSpiTransport::Close(void *pDevHandle) {
+  if (NULL != pDevHandle) {
+    close((intptr_t)pDevHandle);
+  }
+  sem_destroy(&mTxRxSemaphore);
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         OpenAndConfigure
+**
+** Description      Open and configure NFCC device
+**
+** Parameters       pConfig     - hardware information
+**                  pLinkHandle - device handle
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - open_and_configure operation success
+**                  NFCSTATUS_INVALID_DEVICE - device open operation failure
+**
+*******************************************************************************/
+NFCSTATUS NfccSpiTransport::OpenAndConfigure(pphTmlNfc_Config_t pConfig,
+                                             void **pLinkHandle) {
+  int nHandle;
+
+  NXPLOG_TML_D("%s Opening port=%s\n", __func__, pConfig->pDevName);
+  /* open port */
+  nHandle = open((const char *)pConfig->pDevName, O_RDWR);
+  if (nHandle < 0) {
+    NXPLOG_TML_E("_i2c_open() Failed: retval %x", nHandle);
+    *pLinkHandle = NULL;
+    return NFCSTATUS_INVALID_DEVICE;
+  }
+
+  *pLinkHandle = (void *)((intptr_t)nHandle);
+  if (0 != sem_init(&mTxRxSemaphore, 0, 1)) {
+    NXPLOG_TML_E("%s Failed: reason sem_init : retval %x", __func__, nHandle);
+  }
+  /*Reset PN54X*/
+  NfccReset((void *)((intptr_t)nHandle), MODE_POWER_OFF);
+  usleep(10 * 1000);
+  NfccReset((void *)((intptr_t)nHandle), MODE_POWER_ON);
+
+  return NFCSTATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         Flushdata
+**
+** Description      Reads payload of FW rsp from NFCC device into given buffer
+**
+** Parameters       pDevHandle - valid device handle
+**                  pBuffer    - buffer for read data
+**                  numRead    - number of bytes read by calling function
+**
+** Returns          always returns -1
+**
+*******************************************************************************/
+int NfccSpiTransport::Flushdata(void* pDevHandle, uint8_t* pBuffer, int numRead) {
+  int retRead = 0;
+  uint16_t totalBtyesToRead = pBuffer[FW_DNLD_LEN_OFFSET] + FW_DNLD_HEADER_LEN + CRC_LEN;
+  /* we shall read totalBtyesToRead-1 as one byte is already read by calling function*/
+  retRead = read((intptr_t)pDevHandle, pBuffer + numRead, totalBtyesToRead - 1);
+  if (retRead > 0) {
+    numRead += retRead;
+    phNxpNciHal_print_packet("RECV", pBuffer, numRead);
+  } else if (retRead == 0) {
+    NXPLOG_TML_E("%s _i2c_read() [pyld] EOF", __func__);
+  } else {
+    if (bFwDnldFlag == false) {
+      NXPLOG_TML_D("%s _i2c_read() [hdr] received", __func__);
+      phNxpNciHal_print_packet("RECV", pBuffer - numRead, NORMAL_MODE_HEADER_LEN);
+    }
+    NXPLOG_TML_E("%s _i2c_read() [pyld] errno : %x", __func__, errno);
+  }
+  SemPost();
+  return -1;
+}
+
+/*******************************************************************************
+**
+** Function         Read
+**
+** Description      Reads requested number of bytes from NFCC device into given
+**                  buffer
+**
+** Parameters       pDevHandle       - valid device handle
+**                  pBuffer          - buffer for read data
+**                  nNbBytesToRead   - number of bytes requested to be read
+**
+** Returns          numRead   - number of successfully read bytes
+**                  -1        - read operation failure
+**
+*******************************************************************************/
+int NfccSpiTransport::Read(void *pDevHandle, uint8_t *pBuffer,
+                           int nNbBytesToRead) {
+  int ret_Read;
+  int ret_Select;
+  int numRead = 0;
+  struct timeval tv;
+  fd_set rfds;
+  uint16_t totalBtyesToRead = 0;
+
+  UNUSED(nNbBytesToRead);
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+
+  if (bFwDnldFlag == false) {
+    totalBtyesToRead = NORMAL_MODE_HEADER_LEN;
+  } else {
+    totalBtyesToRead = FW_DNLD_HEADER_LEN;
+  }
+
+  /* Read with 2 second timeout, so that the read thread can be aborted
+     when the NFCC does not respond and we need to switch to FW download
+     mode. This should be done via a control socket instead. */
+  FD_ZERO(&rfds);
+  FD_SET((intptr_t)pDevHandle, &rfds);
+  tv.tv_sec = 2;
+  tv.tv_usec = 1;
+
+  ret_Select =
+      select((int)((intptr_t)pDevHandle + (int)1), &rfds, NULL, NULL, &tv);
+  if (ret_Select < 0) {
+    NXPLOG_TML_D("%s errno : %x", __func__, errno);
+    return -1;
+  } else if (ret_Select == 0) {
+    NXPLOG_TML_D("%s Timeout", __func__);
+    return -1;
+  } else {
+    ret_Read = read((intptr_t)pDevHandle, pBuffer, totalBtyesToRead - numRead);
+    if (ret_Read > 0 && !(pBuffer[0] == 0xFF && pBuffer[1] == 0xFF)) {
+      SemTimedWait();
+      numRead += ret_Read;
+    } else if (ret_Read == 0) {
+      NXPLOG_TML_E("%s [hdr]EOF", __func__);
+      return -1;
+    } else {
+      NXPLOG_TML_E("%s [hdr] errno : %x", __func__, errno);
+      NXPLOG_TML_E(" %s pBuffer[0] = %x pBuffer[1]= %x", __func__, pBuffer[0],
+                   pBuffer[1]);
+      return -1;
+    }
+
+    if (bFwDnldFlag == false) {
+      totalBtyesToRead = NORMAL_MODE_HEADER_LEN;
+#if(NXP_EXTNS == TRUE)
+      if (gpphTmlNfc_Context->tReadInfo.pContext != NULL &&
+              !memcmp(gpphTmlNfc_Context->tReadInfo.pContext, "MinOpen", 0x07) &&
+              !pBuffer[0] && pBuffer[1]) {
+        return Flushdata(pDevHandle, pBuffer, numRead);
+      }
+#endif
+    } else {
+      totalBtyesToRead = FW_DNLD_HEADER_LEN;
+    }
+
+    if (numRead < totalBtyesToRead) {
+      ret_Read = read((intptr_t)pDevHandle, (pBuffer + numRead), totalBtyesToRead - numRead);
+
+      if (ret_Read != totalBtyesToRead - numRead) {
+        SemPost();
+        NXPLOG_TML_E("%s [hdr] errno : %x", __func__, errno);
+        return -1;
+      } else {
+        numRead += ret_Read;
+      }
+    }
+    if (bFwDnldFlag == true) {
+      totalBtyesToRead = pBuffer[FW_DNLD_LEN_OFFSET] + FW_DNLD_HEADER_LEN + CRC_LEN;
+    } else {
+      totalBtyesToRead = pBuffer[NORMAL_MODE_LEN_OFFSET] + NORMAL_MODE_HEADER_LEN;
+    }
+    if ((totalBtyesToRead - numRead) != 0) {
+      ret_Read = read((intptr_t)pDevHandle, (pBuffer + numRead), totalBtyesToRead - numRead);
+      if (ret_Read > 0) {
+        numRead += ret_Read;
+      } else if (ret_Read == 0) {
+        SemPost();
+        NXPLOG_TML_E("%s [pyld] EOF", __func__);
+        return -1;
+      } else {
+        if (bFwDnldFlag == false) {
+          NXPLOG_TML_D("_i2c_read() [hdr] received");
+          phNxpNciHal_print_packet("RECV", pBuffer, NORMAL_MODE_HEADER_LEN);
+        }
+        SemPost();
+        NXPLOG_TML_E("%s [pyld] errno : %x", __func__, errno);
+        return -1;
+      }
+    } else {
+      NXPLOG_TML_E("%s _>>>>> Empty packet recieved !!", __func__);
+    }
+  }
+  SemPost();
+  return numRead;
+}
+
+/*******************************************************************************
+**
+** Function         Write
+**
+** Description      Writes requested number of bytes from given buffer into
+**                  NFCC device
+**
+** Parameters       pDevHandle       - valid device handle
+**                  pBuffer          - buffer for read data
+**                  nNbBytesToWrite  - number of bytes requested to be written
+**
+** Returns          numWrote   - number of successfully written bytes
+**                  -1         - write operation failure
+**
+*******************************************************************************/
+int NfccSpiTransport::Write(void *pDevHandle, uint8_t *pBuffer,
+                            int nNbBytesToWrite) {
+  int ret;
+  int numWrote = 0;
+  int numBytes = nNbBytesToWrite;
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+  if (fragmentation_enabled == I2C_FRAGMENATATION_DISABLED &&
+      nNbBytesToWrite > FRAGMENTSIZE_MAX) {
+    NXPLOG_TML_D(
+        "%s data larger than maximum I2C  size,enable I2C fragmentation",
+        __func__);
+    return -1;
+  }
+  while (numWrote < nNbBytesToWrite) {
+    if (fragmentation_enabled == I2C_FRAGMENTATION_ENABLED &&
+        nNbBytesToWrite > FRAGMENTSIZE_MAX) {
+      if (nNbBytesToWrite - numWrote > FRAGMENTSIZE_MAX) {
+        numBytes = numWrote + FRAGMENTSIZE_MAX;
+      } else {
+        numBytes = nNbBytesToWrite;
+      }
+    }
+    SemTimedWait();
+    ret = write((intptr_t)pDevHandle, pBuffer + numWrote, numBytes - numWrote);
+    SemPost();
+    if (ret > 0) {
+      numWrote += ret;
+      if (fragmentation_enabled == I2C_FRAGMENTATION_ENABLED &&
+          numWrote < nNbBytesToWrite) {
+        usleep(500);
+      }
+    } else if (ret == 0) {
+      NXPLOG_TML_D("%s EOF", __func__);
+      return -1;
+    } else {
+      NXPLOG_TML_D("%s errno : %x", __func__, errno);
+      if (errno == EINTR || errno == EAGAIN) {
+        continue;
+      }
+      return -1;
+    }
+  }
+
+  return numWrote;
+}
+
+/*******************************************************************************
+**
+** Function         NfccReset
+**
+** Description      Reset NFCC device, using VEN pin
+**
+** Parameters       pDevHandle     - valid device handle
+**                  eType          - reset level
+**
+** Returns           0   - reset operation success
+**                  -1   - reset operation failure
+**
+*******************************************************************************/
+int NfccSpiTransport::NfccReset(void *pDevHandle, NfccResetType eType) {
+  int ret = -1;
+  NXPLOG_TML_D("%s, VEN eType %ld", __func__, eType);
+
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+
+  ret = ioctl((intptr_t)pDevHandle, NFC_SET_PWR, eType);
+  if (ret < 0) {
+    NXPLOG_TML_E("%s :failed errno = 0x%x", __func__, errno);
+  }
+  if ((eType != MODE_FW_DWNLD_WITH_VEN && eType != MODE_FW_DWND_HIGH) &&
+      ret == 0) {
+    EnableFwDnldMode(false);
+  }
+  if ((((eType == MODE_FW_DWNLD_WITH_VEN) || (eType == MODE_FW_DWND_HIGH)) && (ret == 0))) {
+    EnableFwDnldMode(true);
+  }
+
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         EseReset
+**
+** Description      Request NFCC to reset the eSE
+**
+** Parameters       pDevHandle     - valid device handle
+**                  eType          - EseResetType
+**
+** Returns           0   - reset operation success
+**                  else - reset operation failure
+**
+*******************************************************************************/
+int NfccSpiTransport::EseReset(void *pDevHandle, EseResetType eType) {
+  int ret = -1;
+  NXPLOG_TML_D("%s, eType %ld", __func__, eType);
+
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+  ret = ioctl((intptr_t)pDevHandle, ESE_SET_PWR, eType);
+  if (ret < 0) {
+    NXPLOG_TML_E("%s :failed errno = 0x%x", __func__, errno);
+  }
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         EseGetPower
+**
+** Description      Request NFCC to reset the eSE
+**
+** Parameters       pDevHandle     - valid device handle
+**                  level          - reset level
+**
+** Returns           0   - reset operation success
+**                  else - reset operation failure
+**
+*******************************************************************************/
+int NfccSpiTransport::EseGetPower(void *pDevHandle, long level) {
+  return ioctl((intptr_t)pDevHandle, ESE_GET_PWR, level);
+}
+
+/*******************************************************************************
+**
+** Function         GetPlatform
+**
+** Description      Get platform interface type (i2c or i3c) for common mw
+**
+** Parameters       pDevHandle     - valid device handle
+**
+** Returns           0   - i2c
+**                   1   - i3c
+**
+*******************************************************************************/
+int NfccSpiTransport::GetPlatform(void *pDevHandle) {
+  int ret = -1;
+  NXPLOG_TML_D("%s ", __func__);
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+  ret = ioctl((intptr_t)pDevHandle, NFC_GET_PLATFORM_TYPE);
+  NXPLOG_TML_D("%s :platform = %d", __func__, ret);
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         GetNfcState
+**
+** Description      Get NFC state
+**
+** Parameters       pDevHandle     - valid device handle
+** Returns           0   - unknown
+**                   1   - FW DWL
+**                   2 	 - NCI
+**
+*******************************************************************************/
+int NfccSpiTransport::GetNfcState(void *pDevHandle) {
+  int ret = NFC_STATE_UNKNOWN;
+  NXPLOG_TML_D("%s ", __func__);
+  if (NULL == pDevHandle) {
+    return ret;
+  }
+  ret = ioctl((intptr_t)pDevHandle, NFC_GET_NFC_STATE);
+  NXPLOG_TML_D("%s :nfc state = %d", __func__, ret);
+  return ret;
+}
+/*******************************************************************************
+**
+** Function         EnableFwDnldMode
+**
+** Description      updates the state to Download mode
+**
+** Parameters       True/False
+**
+** Returns          None
+*******************************************************************************/
+void NfccSpiTransport::EnableFwDnldMode(bool mode) { bFwDnldFlag = mode; }
+
+/*******************************************************************************
+**
+** Function         IsFwDnldModeEnabled
+**
+** Description      Returns the current mode
+**
+** Parameters       none
+**
+** Returns           Current mode download/NCI
+*******************************************************************************/
+bool_t NfccSpiTransport::IsFwDnldModeEnabled(void) { return bFwDnldFlag; }
+
+/*******************************************************************************
+**
+** Function         SemPost
+**
+** Description      sem_post 2c_read / write
+**
+** Parameters       none
+**
+** Returns          none
+*******************************************************************************/
+void NfccSpiTransport::SemPost() {
+  int sem_val = 0;
+  sem_getvalue(&mTxRxSemaphore, &sem_val);
+  if (sem_val == 0) {
+    sem_post(&mTxRxSemaphore);
+  }
+}
+
+/*******************************************************************************
+**
+** Function         SemTimedWait
+**
+** Description      Timed sem_wait for avoiding i2c_read & write overlap
+**
+** Parameters       none
+**
+** Returns          Sem_wait return status
+*******************************************************************************/
+int NfccSpiTransport::SemTimedWait() {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  long sem_timedout = 500 * 1000 * 1000;
+  int s = 0;
+  struct timespec ts;
+  clock_gettime(CLOCK_REALTIME, &ts);
+  ts.tv_sec += 0;
+  ts.tv_nsec += sem_timedout;
+  while ((s = sem_timedwait(&mTxRxSemaphore, &ts)) == -1 && errno == EINTR) {
+    continue; /* Restart if interrupted by handler */
+  }
+  if (s != -1) {
+    status = NFCSTATUS_SUCCESS;
+  } else if (errno == ETIMEDOUT && s == -1) {
+    NXPLOG_TML_E("%s :timed out errno = 0x%x", __func__, errno);
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         GetIrqState
+**
+** Description      Get state of IRQ GPIO
+**
+** Parameters       pDevHandle - valid device handle
+**
+** Returns          The state of IRQ line i.e. +ve if read is pending else Zer0.
+**                  In the case of IOCTL error, it returns -ve value.
+**
+*******************************************************************************/
+int NfccSpiTransport::GetIrqState(void *pDevHandle) {
+  int ret = -1;
+
+  NXPLOG_TML_D("%s Enter",__func__);
+  if (NULL != pDevHandle) {
+    ret = ioctl((intptr_t)pDevHandle, NFC_GET_IRQ_STATE);
+  }
+  NXPLOG_TML_D("%s exit: state = %d", __func__, ret);
+  return ret;
+}
diff --git a/halimpl/tml/transport/NfccSpiTransport.h b/halimpl/tml/transport/NfccSpiTransport.h
new file mode 100644
index 0000000..d46ca18
--- /dev/null
+++ b/halimpl/tml/transport/NfccSpiTransport.h
@@ -0,0 +1,266 @@
+/******************************************************************************
+ *
+ *  Copyright 2020-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#pragma once
+#include <NfccTransport.h>
+
+#define NFC_MAGIC 0xE9
+/*
+ * NFCC power control via ioctl
+ * NFC_SET_PWR(0): power off
+ * NFC_SET_PWR(1): power on
+ * NFC_SET_PWR(2): reset and power on with firmware download enabled
+ */
+#define NFC_SET_PWR _IOW(NFC_MAGIC, 0x01, long)
+/*
+ * 1. SPI Request NFCC to enable ESE power, only in param
+ *   Only for SPI
+ *   level 1 = Enable power
+ *   level 0 = Disable power
+ * 2. NFC Request the eSE cold reset, only with MODE_ESE_COLD_RESET
+ */
+#define ESE_SET_PWR _IOW(NFC_MAGIC, 0x02, long)
+
+/*
+ * SPI or DWP can call this ioctl to get the current
+ * power state of ESE
+ */
+#define ESE_GET_PWR _IOR(NFC_MAGIC, 0x03, long)
+
+/*
+ * get platform interface type(i2c or i3c) for common MW
+ * return 0 - i2c, 1 - i3c
+ */
+#define NFC_GET_PLATFORM_TYPE _IO(NFC_MAGIC, 0x04)
+/*
+ * get boot state
+ * return unknown, fw dwl, fw teared, nci
+ */
+#define NFC_GET_NFC_STATE _IO(NFC_MAGIC, 0x05)
+
+/* NFC HAL can call this ioctl to get the current IRQ state */
+#define NFC_GET_IRQ_STATE _IO(NFC_MAGIC, 0x06)
+
+extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
+
+class NfccSpiTransport : public NfccTransport {
+ private:
+  bool_t bFwDnldFlag = false;
+  sem_t mTxRxSemaphore;
+  /*****************************************************************************
+   **
+   ** Function         SemTimedWait
+   **
+   ** Description      Timed sem_wait for avoiding i2c_read & write overlap
+   **
+   ** Parameters       none
+   **
+   ** Returns          Sem_wait return status
+   ****************************************************************************/
+  int SemTimedWait();
+
+  /*****************************************************************************
+   **
+   ** Function         SemPost
+   **
+   ** Description      sem_post 2c_read / write
+   **
+   ** Parameters       none
+   **
+   ** Returns          none
+   ****************************************************************************/
+  void SemPost();
+
+  int Flushdata(void* pDevHandle, uint8_t* pBuffer, int numRead);
+
+ public:
+  /*****************************************************************************
+  **
+  ** Function         Close
+  **
+  ** Description      Closes NFCC device
+  **
+  ** Parameters       pDevHandle - device handle
+  **
+  ** Returns          None
+  **
+  *****************************************************************************/
+  void Close(void *pDevHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         OpenAndConfigure
+   **
+   ** Description      Open and configure NFCC device
+   **
+   ** Parameters       pConfig     - hardware information
+   **                  pLinkHandle - device handle
+   **
+   ** Returns          NFC status:
+   **                  NFCSTATUS_SUCCESS - open_and_configure operation success
+   **                  NFCSTATUS_INVALID_DEVICE - device open operation failure
+   **
+   ****************************************************************************/
+  NFCSTATUS OpenAndConfigure(pphTmlNfc_Config_t pConfig, void **pLinkHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         Read
+   **
+   ** Description      Reads requested number of bytes from NFCC device into
+   *given
+   **                  buffer
+   **
+   ** Parameters       pDevHandle       - valid device handle
+   **                  pBuffer          - buffer for read data
+   **                  nNbBytesToRead   - number of bytes requested to be read
+   **
+   ** Returns          numRead   - number of successfully read bytes
+   **                  -1        - read operation failure
+   **
+   ****************************************************************************/
+  int Read(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToRead);
+
+  /*****************************************************************************
+  **
+  ** Function         Write
+  **
+  ** Description      Writes requested number of bytes from given buffer into
+  **                  NFCC device
+  **
+  ** Parameters       pDevHandle       - valid device handle
+  **                  pBuffer          - buffer for read data
+  **                  nNbBytesToWrite  - number of bytes requested to be written
+  **
+  ** Returns          numWrote   - number of successfully written bytes
+  **                  -1         - write operation failure
+  **
+  *****************************************************************************/
+  int Write(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToWrite);
+
+  /*****************************************************************************
+   **
+   ** Function         NfccReset
+   **
+   ** Description      Reset NFCC device, using VEN pin
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  level          - reset level
+   **
+   ** Returns           0   - reset operation success
+   **                  -1   - reset operation failure
+   **
+   ****************************************************************************/
+  int NfccReset(void *pDevHandle, NfccResetType eType);
+
+  /*****************************************************************************
+   **
+   ** Function         EseReset
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  eType          - EseResetType
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  int EseReset(void *pDevHandle, EseResetType eType);
+
+  /*****************************************************************************
+   **
+   ** Function         EseGetPower
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  level          - reset level
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  int EseGetPower(void *pDevHandle, long level);
+
+  /*****************************************************************************
+   **
+   ** Function         GetPlatform
+   **
+   ** Description      Get platform interface type (i2c or i3c) for common mw
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **
+   ** Returns           0   - i2c
+   **                   1   - i3c
+   **
+   ****************************************************************************/
+  int GetPlatform(void *pDevHandle);
+
+  /*****************************************************************************
+  **
+  ** Function         GetNfcState
+  **
+  ** Description      Get Nfc state
+  **
+  ** Parameters       pDevHandle     - valid device handle
+  ** Returns           0   - unknown
+  **                   1   - FW DWL
+  **                   2   - NCI
+  **
+  *****************************************************************************/
+  int GetNfcState(void *pDevHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         EnableFwDnldMode
+   **
+   ** Description      updates the state to Download mode
+   **
+   ** Parameters       True/False
+   **
+   ** Returns          None
+   ****************************************************************************/
+  void EnableFwDnldMode(bool mode);
+
+  /*****************************************************************************
+   **
+   ** Function         IsFwDnldModeEnabled
+   **
+   ** Description      Returns the current mode
+   **
+   ** Parameters       none
+   **
+   ** Returns           Current mode download/NCI
+   ****************************************************************************/
+  bool_t IsFwDnldModeEnabled(void);
+
+  /*******************************************************************************
+   **
+   ** Function         GetIrqState
+   **
+   ** Description      Get state of IRQ GPIO
+   **
+   ** Parameters       pDevHandle - valid device handle
+   **
+   ** Returns          The state of IRQ line i.e. +ve if read is pending else Zer0.
+   **                  In the case of IOCTL error, it returns -ve value.
+   **
+   *******************************************************************************/
+  int GetIrqState(void *pDevHandle);
+};
diff --git a/halimpl/tml/transport/NfccTransport.cc b/halimpl/tml/transport/NfccTransport.cc
new file mode 100644
index 0000000..4380035
--- /dev/null
+++ b/halimpl/tml/transport/NfccTransport.cc
@@ -0,0 +1,50 @@
+/******************************************************************************
+ *
+ *  Copyright 2020-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <NfccTransport.h>
+
+int NfccTransport::NfccReset(__attribute__((unused)) void *pDevHandle,
+                             __attribute__((unused)) NfccResetType eType) {
+  return NFCSTATUS_SUCCESS;
+}
+
+int NfccTransport::EseReset(__attribute__((unused)) void *pDevHandle,
+                            __attribute__((unused)) EseResetType eType) {
+  return NFCSTATUS_SUCCESS;
+}
+int NfccTransport::EseGetPower(__attribute__((unused)) void *pDevHandle,
+                               __attribute__((unused)) long level) {
+  return NFCSTATUS_SUCCESS;
+}
+
+int NfccTransport::GetPlatform(__attribute__((unused)) void *pDevHandle) {
+  return 0x00;
+}
+
+int NfccTransport::GetNfcState(__attribute__((unused)) void *pDevHandle) {
+  return NFC_STATE_UNKNOWN;
+}
+
+void NfccTransport::EnableFwDnldMode(__attribute__((unused)) bool mode) {
+  return;
+}
+int NfccTransport::GetIrqState(__attribute__((unused)) void *pDevHandle) {
+  return -1;
+}
+
+bool_t NfccTransport::IsFwDnldModeEnabled(void) { return false; }
diff --git a/halimpl/tml/transport/NfccTransport.h b/halimpl/tml/transport/NfccTransport.h
new file mode 100644
index 0000000..2d2f2d3
--- /dev/null
+++ b/halimpl/tml/transport/NfccTransport.h
@@ -0,0 +1,246 @@
+/******************************************************************************
+ *
+ *  Copyright 2020-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#pragma once
+#include <phNfcTypes.h>
+#include <phTmlNfc.h>
+
+enum NfccResetType : long {
+  MODE_POWER_OFF = 0x00,
+  MODE_POWER_ON,
+  MODE_FW_DWNLD_WITH_VEN,
+  MODE_ISO_RST,
+  MODE_FW_DWND_HIGH,
+  MODE_POWER_RESET,
+  MODE_FW_GPIO_LOW
+};
+
+enum EseResetCallSrc : long {
+  SRC_SPI = 0x0,
+  SRC_NFC = 0x10,
+};
+
+enum EseResetType : long {
+  MODE_ESE_POWER_ON = 0,
+  MODE_ESE_POWER_OFF,
+  MODE_ESE_POWER_STATE,
+  /*Request from eSE HAL/Service*/
+  MODE_ESE_COLD_RESET,
+  MODE_ESE_RESET_PROTECTION_ENABLE,
+  MODE_ESE_RESET_PROTECTION_DISABLE,
+  /*Request from NFC HAL/Service*/
+  MODE_ESE_COLD_RESET_NFC = MODE_ESE_COLD_RESET | SRC_NFC,
+  MODE_ESE_RESET_PROTECTION_ENABLE_NFC =
+      MODE_ESE_RESET_PROTECTION_ENABLE | SRC_NFC,
+  MODE_ESE_RESET_PROTECTION_DISABLE_NFC =
+      MODE_ESE_RESET_PROTECTION_DISABLE | SRC_NFC,
+};
+
+extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
+
+class NfccTransport {
+public:
+  /*****************************************************************************
+   **
+   ** Function         Close
+   **
+   ** Description      Closes NFCC device
+   **
+   ** Parameters       pDevHandle - device handle
+   **
+   ** Returns          None
+   **
+   *****************************************************************************/
+  virtual void Close(void *pDevHandle) = 0;
+
+  /*****************************************************************************
+   **
+   ** Function         OpenAndConfigure
+   **
+   ** Description      Open and configure NFCC device and transport layer
+   **
+   ** Parameters       pConfig     - hardware information
+   **                  pLinkHandle - device handle
+   **
+   ** Returns          NFC status:
+   **                  NFCSTATUS_SUCCESS - open_and_configure operation success
+   **                  NFCSTATUS_INVALID_DEVICE - device open operation failure
+   **
+   ****************************************************************************/
+  virtual NFCSTATUS OpenAndConfigure(pphTmlNfc_Config_t pConfig,
+                                     void **pLinkHandle) = 0;
+
+  /*****************************************************************************
+   **
+   ** Function         Read
+   **
+   ** Description      Reads requested number of bytes from NFCC device into
+   **                 given buffer
+   **
+   ** Parameters       pDevHandle       - valid device handle
+   **                  pBuffer          - buffer for read data
+   **                  nNbBytesToRead   - number of bytes requested to be read
+   **
+   ** Returns          numRead   - number of successfully read bytes
+   **                  -1        - read operation failure
+   **
+   ****************************************************************************/
+  virtual int Read(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToRead) = 0;
+
+  /*****************************************************************************
+   **
+   ** Function         Write
+   **
+   ** Description      Writes requested number of bytes from given buffer into
+   **                  NFCC device
+   **
+   ** Parameters       pDevHandle       - valid device handle
+   **                  pBuffer          - buffer for read data
+   **                  nNbBytesToWrite  - number of bytes requested to be
+   *written
+   **
+   ** Returns          numWrote   - number of successfully written bytes
+   **                  -1         - write operation failure
+   **
+   *****************************************************************************/
+  virtual int Write(void *pDevHandle, uint8_t *pBuffer,
+                    int nNbBytesToWrite) = 0;
+
+  /*****************************************************************************
+   **
+   ** Function         Reset
+   **
+   ** Description      Reset NFCC device, using VEN pin
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  eType          - NfccResetType
+   **
+   ** Returns           0   - reset operation success
+   **                  -1   - reset operation failure
+   **
+   ****************************************************************************/
+  virtual int NfccReset(void *pDevHandle, NfccResetType eType);
+
+  /*****************************************************************************
+  **
+  ** Function         GetNfcState
+  **
+  ** Description      Get NFC state
+  **
+  ** Parameters       pDevHandle     - valid device handle
+  ** Returns           0   - unknown
+  **                   1   - FW DWL
+  **                   2   - NCI
+  **
+  *****************************************************************************/
+  virtual int GetNfcState(void *pDevHandle);
+  /*****************************************************************************
+   **
+   ** Function         EseReset
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  eType          - EseResetType
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  virtual int EseReset(void *pDevHandle, EseResetType eType);
+
+  /*****************************************************************************
+   **
+   ** Function         EseGetPower
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  level          - reset level
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  virtual int EseGetPower(void *pDevHandle, long level);
+
+  /*****************************************************************************
+   **
+   ** Function         GetPlatform
+   **
+   ** Description      Get platform interface type (i2c or i3c) for common mw
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **
+   ** Returns           0   - i2c
+   **                   1   - i3c
+   **
+   ****************************************************************************/
+  virtual int GetPlatform(void *pDevHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         EnableFwDnldMode
+   **
+   ** Description      updates the state to Download mode
+   **
+   ** Parameters       True/False
+   **
+   ** Returns          None
+   ****************************************************************************/
+  virtual void EnableFwDnldMode(bool mode);
+
+  /*****************************************************************************
+   **
+   ** Function         IsFwDnldModeEnabled
+   **
+   ** Description      Returns the current mode
+   **
+   ** Parameters       none
+   **
+   ** Returns          Current mode download/NCI
+   ****************************************************************************/
+  virtual bool_t IsFwDnldModeEnabled(void);
+
+  /*******************************************************************************
+   **
+   ** Function         GetIrqState
+   **
+   ** Description      Get state of IRQ GPIO
+   **
+   ** Parameters       pDevHandle - valid device handle
+   **
+   ** Returns          The state of IRQ line i.e. +ve if read is pending else
+   *Zer0.
+   **                  In the case of IOCTL error, it returns -ve value.
+   **
+   *******************************************************************************/
+  virtual int GetIrqState(void *pDevHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         ~NfccTransport
+   **
+   ** Description      TransportLayer destructor
+   **
+   ** Parameters       none
+   **
+   ** Returns          None
+   ****************************************************************************/
+  virtual ~NfccTransport(){};
+};
diff --git a/intf/nxpnfc/1.0/manifest.xml b/intf/nxpnfc/1.0/manifest.xml
index ceabdbd..fcb4033 100644
--- a/intf/nxpnfc/1.0/manifest.xml
+++ b/intf/nxpnfc/1.0/manifest.xml
@@ -3,12 +3,20 @@
         <name>android.hardware.nfc</name>
         <transport>hwbinder</transport>
         <impl level="generic"></impl>
-        <version>1.0</version>
+        <version>1.1</version>
+        <interface>
+            <name>INfc</name>
+            <instance>default</instance>
+        </interface>
     </hal>
     <hal format="hidl">
         <name>vendor.nxp.nxpnfc</name>
         <transport>hwbinder</transport>
         <impl level="generic"></impl>
         <version>1.0</version>
+        <interface>
+            <name>INfc</name>
+            <instance>default</instance>
+        </interface>
     </hal>
 </manifest>
diff --git a/pn8x/1.1/Nfc.h b/pn8x/1.1/Nfc.h
index ef467de..5c06b04 100755
--- a/pn8x/1.1/Nfc.h
+++ b/pn8x/1.1/Nfc.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- *  Copyright 2018 NXP
+ *  Copyright 2018,2021 NXP
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -95,7 +95,7 @@ struct Nfc : public V1_1::INfc, public hidl_death_recipient {
   }
 
   virtual void serviceDied(uint64_t /*cookie*/, const wp<IBase>& /*who*/) {
-    close();
+    abort();
   }
 
  private:
diff --git a/pn8x/Android.bp b/pn8x/Android.bp
index f196c5a..ede2cb6 100644
--- a/pn8x/Android.bp
+++ b/pn8x/Android.bp
@@ -32,6 +32,7 @@ cc_library_shared {
         "-Wextra",
         // Allow implicit fallthroughs in phDnldNfc_Internal.cc and phNxpConfig.cpp until they are fixed.
         "-Wno-implicit-fallthrough",
+	"-DNXP_EXTNS=TRUE",
     ],
 
     srcs: [
@@ -49,7 +50,8 @@ cc_library_shared {
         "halimpl/tml/phDal4Nfc_messageQueueLib.cc",
         "halimpl/tml/phOsalNfc_Timer.cc",
         "halimpl/tml/phTmlNfc.cc",
-        "halimpl/tml/phTmlNfc_i2c.cc",
+        "halimpl/tml/NfccTransportFactory.cc",
+        "halimpl/tml/transport/*.cc",
         "halimpl/tml/spi_spm.cc",
         "halimpl/utils/NxpNfcCapability.cpp",
         "halimpl/utils/phNxpConfig.cpp",
@@ -60,12 +62,14 @@ cc_library_shared {
     ],
 
     local_include_dirs: [
+        "halimpl/common",
         "halimpl/dnld",
         "halimpl/hal",
         "halimpl/log",
         "halimpl/self-test",
         "halimpl/src/include",
         "halimpl/tml",
+        "halimpl/tml/transport",
         "halimpl/utils",
         "halimpl/mifare",
     ],
diff --git a/pn8x/extns/impl/Nxp_Features.h b/pn8x/extns/impl/Nxp_Features.h
index 48f1745..cdc86bd 100755
--- a/pn8x/extns/impl/Nxp_Features.h
+++ b/pn8x/extns/impl/Nxp_Features.h
@@ -25,7 +25,9 @@
 #define FW_MOBILE_MAJOR_NUMBER_PN81A 0x02
 #define FW_MOBILE_MAJOR_NUMBER_PN551 0x05
 #define FW_MOBILE_MAJOR_NUMBER_PN557 0x01
-using namespace std;
+#define FW_MOBILE_MAJOR_NUMBER_PN548AD 0x01
+
+ using namespace std;
 typedef enum {
   unknown,
   pn547C2,
@@ -60,6 +62,8 @@ extern tNfc_featureList nfcFL;
       nfcFL.chipType = pn553;            \
     } else if (chipType == pn67T) {      \
       nfcFL.chipType = pn551;            \
+    } else if (chipType == pn66T) {      \
+      nfcFL.chipType = pn548C2;          \
     }                                    \
     CONFIGURE_FEATURELIST_NFCC(chipType) \
   }
@@ -70,8 +74,8 @@ extern tNfc_featureList nfcFL;
     nfcFL._PHDNLDNFC_USERDATA_EEPROM_LEN = 0x0C80U;                 \
                                                                     \
     if (chipType == pn557 || chipType == pn81T) {                   \
-      STRCPY_FW_LIB("libpn557_fw")                                  \
-      STRCPY_FW_BIN("pn557")                                        \
+      STRCPY_FW_LIB("libpn7160_fw")                                 \
+      STRCPY_FW_BIN("pn7160")                                       \
                                                                     \
       nfcFL._FW_MOBILE_MAJOR_NUMBER = FW_MOBILE_MAJOR_NUMBER_PN557; \
     } else if (chipType == pn553 || chipType == pn80T) {            \
@@ -87,7 +91,16 @@ extern tNfc_featureList nfcFL;
       nfcFL._PHDNLDNFC_USERDATA_EEPROM_OFFSET = 0x02BCU;            \
       nfcFL._PHDNLDNFC_USERDATA_EEPROM_LEN = 0x0C00U;               \
       nfcFL._FW_MOBILE_MAJOR_NUMBER = FW_MOBILE_MAJOR_NUMBER_PN551; \
-    }                                                               \
+                                                                            \
+    } else if (chipType == pn548C2 || chipType == pn66T) {                  \
+                                                                            \
+      STRCPY_FW_LIB("libpn548ad_fw")                                        \
+      STRCPY_FW_BIN("pn548")                                                \
+                                                                            \
+      nfcFL._PHDNLDNFC_USERDATA_EEPROM_OFFSET = 0x02BCU;                    \
+      nfcFL._PHDNLDNFC_USERDATA_EEPROM_LEN = 0x0C00U;                       \
+      nfcFL._FW_MOBILE_MAJOR_NUMBER = FW_MOBILE_MAJOR_NUMBER_PN548AD;       \
+     }                                                                      \
   }
 #define STRCPY_FW_LIB(str)                       \
   {                                              \
diff --git a/pn8x/extns/impl/hal_nxpnfc.h b/pn8x/extns/impl/hal_nxpnfc.h
index ac1b1ed..64168fb 100755
--- a/pn8x/extns/impl/hal_nxpnfc.h
+++ b/pn8x/extns/impl/hal_nxpnfc.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- *  Copyright 2018 NXP
+ *  Copyright 2018,2021 NXP
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -27,6 +27,11 @@ enum {
   // HAL_NFC_ENABLE_I2C_FRAGMENTATION_EVT = 0x07,
   HAL_NFC_POST_MIN_INIT_CPLT_EVT = 0x08
 };
+
+enum {
+  HAL_NFC_GET_NXP_CONFIG = 30,
+};
+
 /*
  * Data structures provided below are used of Hal Ioctl calls
  */
@@ -76,6 +81,12 @@ typedef struct {
   long level;
 } nfc_nci_ExtnInputData_t;
 
+typedef struct {
+  uint8_t wAgcDebugEnable;
+  uint8_t wT4TNdefEnable;
+  uint8_t wT4TPowerState;
+} nxp_nfc_config_t;
+
 /*
  * outputData_t :ioctl has multiple commands/responses
  * This contains the output types for each ioctl.
@@ -89,6 +100,7 @@ typedef union {
   uint16_t fwDwnldStatus;
   uint16_t fwMwVerStatus;
   uint8_t chipType;
+  nxp_nfc_config_t nxpConfigs;
 } outputData_t;
 
 /*
diff --git a/pn8x/halimpl/common/phNfcCommon.h b/pn8x/halimpl/common/phNfcCommon.h
index 919b191..afe4f5d 100755
--- a/pn8x/halimpl/common/phNfcCommon.h
+++ b/pn8x/halimpl/common/phNfcCommon.h
@@ -33,7 +33,14 @@
 #include <pthread.h>
 #include <semaphore.h>
 
+#ifndef FW_LIB_ROOT_DIR
+#ifdef __LP64__
+#define FW_LIB_ROOT_DIR "/vendor/lib64/"
+#else
 #define FW_LIB_ROOT_DIR "/vendor/lib/"
+#endif
+#endif
+
 #define FW_BIN_ROOT_DIR "/vendor/firmware/"
 #define FW_LIB_EXTENSION ".so"
 #define FW_BIN_EXTENSION ".bin"
diff --git a/pn8x/halimpl/dnld/phDnldNfc.cc b/pn8x/halimpl/dnld/phDnldNfc.cc
index 2427226..389fe6f 100644
--- a/pn8x/halimpl/dnld/phDnldNfc.cc
+++ b/pn8x/halimpl/dnld/phDnldNfc.cc
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2014 NXP Semiconductors
+ * Copyright (C) 2010-2014,2021 NXP Semiconductors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -243,6 +243,8 @@ NFCSTATUS phDnldNfc_CheckIntegrity(uint8_t bChipVer, pphDnldNfc_Buff_t pCRCData,
     } else {
       if ((PHDNLDNFC_HWVER_MRA2_1 == bChipVer) ||
           (PHDNLDNFC_HWVER_MRA2_2 == bChipVer) ||
+          ((nfcFL.chipType == pn548C2) &&
+           (PHDNLDNFC_HWVER_PN548AD_MRA1_0 == bChipVer)) ||
           ((nfcFL.chipType == pn551) &&
            (PHDNLDNFC_HWVER_PN551_MRA1_0 == bChipVer)) ||
           (((nfcFL.chipType == pn553) || (nfcFL.chipType == pn557)) &&
diff --git a/pn8x/halimpl/dnld/phDnldNfc.h b/pn8x/halimpl/dnld/phDnldNfc.h
index ae672ef..2d254bb 100755
--- a/pn8x/halimpl/dnld/phDnldNfc.h
+++ b/pn8x/halimpl/dnld/phDnldNfc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2014 NXP Semiconductors
+ * Copyright (C) 2010-2014,2021 NXP Semiconductors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -43,6 +43,8 @@ typedef void (*pphDnldNfc_RspCb_t)(void* pContext, NFCSTATUS wStatus,
 #define PHDNLDNFC_HWVER_MRA2_1 (0x04U) /* ChipVersion MRA2.1 */
 #define PHDNLDNFC_HWVER_MRA2_2 (0x05U) /* ChipVersion MRA2.2 */
 
+/* PN548AD ChipVersion MRA1.0 */
+#define PHDNLDNFC_HWVER_PN548AD_MRA1_0 (0x08U)
 /* PN551 ChipVersion MRA1.0 */
 #define PHDNLDNFC_HWVER_PN551_MRA1_0 (0x08U)
 /* PN553-NCI1.0 ChipVersion MRA1.0 */
diff --git a/pn8x/halimpl/dnld/phNxpNciHal_Dnld.cc b/pn8x/halimpl/dnld/phNxpNciHal_Dnld.cc
index 247b24e..9d4787e 100644
--- a/pn8x/halimpl/dnld/phNxpNciHal_Dnld.cc
+++ b/pn8x/halimpl/dnld/phNxpNciHal_Dnld.cc
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2014 NXP Semiconductors
+ * Copyright (C) 2012-2014,2021 NXP Semiconductors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -530,6 +530,8 @@ static void phNxpNciHal_fw_dnld_get_version_cb(void* pContext, NFCSTATUS status,
 
       if ((PHDNLDNFC_HWVER_MRA2_1 == bHwVer) ||
           (PHDNLDNFC_HWVER_MRA2_2 == bHwVer) ||
+          ((nfcFL.chipType == pn548C2) &&
+           (PHDNLDNFC_HWVER_PN548AD_MRA1_0 == bHwVer)) ||
           ((nfcFL.chipType == pn551) &&
            (PHDNLDNFC_HWVER_PN551_MRA1_0 == bHwVer)) ||
           (((nfcFL.chipType == pn553) || (nfcFL.chipType == pn557)) &&
diff --git a/pn8x/halimpl/hal/phNxpNciHal.cc b/pn8x/halimpl/hal/phNxpNciHal.cc
index 1ce5b87..2515d39 100644
--- a/pn8x/halimpl/hal/phNxpNciHal.cc
+++ b/pn8x/halimpl/hal/phNxpNciHal.cc
@@ -51,6 +51,8 @@ static uint8_t cmd_icode_eof[] = {0x00, 0x00, 0x00};
 
 /* FW download success flag */
 static uint8_t fw_download_success = 0;
+/* Anti-tearing mechanism sucess flag */
+uint8_t anti_tearing_recovery_success = 0;
 
 static uint8_t config_access = false;
 static uint8_t config_success = true;
@@ -79,6 +81,8 @@ static uint8_t gRecFwRetryCount;  // variable to hold recovery FW retry count
 static uint8_t Rx_data[NCI_MAX_DATA_LEN];
 extern int phPalEse_spi_ioctl(phPalEse_ControlCode_t eControlCode,
                               void* pDevHandle, long level);
+uint8_t discovery_cmd[50] = {0};
+uint8_t discovery_cmd_len = 0;
 uint32_t timeoutTimerId = 0;
 bool nfc_debug_enabled = true;
 static bool sIsForceFwDownloadReqd = false;
@@ -118,6 +122,7 @@ static NFCSTATUS phNxpNciHal_CheckValidFwVersion(void);
 static void phNxpNciHal_enable_i2c_fragmentation();
 static NFCSTATUS phNxpNciHal_get_mw_eeprom(void);
 static NFCSTATUS phNxpNciHal_set_mw_eeprom(void);
+static NFCSTATUS phNxpNciHal_config_t4t_ndef(uint8_t t4tFlag);
 static int phNxpNciHal_fw_mw_ver_check();
 NFCSTATUS phNxpNciHal_check_clock_config(void);
 NFCSTATUS phNxpNciHal_china_tianjin_rf_setting(void);
@@ -322,6 +327,7 @@ static NFCSTATUS phNxpNciHal_fw_download(void) {
     return NFCSTATUS_REJECTED;
   }
 
+#if(NXP_EXTNS != TRUE)
   nfc_nci_IoctlInOutData_t data;
   memset(&data, 0x00, sizeof(nfc_nci_IoctlInOutData_t));
   data.inp.level =
@@ -332,8 +338,11 @@ static NFCSTATUS phNxpNciHal_fw_download(void) {
     NXPLOG_NCIHAL_E("FW download denied while SPI in use, Continue NFC init");
     return NFCSTATUS_REJECTED;
   }
-  nxpncihal_ctrl.phNxpNciGpioInfo.state = GPIO_UNKNOWN;
-  phNxpNciHal_gpio_restore(GPIO_STORE);
+#endif
+  if (!sIsForceFwDownloadReqd) {
+    nxpncihal_ctrl.phNxpNciGpioInfo.state = GPIO_UNKNOWN;
+    phNxpNciHal_gpio_restore(GPIO_STORE);
+  }
 
   int fw_retry_count = 0;
   NFCSTATUS status = NFCSTATUS_REJECTED;
@@ -509,7 +518,7 @@ static void phNxpNciHal_get_clk_freq(void) {
                   nxpprofile_ctrl.bClkSrcVal);
   NXPLOG_FWDNLD_D("gphNxpNciHal_fw_IoctlCtx.bClkFreqVal = 0x%x",
                   nxpprofile_ctrl.bClkFreqVal);
-  NXPLOG_FWDNLD_D("gphNxpNciHal_fw_IoctlCtx.bClkFreqVal = 0x%x",
+  NXPLOG_FWDNLD_D("gphNxpNciHal_fw_IoctlCtx.bTimeout = 0x%x",
                   nxpprofile_ctrl.bTimeout);
 
   if ((nxpprofile_ctrl.bClkSrcVal < CLK_SRC_XTAL) ||
@@ -625,6 +634,11 @@ int phNxpNciHal_MinOpen() {
   tOsalConfig.pLogFile = NULL;
   tTmlConfig.dwGetMsgThreadId = (uintptr_t)nxpncihal_ctrl.gDrvCfg.nClientId;
 
+  if (nfcFL.chipType == pn548C2) {
+    memset(discovery_cmd, 0, sizeof(discovery_cmd));
+    discovery_cmd_len = 0;
+  }
+
   /* Initialize TML layer */
   wConfigStatus = phTmlNfc_Init(&tTmlConfig);
   if (wConfigStatus != NFCSTATUS_SUCCESS) {
@@ -674,14 +688,15 @@ init_retry:
     return NFCSTATUS_FAILED;
   }
   sIsForceFwDownloadReqd = (status != NFCSTATUS_SUCCESS) &&
-                           (nxpncihal_ctrl.retry_cnt >= MAX_RETRY_COUNT);
+      ((nxpncihal_ctrl.retry_cnt >= MAX_RETRY_COUNT) ||
+      (init_retry_cnt >= MAX_RETRY_COUNT)) ;
   if (sIsForceFwDownloadReqd) {
     NXPLOG_NCIHAL_E("Force FW Download, NFCC not coming out from Standby");
     wConfigStatus = NFCSTATUS_FAILED;
     goto force_download;
   } else if (status != NFCSTATUS_SUCCESS) {
     NXPLOG_NCIHAL_E("NCI_CORE_RESET: Failed");
-    if (init_retry_cnt < 3) {
+    if (init_retry_cnt < MAX_RETRY_COUNT) {
       init_retry_cnt++;
       (void)phNxpNciHal_power_cycle();
       goto init_retry;
@@ -843,9 +858,82 @@ int phNxpNciHal_fw_mw_ver_check() {
              (rom_version == FW_MOBILE_ROM_VERSION_PN551) &&
              (fw_maj_ver == 0x05)) {
     status = NFCSTATUS_SUCCESS;
-  }
+  } else if ((nfcFL.chipType == pn548C2) &&
+             (rom_version == FW_MOBILE_ROM_VERSION_PN548AD) &&
+             (fw_maj_ver == 0x01)) {
+    status = NFCSTATUS_SUCCESS;
+   }
   return status;
 }
+
+NFCSTATUS phNxpNciHal_core_reset_recovery() {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+
+  /*NCI_INIT_CMD*/
+  static uint8_t cmd_init_nci[] = {0x20, 0x01, 0x00};
+  /*NCI_RESET_CMD*/
+  static uint8_t cmd_reset_nci[] = {0x20, 0x00, 0x01,
+                                    0x00};  // keep configuration
+  static uint8_t cmd_init_nci2_0[] = {0x20, 0x01, 0x02, 0x00, 0x00};
+  /* reset config cache */
+  uint8_t retry_core_init_cnt = 0;
+
+  if (discovery_cmd_len == 0) {
+    goto FAILURE;
+  }
+  NXPLOG_NCIHAL_D("%s: recovery", __func__);
+
+retry_core_init:
+  if (retry_core_init_cnt > 3) {
+    goto FAILURE;
+  }
+
+  status = phTmlNfc_IoCtl(phTmlNfc_e_ResetDevice);
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_D("PN54X Reset - FAILED\n");
+    goto FAILURE;
+  }
+  status = phNxpNciHal_send_ext_cmd(sizeof(cmd_reset_nci), cmd_reset_nci);
+  if ((status != NFCSTATUS_SUCCESS) &&
+      (nxpncihal_ctrl.retry_cnt >= MAX_RETRY_COUNT)) {
+    retry_core_init_cnt++;
+    goto retry_core_init;
+  } else if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_D("NCI_CORE_RESET: Failed");
+    retry_core_init_cnt++;
+    goto retry_core_init;
+  }
+  if (nxpncihal_ctrl.nci_info.nci_version == NCI_VERSION_2_0) {
+    status = phNxpNciHal_send_ext_cmd(sizeof(cmd_init_nci2_0), cmd_init_nci2_0);
+  } else {
+    status = phNxpNciHal_send_ext_cmd(sizeof(cmd_init_nci), cmd_init_nci);
+  }
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_D("NCI_CORE_INIT : Failed");
+    retry_core_init_cnt++;
+    goto retry_core_init;
+  }
+
+  status = phNxpNciHal_send_ext_cmd(discovery_cmd_len, discovery_cmd);
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_D("RF_DISCOVERY : Failed");
+    retry_core_init_cnt++;
+    goto retry_core_init;
+  }
+
+  return NFCSTATUS_SUCCESS;
+FAILURE:
+  abort();
+}
+
+void phNxpNciHal_discovery_cmd_ext(uint8_t* p_cmd_data, uint16_t cmd_len) {
+  NXPLOG_NCIHAL_D("phNxpNciHal_discovery_cmd_ext");
+  if (cmd_len > 0 && cmd_len <= sizeof(discovery_cmd)) {
+    memcpy(discovery_cmd, p_cmd_data, cmd_len);
+    discovery_cmd_len = cmd_len;
+  }
+}
+
 /******************************************************************************
  * Function         phNxpNciHal_MinOpen_complete
  *
@@ -1015,7 +1103,7 @@ int phNxpNciHal_write_unlocked(uint16_t data_len, const uint8_t* p_data) {
   if (phNxpNciHal_check_ncicmd_write_window(nxpncihal_ctrl.cmd_len,
                                             nxpncihal_ctrl.p_cmd_data) !=
       NFCSTATUS_SUCCESS) {
-    NXPLOG_NCIHAL_D("phNxpNciHal_write_unlocked Create cb data failed");
+    NXPLOG_NCIHAL_D("phNxpNciHal_write_unlocked check nci write window failed");
     data_len = 0;
     goto clean_and_return;
   }
@@ -1443,7 +1531,10 @@ int phNxpNciHal_core_initialized(uint16_t core_init_rsp_params_len,
     }
   }
 
-  if (isNxpConfigModified() || (fw_download_success == 1)) {
+  if (isNxpConfigModified() || (fw_download_success == 1)  || (anti_tearing_recovery_success == 1)) {
+    NXPLOG_NCIHAL_D("Applying Settings: isNxpConfigModified()=%d, fw_download_success=%d, anti_tearing_recovery_success=%d",
+      isNxpConfigModified(), fw_download_success, anti_tearing_recovery_success);
+
     retlen = 0;
     fw_download_success = 0;
 
@@ -1687,17 +1778,35 @@ int phNxpNciHal_core_initialized(uint16_t core_init_rsp_params_len,
       retry_core_init_cnt++;
       goto retry_core_init;
     }
+
+    if (!GetNxpNumValue(NAME_NXP_T4T_NFCEE_ENABLE, (void*)&retlen,
+                        sizeof(retlen))) {
+      retlen = 0x00;
+      NXPLOG_NCIHAL_D(
+          "T4T_NFCEE_ENABLE not found. Taking default value : 0x%02lx", retlen);
+    }
+
+    // Configure t4t ndef emulation
+    status = phNxpNciHal_config_t4t_ndef((uint8_t)retlen);
+    if (status != NFCSTATUS_SUCCESS) {
+      NXPLOG_NCIHAL_E("NXP Update MW EEPROM Proprietary Ext failed");
+    }
+
     // Update eeprom value
     status = phNxpNciHal_set_mw_eeprom();
     if (status != NFCSTATUS_SUCCESS) {
       NXPLOG_NCIHAL_E("NXP Update MW EEPROM Proprietary Ext failed");
     }
+
+    anti_tearing_recovery_success = 0;
   }
 
   retlen = 0;
 
+  NXPLOG_NCIHAL_D("Performing NAME_NXP_CORE_CONF Settings");
   isfound =
       GetNxpByteArrayValue(NAME_NXP_CORE_CONF, (char*)buffer, bufflen, &retlen);
+  NXPLOG_NCIHAL_D("NAME_NXP_CORE_CONF Settings Found - %d Len: %ld", isfound, retlen);
   if (retlen > 0) {
     /* NXP ACT Proprietary Ext */
     status = phNxpNciHal_send_ext_cmd(retlen, buffer);
@@ -2236,6 +2345,44 @@ int phNxpNciHal_configDiscShutdown(void) {
   return NFCSTATUS_SUCCESS;
 }
 
+#if(NXP_EXTNS == TRUE)
+/******************************************************************************
+ * Function         phNxpNciHal_getNxp
+ *
+ * Description      This function can be used by HAL to inform
+ *                 to update vendor configuration parametres
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+void phNxpNciHal_getNxpConfig(nfc_nci_IoctlInOutData_t *pInpOutData) {
+  unsigned long num = 0;
+  uint8_t *buffer = NULL;
+  long bufflen = 260;
+
+  buffer = (uint8_t *)malloc(bufflen * sizeof(uint8_t));
+  memset(&pInpOutData->out.data.nxpConfigs, 0x00, sizeof(pInpOutData->out.data.nxpConfigs));
+  if (GetNxpNumValue(NAME_NXP_AGC_DEBUG_ENABLE, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.wAgcDebugEnable = num;
+  }else {
+    pInpOutData->out.data.nxpConfigs.wAgcDebugEnable = 0x00;
+  }
+
+  if (GetNxpNumValue(NAME_NXP_T4T_NFCEE_ENABLE, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.wT4TNdefEnable = num;
+  }else {
+    pInpOutData->out.data.nxpConfigs.wT4TNdefEnable = 0x00;
+  }
+
+  if (GetNxpNumValue(NAME_DEFAULT_T4TNFCEE_AID_POWER_STATE, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.wT4TPowerState = num;
+  }else {
+    pInpOutData->out.data.nxpConfigs.wT4TPowerState = 0x00;
+  }
+
+}
+#endif
+
 /******************************************************************************
  * Function         phNxpNciHal_getVendorConfig
  *
@@ -2607,7 +2754,13 @@ int phNxpNciHal_ioctl(long arg, void* p_data) {
                       pInpOutData->inp.data.nciCmd.p_cmd[0]);
       if (gpEseAdapt != NULL)
         ret = gpEseAdapt->HalIoctl(HAL_NFC_IOCTL_RF_STATUS_UPDATE, pInpOutData);
+        break;
+#if(NXP_EXTNS == TRUE)
+    case HAL_NFC_GET_NXP_CONFIG:
+      phNxpNciHal_getNxpConfig(pInpOutData);
+      ret = 0;
       break;
+#endif
     default:
       NXPLOG_NCIHAL_E("%s : Wrong arg = %ld", __func__, arg);
       break;
@@ -2685,6 +2838,38 @@ retry_send_ext:
   return status;
 }
 
+/******************************************************************************
+ * Function         phNxpNciHal_config_t4t_ndef
+ *
+ * Description      This function is called to configure T4T Ndef emulation
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+static NFCSTATUS phNxpNciHal_config_t4t_ndef(uint8_t t4tFlag) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  NXPLOG_NCIHAL_D("NxpNci phNxpNciHal_enable_ndef");
+  uint8_t retry_cnt = 0;
+  uint8_t set_mw_eeprom_cmd[8] = {0};
+  uint8_t cmd_header[] = {0x20, 0x02, 0x05, 0x01, 0xA0, 0x95, 0x01, t4tFlag};
+
+  memcpy(set_mw_eeprom_cmd, cmd_header, sizeof(cmd_header));
+
+retry_send_ext:
+  if (retry_cnt > 3) {
+    return NFCSTATUS_FAILED;
+  }
+
+  status =
+      phNxpNciHal_send_ext_cmd(sizeof(set_mw_eeprom_cmd), set_mw_eeprom_cmd);
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_D("unable to update the mw eeprom data");
+    retry_cnt++;
+    goto retry_send_ext;
+  }
+  return status;
+}
+
 /******************************************************************************
  * Function         phNxpNciHal_set_clock
  *
diff --git a/pn8x/halimpl/hal/phNxpNciHal.h b/pn8x/halimpl/hal/phNxpNciHal.h
index b887ea0..28b0b1b 100644
--- a/pn8x/halimpl/hal/phNxpNciHal.h
+++ b/pn8x/halimpl/hal/phNxpNciHal.h
@@ -20,6 +20,7 @@
 #include <phNxpNciHal_utils.h>
 #include "NxpMfcReader.h"
 #include "NxpNfcCapability.h"
+#include "hal_nxpnfc.h"
 
 /********************* Definitions and structures *****************************/
 #define MAX_RETRY_COUNT 5
@@ -34,6 +35,7 @@
 typedef void(phNxpNciHal_control_granted_callback_t)();
 
 /*ROM CODE VERSION FW*/
+#define FW_MOBILE_ROM_VERSION_PN548AD 0x10
 #define FW_MOBILE_ROM_VERSION_PN551 0x10
 #define FW_MOBILE_ROM_VERSION_PN553 0x11
 #define FW_MOBILE_ROM_VERSION_PN557 0x12
@@ -178,6 +180,8 @@ int phNxpNciHal_check_ncicmd_write_window(uint16_t cmd_len, uint8_t* p_cmd);
 void phNxpNciHal_request_control(void);
 void phNxpNciHal_release_control(void);
 int phNxpNciHal_write_unlocked(uint16_t data_len, const uint8_t* p_data);
+NFCSTATUS phNxpNciHal_core_reset_recovery();
+void phNxpNciHal_discovery_cmd_ext(uint8_t* p_cmd_data, uint16_t cmd_len);
 /*******************************************************************************
 **
 ** Function         phNxpNciHal_configFeatureList
@@ -187,4 +191,17 @@ int phNxpNciHal_write_unlocked(uint16_t data_len, const uint8_t* p_data);
 ** Returns          none
 *******************************************************************************/
 void phNxpNciHal_configFeatureList(uint8_t* init_rsp, uint16_t rsp_len);
+#if(NXP_EXTNS == TRUE)
+/*******************************************************************************
+**
+** Function         phNxpNciHal_getNxpConfig
+**
+** Description      Read vendor configuration macro values
+**
+** Parameters       ioctl input/output struct.
+**
+** Returns          none
+*******************************************************************************/
+void phNxpNciHal_getNxpConfig(nfc_nci_IoctlInOutData_t *pInpOutData);
+#endif
 #endif /* _PHNXPNCIHAL_H_ */
diff --git a/pn8x/halimpl/hal/phNxpNciHal_ext.cc b/pn8x/halimpl/hal/phNxpNciHal_ext.cc
index 59b6007..9fb21b6 100644
--- a/pn8x/halimpl/hal/phNxpNciHal_ext.cc
+++ b/pn8x/halimpl/hal/phNxpNciHal_ext.cc
@@ -32,10 +32,12 @@
 /******************* Global variables *****************************************/
 extern phNxpNciHal_Control_t nxpncihal_ctrl;
 extern phNxpNciProfile_Control_t nxpprofile_ctrl;
+extern uint8_t anti_tearing_recovery_success;
 extern uint32_t cleanup_timer;
 extern bool nfc_debug_enabled;
 uint8_t icode_detected = 0x00;
 uint8_t icode_send_eof = 0x00;
+uint8_t nfcdep_detected = 0x00;
 static uint8_t ee_disc_done = 0x00;
 uint8_t EnableP2P_PrioLogic = false;
 extern bool bEnableMfcExtns;
@@ -97,7 +99,11 @@ NFCSTATUS phNxpNciHal_process_ext_rsp(uint8_t* p_ntf, uint16_t* p_len) {
   NFCSTATUS status = NFCSTATUS_SUCCESS;
 
   if (p_ntf[0] == 0x61 && p_ntf[1] == 0x05 && *p_len < 14) {
-    if (*p_len <= 6) {
+    if ((nfcFL.chipType == pn548C2) && (nfcdep_detected)) {
+      nfcdep_detected = 0x00;
+    }
+
+    if(*p_len <= 6) {
       android_errorWriteLog(0x534e4554, "118152591");
     }
     NXPLOG_NCIHAL_E("RF_INTF_ACTIVATED_NTF length error!");
@@ -172,6 +178,9 @@ NFCSTATUS phNxpNciHal_process_ext_rsp(uint8_t* p_ntf, uint16_t* p_len) {
         break;
       case 0x03:
         NXPLOG_NCIHAL_D("NxpNci: RF Interface = NFC-DEP");
+        if (nfcFL.chipType == pn548C2) {
+          nfcdep_detected = 0x01;
+        }
         break;
       case 0x80:
         NXPLOG_NCIHAL_D("NxpNci: RF Interface = MIFARE");
@@ -368,6 +377,12 @@ NFCSTATUS phNxpNciHal_process_ext_rsp(uint8_t* p_ntf, uint16_t* p_len) {
       *p_len = 5;
     }
   }
+  else if(p_ntf[0] == 0x60 && p_ntf[1] == 0x07 && p_ntf[3] == 0xE6)
+  {
+      NXPLOG_NCIHAL_E("CORE_GENERIC_ERROR_NTF received!");
+      /* register recovery success to force applying RF settings */
+      anti_tearing_recovery_success = 1;
+  }
 
   if (*p_len == 4 && p_ntf[0] == 0x61 && p_ntf[1] == 0x07) {
     unsigned long rf_update_enable = 0;
@@ -483,6 +498,14 @@ static NFCSTATUS phNxpNciHal_ext_process_nfc_init_rsp(uint8_t* p_ntf,
       }
       NXPLOG_NCIHAL_D("CORE_RESET_NTF received !");
       NXPLOG_NCIR_E("len = %3d > %s", *p_len, print_buffer);
+      if ((nfcFL.chipType == pn548C2) && nfcdep_detected &&
+          !(p_ntf[2] == 0x06 && p_ntf[3] == 0xA0 && p_ntf[4] == 0x00 &&
+            ((p_ntf[5] == 0xC9 && p_ntf[6] == 0x95 && p_ntf[7] == 0x00 &&
+              p_ntf[8] == 0x00) ||
+             (p_ntf[5] == 0x07 && p_ntf[6] == 0x39 && p_ntf[7] == 0xF2 &&
+              p_ntf[8] == 0x00)))) {
+        nfcdep_detected = 0x00;
+      }
       phNxpNciHal_emergency_recovery();
       status = NFCSTATUS_FAILED;
     } /* Parsing CORE_INIT_RSP*/
@@ -756,6 +779,10 @@ NFCSTATUS phNxpNciHal_write_ext(uint16_t* cmd_len, uint8_t* p_cmd_data,
     NXPLOG_NCIHAL_D("> Polling Loop Started");
     icode_detected = 0;
     icode_send_eof = 0;
+    if (nfcFL.chipType == pn548C2) {
+      // Cache discovery cmd for recovery
+      phNxpNciHal_discovery_cmd_ext(p_cmd_data, *cmd_len);
+    }
   }
   // 22000100
   else if (p_cmd_data[0] == 0x22 && p_cmd_data[1] == 0x00 &&
@@ -910,6 +937,53 @@ NFCSTATUS phNxpNciHal_write_ext(uint16_t* cmd_len, uint8_t* p_cmd_data,
     }
   }
 
+  if (nfcFL.chipType == pn548C2 && p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02) {
+    uint8_t temp;
+    uint8_t* p = p_cmd_data + 4;
+    uint8_t* end = p_cmd_data + *cmd_len;
+    while (p < end) {
+      if (*p == 0x53)  // LF_T3T_FLAGS
+      {
+        NXPLOG_NCIHAL_D("> Going through workaround - LF_T3T_FLAGS swap");
+        temp = *(p + 3);
+        *(p + 3) = *(p + 2);
+        *(p + 2) = temp;
+        NXPLOG_NCIHAL_D("> Going through workaround - LF_T3T_FLAGS - End");
+        status = NFCSTATUS_SUCCESS;
+        break;
+      }
+      if (*p == 0xA0) {
+        p += *(p + 2) + 3;
+      } else {
+        p += *(p + 1) + 2;
+      }
+    }
+  }
+
+  if ((nfcFL.chipType == pn548C2) &&
+          (p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02)) {
+      uint8_t temp;
+      uint8_t* p = p_cmd_data + 4;
+      uint8_t* end = p_cmd_data + *cmd_len;
+      while (p < end) {
+          if (*p == 0x53)  // LF_T3T_FLAGS
+          {
+              NXPLOG_NCIHAL_D("> Going through workaround - LF_T3T_FLAGS swap");
+              temp = *(p + 3);
+              *(p + 3) = *(p + 2);
+              *(p + 2) = temp;
+              NXPLOG_NCIHAL_D("> Going through workaround - LF_T3T_FLAGS - End");
+              status = NFCSTATUS_SUCCESS;
+              break;
+          }
+          if (*p == 0xA0) {
+              p += *(p + 2) + 3;
+          } else {
+              p += *(p + 1) + 2;
+          }
+      }
+  }
+
   return status;
 }
 
diff --git a/pn8x/halimpl/libnfc-nxp-PN548AD_example.conf b/pn8x/halimpl/libnfc-nxp-PN548AD_example.conf
index 53121b2..00ae0b0 100755
--- a/pn8x/halimpl/libnfc-nxp-PN548AD_example.conf
+++ b/pn8x/halimpl/libnfc-nxp-PN548AD_example.conf
@@ -32,6 +32,10 @@ VZW_FEATURE_ENABLE=0x01
 ###############################################################################
 # File name for Firmware
 NXP_FW_NAME="libpn548ad_fw.so"
+# Firmware file type
+#.so file   0x01
+#.bin file  0x02
+NXP_FW_TYPE=0x01
 
 ###############################################################################
 # System clock source selection configuration
diff --git a/pn8x/halimpl/libnfc-nxp-PN66T_example.conf b/pn8x/halimpl/libnfc-nxp-PN66T_example.conf
index d63881f..972866b 100755
--- a/pn8x/halimpl/libnfc-nxp-PN66T_example.conf
+++ b/pn8x/halimpl/libnfc-nxp-PN66T_example.conf
@@ -31,6 +31,10 @@ VZW_FEATURE_ENABLE=0x01
 ###############################################################################
 # File name for Firmware
 NXP_FW_NAME="libpn548ad_fw.so"
+# Firmware file type
+#.so file   0x01
+#.bin file  0x02
+NXP_FW_TYPE=0x01
 
 ###############################################################################
 # System clock source selection configuration
diff --git a/pn8x/halimpl/src/adaptation/EseAdaptation.cpp b/pn8x/halimpl/src/adaptation/EseAdaptation.cpp
index f45af70..14ad48e 100755
--- a/pn8x/halimpl/src/adaptation/EseAdaptation.cpp
+++ b/pn8x/halimpl/src/adaptation/EseAdaptation.cpp
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015,2021 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -57,8 +57,6 @@ ThreadCondVar EseAdaptation::mHalCoreInitCompletedEvent;
 ThreadCondVar EseAdaptation::mHalInitCompletedEvent;
 #define SIGNAL_NONE 0
 #define SIGNAL_SIGNALED 1
-static uint8_t isSignaled = SIGNAL_NONE;
-static uint8_t evt_status;
 #endif
 
 /*******************************************************************************
diff --git a/pn8x/halimpl/tml/NfccTransportFactory.cc b/pn8x/halimpl/tml/NfccTransportFactory.cc
new file mode 100755
index 0000000..141e8a8
--- /dev/null
+++ b/pn8x/halimpl/tml/NfccTransportFactory.cc
@@ -0,0 +1,79 @@
+/******************************************************************************
+ *
+ *  Copyright 2020-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <NfccI2cTransport.h>
+#include <NfccSpiTransport.h>
+#include <NfccTransportFactory.h>
+#include <phNxpLog.h>
+
+/*******************************************************************************
+ **
+ ** Function         NfccTransportFactory
+ **
+ ** Description      Constructor for transportFactory. This will be private to
+ **                  support singleton
+ **
+ ** Parameters       none
+ **
+ ** Returns          none
+ ******************************************************************************/
+NfccTransportFactory::NfccTransportFactory() {}
+
+/*******************************************************************************
+**
+** Function         getTransport
+**
+** Description      selects and returns transport channel based on the input
+**                  parameter
+**
+** Parameters       Required transport Type
+**
+** Returns          Selected transport channel
+******************************************************************************/
+NfccTransportFactory& NfccTransportFactory::getInstance() {
+  static NfccTransportFactory mTransprtFactoryInstance;
+  return mTransprtFactoryInstance;
+}
+
+/*******************************************************************************
+**
+** Function         getTransport
+**
+** Description      selects and returns transport channel based on the input
+**                  parameter
+**
+** Parameters       Required transport Type
+**
+** Returns          Selected transport channel
+******************************************************************************/
+spTransport NfccTransportFactory::getTransport(transportIntf transportType) {
+  NXPLOG_TML_D("%s Requested transportType: %d\n", __func__, transportType);
+  spTransport mspTransportInterface;
+  switch (transportType) {
+    case I2C:
+    case UNKNOWN:
+      mspTransportInterface = std::make_shared<NfccI2cTransport>();
+      break;
+    case SPI:
+      mspTransportInterface = std::make_shared<NfccSpiTransport>();
+    default:
+      mspTransportInterface = std::make_shared<NfccI2cTransport>();
+      break;
+  }
+  return mspTransportInterface;
+}
diff --git a/pn8x/halimpl/tml/NfccTransportFactory.h b/pn8x/halimpl/tml/NfccTransportFactory.h
new file mode 100755
index 0000000..f580bae
--- /dev/null
+++ b/pn8x/halimpl/tml/NfccTransportFactory.h
@@ -0,0 +1,67 @@
+/******************************************************************************
+ *
+ *  Copyright 2020-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#pragma once
+#include <NfccTransport.h>
+#include <memory>
+
+#define transportFactory (NfccTransportFactory::getInstance())
+typedef std::shared_ptr<NfccTransport> spTransport;
+enum transportIntf { I2C, SPI, UNKNOWN };
+
+extern spTransport gpTransportObj;
+class NfccTransportFactory {
+  /*****************************************************************************
+   **
+   ** Function         NfccTransportFactory
+   **
+   ** Description      Constructor for transportFactory. This will be private to
+   **                  support singleton
+   **
+   ** Parameters       none
+   **
+   ** Returns          none
+   ****************************************************************************/
+  NfccTransportFactory();
+
+ public:
+  /*****************************************************************************
+   **
+   ** Function         getInstance
+   **
+   ** Description      returns the static instance of TransportFactory
+   **
+   ** Parameters       none
+   **
+   ** Returns          TransportFactory instance
+   ****************************************************************************/
+  static NfccTransportFactory& getInstance();
+
+  /*****************************************************************************
+  **
+  ** Function         getTransport
+  **
+  ** Description      selects and returns transport channel based on the input
+  **                  parameter
+  **
+  ** Parameters       Required transport Type
+  **
+  ** Returns          Selected transport channel
+  ****************************************************************************/
+  spTransport getTransport(transportIntf transportType);
+};
diff --git a/pn8x/halimpl/tml/phTmlNfc.cc b/pn8x/halimpl/tml/phTmlNfc.cc
index baf5354..d48ac25 100644
--- a/pn8x/halimpl/tml/phTmlNfc.cc
+++ b/pn8x/halimpl/tml/phTmlNfc.cc
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2014 NXP Semiconductors
+ * Copyright (C) 2010-2021 NXP Semiconductors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,12 +18,13 @@
  * TML Implementation.
  */
 
+#include "NfccTransportFactory.h"
 #include <phDal4Nfc_messageQueueLib.h>
+#include <phNxpConfig.h>
 #include <phNxpLog.h>
 #include <phNxpNciHal_utils.h>
 #include <phOsalNfc_Timer.h>
 #include <phTmlNfc.h>
-#include <phTmlNfc_i2c.h>
 
 /*
  * Duration of Timer to wait after sending an Nci packet
@@ -51,6 +52,8 @@ static void* phTmlNfc_TmlWriterThread(void* pParam);
 static void phTmlNfc_ReTxTimerCb(uint32_t dwTimerId, void* pContext);
 static NFCSTATUS phTmlNfc_InitiateTimer(void);
 
+spTransport gpTransportObj;
+
 /* Function definitions */
 
 /*******************************************************************************
@@ -95,6 +98,10 @@ NFCSTATUS phTmlNfc_Init(pphTmlNfc_Config_t pConfig) {
     if (NULL == gpphTmlNfc_Context) {
       wInitStatus = PHNFCSTVAL(CID_NFC_TML, NFCSTATUS_FAILED);
     } else {
+      /*Configure transport layer for communication*/
+      if (NFCSTATUS_SUCCESS != phTmlNfc_ConfigTransport())
+        return NFCSTATUS_FAILED;
+
       /* Initialise all the internal TML variables */
       memset(gpphTmlNfc_Context, PH_TMLNFC_RESET_VALUE,
              sizeof(phTmlNfc_Context_t));
@@ -102,7 +109,7 @@ NFCSTATUS phTmlNfc_Init(pphTmlNfc_Config_t pConfig) {
       gpphTmlNfc_Context->bThreadDone = 1;
 
       /* Open the device file to which data is read/written */
-      wInitStatus = phTmlNfc_i2c_open_and_configure(
+      wInitStatus = gpTransportObj->OpenAndConfigure(
           pConfig, &(gpphTmlNfc_Context->pDevHandle));
 
       if (NFCSTATUS_SUCCESS != wInitStatus) {
@@ -159,6 +166,32 @@ NFCSTATUS phTmlNfc_Init(pphTmlNfc_Config_t pConfig) {
   return wInitStatus;
 }
 
+/*******************************************************************************
+**
+** Function         phTmlNfc_ConfigTransport
+**
+** Description      Configure Transport channel based on transport type provided
+**                  in config file
+**
+** Returns          NFCSTATUS_SUCCESS If transport channel is configured
+**                  NFCSTATUS_FAILED If transport channel configuration failed
+**
+*******************************************************************************/
+NFCSTATUS phTmlNfc_ConfigTransport() {
+  unsigned long transportType = UNKNOWN;
+  unsigned long value = 0;
+  int isfound = GetNxpNumValue(NAME_NXP_TRANSPORT, &value, sizeof(value));
+  if (isfound > 0) {
+    transportType = value;
+  }
+  gpTransportObj = transportFactory.getTransport((transportIntf)transportType);
+  if (gpTransportObj == nullptr) {
+    NXPLOG_TML_E("No Transport channel available \n");
+    return NFCSTATUS_FAILED;
+  }
+  return NFCSTATUS_SUCCESS;
+}
+
 /*******************************************************************************
 **
 ** Function         phTmlNfc_ConfigNciPktReTx
@@ -332,7 +365,7 @@ static void* phTmlNfc_TmlThread(void* pParam) {
       if (NULL != gpphTmlNfc_Context->pDevHandle) {
         NXPLOG_TML_D("PN54X - Invoking I2C Read.....\n");
         dwNoBytesWrRd =
-            phTmlNfc_i2c_read(gpphTmlNfc_Context->pDevHandle, temp, 260);
+            gpTransportObj->Read(gpphTmlNfc_Context->pDevHandle, temp, 260);
 
         if (-1 == dwNoBytesWrRd) {
           NXPLOG_TML_E("PN54X - Error in I2C Read.....\n");
@@ -453,13 +486,13 @@ static void* phTmlNfc_TmlWriterThread(void* pParam) {
         /* Write the data in the buffer onto the file */
         NXPLOG_TML_D("PN54X - Invoking I2C Write.....\n");
         dwNoBytesWrRd =
-            phTmlNfc_i2c_write(gpphTmlNfc_Context->pDevHandle,
-                               gpphTmlNfc_Context->tWriteInfo.pBuffer,
-                               gpphTmlNfc_Context->tWriteInfo.wLength);
+            gpTransportObj->Write(gpphTmlNfc_Context->pDevHandle,
+                                  gpphTmlNfc_Context->tWriteInfo.pBuffer,
+                                  gpphTmlNfc_Context->tWriteInfo.wLength);
 
         /* Try I2C Write Five Times, if it fails : Raju */
         if (-1 == dwNoBytesWrRd) {
-          if (getDownloadFlag() == true) {
+          if (gpTransportObj->IsFwDnldModeEnabled() == true) {
             if (retry_cnt++ < MAX_WRITE_RETRY_COUNT) {
               NXPLOG_TML_D("PN54X - Error in I2C Write  - Retry 0x%x",
                            retry_cnt);
@@ -558,13 +591,15 @@ void phTmlNfc_CleanUp(void) {
     return;
   }
   if (NULL != gpphTmlNfc_Context->pDevHandle) {
-    (void)phTmlNfc_i2c_reset(gpphTmlNfc_Context->pDevHandle, 0);
+    (void)gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle,
+                                    MODE_POWER_OFF);
     gpphTmlNfc_Context->bThreadDone = 0;
   }
   sem_destroy(&gpphTmlNfc_Context->rxSemaphore);
   sem_destroy(&gpphTmlNfc_Context->txSemaphore);
   sem_destroy(&gpphTmlNfc_Context->postMsgSemaphore);
-  phTmlNfc_i2c_close(gpphTmlNfc_Context->pDevHandle);
+  gpTransportObj->Close(gpphTmlNfc_Context->pDevHandle);
+  gpTransportObj = NULL;
   gpphTmlNfc_Context->pDevHandle = NULL;
   /* Clear memory allocated for storing Context variables */
   free((void*)gpphTmlNfc_Context);
@@ -876,24 +911,30 @@ NFCSTATUS phTmlNfc_IoCtl(phTmlNfc_ControlCode_t eControlCode) {
     switch (eControlCode) {
       case phTmlNfc_e_ResetDevice: {
         /*Reset PN54X*/
-        phTmlNfc_i2c_reset(gpphTmlNfc_Context->pDevHandle, 1);
+        gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle,
+                                  MODE_POWER_ON);
         usleep(100 * 1000);
-        phTmlNfc_i2c_reset(gpphTmlNfc_Context->pDevHandle, 0);
+        gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle,
+                                  MODE_POWER_OFF);
         usleep(100 * 1000);
-        phTmlNfc_i2c_reset(gpphTmlNfc_Context->pDevHandle, 1);
+        gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle,
+                                  MODE_POWER_ON);
         break;
       }
       case phTmlNfc_e_EnableNormalMode: {
         /*Reset PN54X*/
-        phTmlNfc_i2c_reset(gpphTmlNfc_Context->pDevHandle, 0);
+        gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle,
+                                  MODE_POWER_OFF);
         usleep(10 * 1000);
-        phTmlNfc_i2c_reset(gpphTmlNfc_Context->pDevHandle, 1);
+        gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle,
+                                  MODE_POWER_ON);
         usleep(100 * 1000);
         break;
       }
       case phTmlNfc_e_EnableDownloadMode: {
-        phTmlNfc_ConfigNciPktReTx(phTmlNfc_e_DisableRetrans, 0);
-        (void)phTmlNfc_i2c_reset(gpphTmlNfc_Context->pDevHandle, 2);
+        phTmlNfc_ConfigNciPktReTx(phTmlNfc_e_DisableRetrans, MODE_POWER_OFF);
+        (void)gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle,
+                                        MODE_FW_DWNLD_WITH_VEN);
         usleep(100 * 1000);
         break;
       }
diff --git a/pn8x/halimpl/tml/phTmlNfc.h b/pn8x/halimpl/tml/phTmlNfc.h
index 002889d..f42efee 100755
--- a/pn8x/halimpl/tml/phTmlNfc.h
+++ b/pn8x/halimpl/tml/phTmlNfc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2014 NXP Semiconductors
+ * Copyright (C) 2010-2021 NXP Semiconductors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -76,6 +76,15 @@ typedef struct phTmlNfc_TransactInfo {
   uint16_t wLength;        /* Data size of the Transaction*/
 } phTmlNfc_TransactInfo_t; /* Instance of Transaction structure */
 
+/*nfc state flags*/
+enum nfc_state_flags {
+  /*nfc in unknown state */
+  NFC_STATE_UNKNOWN = 0,
+  /*nfc booted in download mode */
+  NFC_STATE_FW_DWL = 0x1,
+  /*nfc booted in NCI mode */
+  NFC_STATE_NCI = 0x2,
+};
 /*
  * TML transreceive completion callback to Upper Layer
  *
@@ -229,4 +238,5 @@ void phTmlNfc_ConfigNciPktReTx(phTmlNfc_ConfigRetrans_t eConfig,
                                uint8_t bRetryCount);
 void phTmlNfc_set_fragmentation_enabled(phTmlNfc_i2cfragmentation_t enable);
 phTmlNfc_i2cfragmentation_t phTmlNfc_get_fragmentation_enabled();
+NFCSTATUS phTmlNfc_ConfigTransport();
 #endif /*  PHTMLNFC_H  */
diff --git a/pn8x/halimpl/tml/spi_spm.cc b/pn8x/halimpl/tml/spi_spm.cc
index 8373e50..8aea4e5 100755
--- a/pn8x/halimpl/tml/spi_spm.cc
+++ b/pn8x/halimpl/tml/spi_spm.cc
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2014 NXP Semiconductors
+ * Copyright (C) 2012-2021 NXP Semiconductors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,12 +19,12 @@
 #include <sys/types.h>
 #include <unistd.h>
 
+#include "NfccTransportFactory.h"
+#include "phNxpLog.h"
+#include "spi_spm.h"
 #include <errno.h>
 #include <fcntl.h>
 #include <sys/ioctl.h>
-#include "phNxpLog.h"
-#include "phTmlNfc_i2c.h"
-#include "spi_spm.h"
 
 /*******************************************************************************
 **
@@ -51,13 +51,13 @@ int phPalEse_spi_ioctl(phPalEse_ControlCode_t eControlCode, void* pDevHandle,
   switch (eControlCode) {
     case phPalEse_e_ChipRst:
       if (level == 1 || level == 0)
-        ret = ioctl((intptr_t)pDevHandle, P61_SET_SPI_PWR, level);
+          ret = gpTransportObj->EseReset(pDevHandle, (EseResetType)level);
       else
         ret = 0;
       break;
 
     case phPalEse_e_GetSPMStatus:
-      ret = ioctl((intptr_t)pDevHandle, P61_GET_PWR_STATUS, level);
+      ret = gpTransportObj->EseGetPower(pDevHandle, level);
       break;
 
     case phPalEse_e_SetPowerScheme:
@@ -72,7 +72,7 @@ int phPalEse_spi_ioctl(phPalEse_ControlCode_t eControlCode, void* pDevHandle,
       break;
 #endif
     case phPalEse_e_DisablePwrCntrl:
-      ret = ioctl((intptr_t)pDevHandle, P61_SET_SPI_PWR, 1);
+      ret = gpTransportObj->EseReset(pDevHandle, MODE_ESE_POWER_OFF);
       break;
     default:
       ret = -1;
diff --git a/pn8x/halimpl/tml/transport/NfccI2cTransport.cc b/pn8x/halimpl/tml/transport/NfccI2cTransport.cc
new file mode 100755
index 0000000..cc76f11
--- /dev/null
+++ b/pn8x/halimpl/tml/transport/NfccI2cTransport.cc
@@ -0,0 +1,533 @@
+/******************************************************************************
+ *  Copyright 2020-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <errno.h>
+#include <fcntl.h>
+#include <hardware/nfc.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/select.h>
+#include <termios.h>
+#include <unistd.h>
+
+#include "phNxpNciHal_utils.h"
+#include <NfccI2cTransport.h>
+#include <phNfcStatus.h>
+#include <phNxpLog.h>
+#include <string.h>
+
+#define CRC_LEN 2
+#define NORMAL_MODE_HEADER_LEN 3
+#define FW_DNLD_HEADER_LEN 2
+#define FW_DNLD_LEN_OFFSET 1
+#define NORMAL_MODE_LEN_OFFSET 2
+#define FRAGMENTSIZE_MAX PHNFC_I2C_FRAGMENT_SIZE
+extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
+extern phTmlNfc_Context_t *gpphTmlNfc_Context;
+/*******************************************************************************
+**
+** Function         Close
+**
+** Description      Closes NFCC device
+**
+** Parameters       pDevHandle - device handle
+**
+** Returns          None
+**
+*******************************************************************************/
+void NfccI2cTransport::Close(void *pDevHandle) {
+  if (NULL != pDevHandle) {
+    close((intptr_t)pDevHandle);
+  }
+  sem_destroy(&mTxRxSemaphore);
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         OpenAndConfigure
+**
+** Description      Open and configure NFCC device
+**
+** Parameters       pConfig     - hardware information
+**                  pLinkHandle - device handle
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - open_and_configure operation success
+**                  NFCSTATUS_INVALID_DEVICE - device open operation failure
+**
+*******************************************************************************/
+NFCSTATUS NfccI2cTransport::OpenAndConfigure(pphTmlNfc_Config_t pConfig,
+                                             void **pLinkHandle) {
+  int nHandle;
+
+  NXPLOG_TML_D("%s Opening port=%s\n", __func__, pConfig->pDevName);
+  /* open port */
+  nHandle = open((const char *)pConfig->pDevName, O_RDWR);
+  if (nHandle < 0) {
+    NXPLOG_TML_E("_i2c_open() Failed: retval %x", nHandle);
+    *pLinkHandle = NULL;
+    return NFCSTATUS_INVALID_DEVICE;
+  }
+
+  *pLinkHandle = (void *)((intptr_t)nHandle);
+  if (0 != sem_init(&mTxRxSemaphore, 0, 1)) {
+    NXPLOG_TML_E("%s Failed: reason sem_init : retval %x", __func__, nHandle);
+  }
+  /*Reset PN54X*/
+  NfccReset((void *)((intptr_t)nHandle), MODE_POWER_OFF);
+  usleep(10 * 1000);
+  NfccReset((void *)((intptr_t)nHandle), MODE_POWER_ON);
+
+  return NFCSTATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         Flushdata
+**
+** Description      Reads payload of FW rsp from NFCC device into given buffer
+**
+** Parameters       pDevHandle - valid device handle
+**                  pBuffer    - buffer for read data
+**                  numRead    - number of bytes read by calling function
+**
+** Returns          always returns -1
+**
+*******************************************************************************/
+int NfccI2cTransport::Flushdata(void* pDevHandle, uint8_t* pBuffer, int numRead) {
+  int retRead = 0;
+  uint16_t totalBtyesToRead = pBuffer[FW_DNLD_LEN_OFFSET] + FW_DNLD_HEADER_LEN + CRC_LEN;
+  /* we shall read totalBtyesToRead-1 as one byte is already read by calling function*/
+  retRead = read((intptr_t)pDevHandle, pBuffer + numRead, totalBtyesToRead - 1);
+  if (retRead > 0) {
+    numRead += retRead;
+    phNxpNciHal_print_packet("RECV", pBuffer, numRead);
+  } else if (retRead == 0) {
+    NXPLOG_TML_E("%s _i2c_read() [pyld] EOF", __func__);
+  } else {
+    if (bFwDnldFlag == false) {
+      NXPLOG_TML_D("%s _i2c_read() [hdr] received", __func__);
+      phNxpNciHal_print_packet("RECV", pBuffer - numRead, NORMAL_MODE_HEADER_LEN);
+    }
+    NXPLOG_TML_E("%s _i2c_read() [pyld] errno : %x", __func__, errno);
+  }
+  SemPost();
+  return -1;
+}
+
+/*******************************************************************************
+**
+** Function         Read
+**
+** Description      Reads requested number of bytes from NFCC device into given
+**                  buffer
+**
+** Parameters       pDevHandle       - valid device handle
+**                  pBuffer          - buffer for read data
+**                  nNbBytesToRead   - number of bytes requested to be read
+**
+** Returns          numRead   - number of successfully read bytes
+**                  -1        - read operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::Read(void *pDevHandle, uint8_t *pBuffer,
+                           int nNbBytesToRead) {
+  int ret_Read;
+  int ret_Select;
+  int numRead = 0;
+  struct timeval tv;
+  fd_set rfds;
+  uint16_t totalBtyesToRead = 0;
+
+  UNUSED(nNbBytesToRead);
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+
+  if (bFwDnldFlag == false) {
+    totalBtyesToRead = NORMAL_MODE_HEADER_LEN;
+  } else {
+    totalBtyesToRead = FW_DNLD_HEADER_LEN;
+  }
+
+  /* Read with 2 second timeout, so that the read thread can be aborted
+     when the NFCC does not respond and we need to switch to FW download
+     mode. This should be done via a control socket instead. */
+  FD_ZERO(&rfds);
+  FD_SET((intptr_t)pDevHandle, &rfds);
+  tv.tv_sec = 2;
+  tv.tv_usec = 1;
+
+  ret_Select =
+      select((int)((intptr_t)pDevHandle + (int)1), &rfds, NULL, NULL, &tv);
+  if (ret_Select < 0) {
+    NXPLOG_TML_D("%s errno : %x", __func__, errno);
+    return -1;
+  } else if (ret_Select == 0) {
+    NXPLOG_TML_D("%s Timeout", __func__);
+    return -1;
+  } else {
+    ret_Read = read((intptr_t)pDevHandle, pBuffer, totalBtyesToRead - numRead);
+    if (ret_Read > 0 && !(pBuffer[0] == 0xFF && pBuffer[1] == 0xFF)) {
+      SemTimedWait();
+      numRead += ret_Read;
+    } else if (ret_Read == 0) {
+      NXPLOG_TML_E("%s [hdr]EOF", __func__);
+      return -1;
+    } else {
+      NXPLOG_TML_E("%s [hdr] errno : %x", __func__, errno);
+      NXPLOG_TML_E(" %s pBuffer[0] = %x pBuffer[1]= %x", __func__, pBuffer[0],
+                   pBuffer[1]);
+      return -1;
+    }
+
+    if (bFwDnldFlag == false) {
+      totalBtyesToRead = NORMAL_MODE_HEADER_LEN;
+#if(NXP_EXTNS == TRUE)
+      if (gpphTmlNfc_Context->tReadInfo.pContext != NULL &&
+              !memcmp(gpphTmlNfc_Context->tReadInfo.pContext, "MinOpen", 0x07) &&
+              !pBuffer[0] && pBuffer[1]) {
+        return Flushdata(pDevHandle, pBuffer, numRead);
+      }
+#endif
+    } else {
+      totalBtyesToRead = FW_DNLD_HEADER_LEN;
+    }
+
+    if (numRead < totalBtyesToRead) {
+      ret_Read = read((intptr_t)pDevHandle, (pBuffer + numRead), totalBtyesToRead - numRead);
+
+      if (ret_Read != totalBtyesToRead - numRead) {
+        SemPost();
+        NXPLOG_TML_E("%s [hdr] errno : %x", __func__, errno);
+        return -1;
+      } else {
+        numRead += ret_Read;
+      }
+    }
+    if (bFwDnldFlag == true) {
+      totalBtyesToRead = pBuffer[FW_DNLD_LEN_OFFSET] + FW_DNLD_HEADER_LEN + CRC_LEN;
+    } else {
+      totalBtyesToRead = pBuffer[NORMAL_MODE_LEN_OFFSET] + NORMAL_MODE_HEADER_LEN;
+    }
+    if ((totalBtyesToRead - numRead) != 0) {
+      ret_Read = read((intptr_t)pDevHandle, (pBuffer + numRead), totalBtyesToRead - numRead);
+      if (ret_Read > 0) {
+        numRead += ret_Read;
+      } else if (ret_Read == 0) {
+        SemPost();
+        NXPLOG_TML_E("%s [pyld] EOF", __func__);
+        return -1;
+      } else {
+        if (bFwDnldFlag == false) {
+          NXPLOG_TML_D("_i2c_read() [hdr] received");
+          phNxpNciHal_print_packet("RECV", pBuffer, NORMAL_MODE_HEADER_LEN);
+        }
+        SemPost();
+        NXPLOG_TML_E("%s [pyld] errno : %x", __func__, errno);
+        return -1;
+      }
+    } else {
+      NXPLOG_TML_E("%s _>>>>> Empty packet recieved !!", __func__);
+    }
+  }
+  SemPost();
+  return numRead;
+}
+
+/*******************************************************************************
+**
+** Function         Write
+**
+** Description      Writes requested number of bytes from given buffer into
+**                  NFCC device
+**
+** Parameters       pDevHandle       - valid device handle
+**                  pBuffer          - buffer for read data
+**                  nNbBytesToWrite  - number of bytes requested to be written
+**
+** Returns          numWrote   - number of successfully written bytes
+**                  -1         - write operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::Write(void *pDevHandle, uint8_t *pBuffer,
+                            int nNbBytesToWrite) {
+  int ret;
+  int numWrote = 0;
+  int numBytes = nNbBytesToWrite;
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+  if (fragmentation_enabled == I2C_FRAGMENATATION_DISABLED &&
+      nNbBytesToWrite > FRAGMENTSIZE_MAX) {
+    NXPLOG_TML_D(
+        "%s data larger than maximum I2C  size,enable I2C fragmentation",
+        __func__);
+    return -1;
+  }
+  while (numWrote < nNbBytesToWrite) {
+    if (fragmentation_enabled == I2C_FRAGMENTATION_ENABLED &&
+        nNbBytesToWrite > FRAGMENTSIZE_MAX) {
+      if (nNbBytesToWrite - numWrote > FRAGMENTSIZE_MAX) {
+        numBytes = numWrote + FRAGMENTSIZE_MAX;
+      } else {
+        numBytes = nNbBytesToWrite;
+      }
+    }
+    SemTimedWait();
+    ret = write((intptr_t)pDevHandle, pBuffer + numWrote, numBytes - numWrote);
+    SemPost();
+    if (ret > 0) {
+      numWrote += ret;
+      if (fragmentation_enabled == I2C_FRAGMENTATION_ENABLED &&
+          numWrote < nNbBytesToWrite) {
+        usleep(500);
+      }
+    } else if (ret == 0) {
+      NXPLOG_TML_D("%s EOF", __func__);
+      return -1;
+    } else {
+      NXPLOG_TML_D("%s errno : %x", __func__, errno);
+      if (errno == EINTR || errno == EAGAIN) {
+        continue;
+      }
+      return -1;
+    }
+  }
+
+  return numWrote;
+}
+
+/*******************************************************************************
+**
+** Function         Reset
+**
+** Description      Reset NFCC device, using VEN pin
+**
+** Parameters       pDevHandle     - valid device handle
+**                  eType          - reset level
+**
+** Returns           0   - reset operation success
+**                  -1   - reset operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::NfccReset(void *pDevHandle, NfccResetType eType) {
+  int ret = -1;
+  NXPLOG_TML_D("%s, VEN eType %ld", __func__, eType);
+
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+
+  ret = ioctl((intptr_t)pDevHandle, NFC_SET_PWR, eType);
+  if (ret < 0) {
+    NXPLOG_TML_E("%s :failed errno = 0x%x", __func__, errno);
+  }
+  if ((eType != MODE_FW_DWNLD_WITH_VEN && eType != MODE_FW_DWND_HIGH) &&
+      ret == 0) {
+    EnableFwDnldMode(false);
+  }
+  if ((((eType == MODE_FW_DWNLD_WITH_VEN) || (eType == MODE_FW_DWND_HIGH)) && (ret == 0))) {
+    EnableFwDnldMode(true);
+  }
+
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         EseReset
+**
+** Description      Request NFCC to reset the eSE
+**
+** Parameters       pDevHandle     - valid device handle
+**                  eType          - EseResetType
+**
+** Returns           0   - reset operation success
+**                  else - reset operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::EseReset(void *pDevHandle, EseResetType eType) {
+  int ret = -1;
+  NXPLOG_TML_D("%s, eType %ld", __func__, eType);
+
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+  ret = ioctl((intptr_t)pDevHandle, ESE_SET_PWR, eType);
+  if (ret < 0) {
+    NXPLOG_TML_E("%s :failed errno = 0x%x", __func__, errno);
+  }
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         EseGetPower
+**
+** Description      Request NFCC to reset the eSE
+**
+** Parameters       pDevHandle     - valid device handle
+**                  level          - reset level
+**
+** Returns           0   - reset operation success
+**                  else - reset operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::EseGetPower(void *pDevHandle, long level) {
+  return ioctl((intptr_t)pDevHandle, ESE_GET_PWR, level);
+}
+
+/*******************************************************************************
+**
+** Function         GetPlatform
+**
+** Description      Get platform interface type (i2c or i3c) for common mw
+**
+** Parameters       pDevHandle     - valid device handle
+**
+** Returns           0   - i2c
+**                   1   - i3c
+**
+*******************************************************************************/
+int NfccI2cTransport::GetPlatform(void *pDevHandle) {
+  int ret = -1;
+  NXPLOG_TML_D("%s ", __func__);
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+  ret = ioctl((intptr_t)pDevHandle, NFC_GET_PLATFORM_TYPE);
+  NXPLOG_TML_D("%s :platform = %d", __func__, ret);
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         GetNfcState
+**
+** Description      Get NFC state
+**
+** Parameters       pDevHandle     - valid device handle
+** Returns           0   - unknown
+**                   1   - FW DWL
+**                   2 	 - NCI
+**
+*******************************************************************************/
+int NfccI2cTransport::GetNfcState(void *pDevHandle) {
+  int ret = NFC_STATE_UNKNOWN;
+  NXPLOG_TML_D("%s ", __func__);
+  if (NULL == pDevHandle) {
+    return ret;
+  }
+  ret = ioctl((intptr_t)pDevHandle, NFC_GET_NFC_STATE);
+  NXPLOG_TML_D("%s :nfc state = %d", __func__, ret);
+  return ret;
+}
+/*******************************************************************************
+**
+** Function         EnableFwDnldMode
+**
+** Description      updates the state to Download mode
+**
+** Parameters       True/False
+**
+** Returns          None
+*******************************************************************************/
+void NfccI2cTransport::EnableFwDnldMode(bool mode) { bFwDnldFlag = mode; }
+
+/*******************************************************************************
+**
+** Function         IsFwDnldModeEnabled
+**
+** Description      Returns the current mode
+**
+** Parameters       none
+**
+** Returns           Current mode download/NCI
+*******************************************************************************/
+bool_t NfccI2cTransport::IsFwDnldModeEnabled(void) { return bFwDnldFlag; }
+
+/*******************************************************************************
+**
+** Function         SemPost
+**
+** Description      sem_post 2c_read / write
+**
+** Parameters       none
+**
+** Returns          none
+*******************************************************************************/
+void NfccI2cTransport::SemPost() {
+  int sem_val = 0;
+  sem_getvalue(&mTxRxSemaphore, &sem_val);
+  if (sem_val == 0) {
+    sem_post(&mTxRxSemaphore);
+  }
+}
+
+/*******************************************************************************
+**
+** Function         SemTimedWait
+**
+** Description      Timed sem_wait for avoiding i2c_read & write overlap
+**
+** Parameters       none
+**
+** Returns          Sem_wait return status
+*******************************************************************************/
+int NfccI2cTransport::SemTimedWait() {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  long sem_timedout = 500 * 1000 * 1000;
+  int s = 0;
+  struct timespec ts;
+  clock_gettime(CLOCK_REALTIME, &ts);
+  ts.tv_sec += 0;
+  ts.tv_nsec += sem_timedout;
+  while ((s = sem_timedwait(&mTxRxSemaphore, &ts)) == -1 && errno == EINTR) {
+    continue; /* Restart if interrupted by handler */
+  }
+  if (s != -1) {
+    status = NFCSTATUS_SUCCESS;
+  } else if (errno == ETIMEDOUT && s == -1) {
+    NXPLOG_TML_E("%s :timed out errno = 0x%x", __func__, errno);
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         GetIrqState
+**
+** Description      Get state of IRQ GPIO
+**
+** Parameters       pDevHandle - valid device handle
+**
+** Returns          The state of IRQ line i.e. +ve if read is pending else Zer0.
+**                  In the case of IOCTL error, it returns -ve value.
+**
+*******************************************************************************/
+int NfccI2cTransport::GetIrqState(void *pDevHandle) {
+  int ret = -1;
+
+  NXPLOG_TML_D("%s Enter",__func__);
+  if (NULL != pDevHandle) {
+    ret = ioctl((intptr_t)pDevHandle, NFC_GET_IRQ_STATE);
+  }
+  NXPLOG_TML_D("%s exit: state = %d", __func__, ret);
+  return ret;
+}
diff --git a/pn8x/halimpl/tml/transport/NfccI2cTransport.h b/pn8x/halimpl/tml/transport/NfccI2cTransport.h
new file mode 100755
index 0000000..ae684b8
--- /dev/null
+++ b/pn8x/halimpl/tml/transport/NfccI2cTransport.h
@@ -0,0 +1,266 @@
+/******************************************************************************
+ *
+ *  Copyright 2020-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#pragma once
+#include <NfccTransport.h>
+
+#define NFC_MAGIC 0xE9
+/*
+ * NFCC power control via ioctl
+ * NFC_SET_PWR(0): power off
+ * NFC_SET_PWR(1): power on
+ * NFC_SET_PWR(2): reset and power on with firmware download enabled
+ */
+#define NFC_SET_PWR _IOW(NFC_MAGIC, 0x01, long)
+/*
+ * 1. SPI Request NFCC to enable ESE power, only in param
+ *   Only for SPI
+ *   level 1 = Enable power
+ *   level 0 = Disable power
+ * 2. NFC Request the eSE cold reset, only with MODE_ESE_COLD_RESET
+ */
+#define ESE_SET_PWR _IOW(NFC_MAGIC, 0x02, long)
+
+/*
+ * SPI or DWP can call this ioctl to get the current
+ * power state of ESE
+ */
+#define ESE_GET_PWR _IOR(NFC_MAGIC, 0x03, long)
+
+/*
+ * get platform interface type(i2c or i3c) for common MW
+ * return 0 - i2c, 1 - i3c
+ */
+#define NFC_GET_PLATFORM_TYPE _IO(NFC_MAGIC, 0x04)
+/*
+ * get boot state
+ * return unknown, fw dwl, fw teared, nci
+ */
+#define NFC_GET_NFC_STATE _IO(NFC_MAGIC, 0x05)
+
+/* NFC HAL can call this ioctl to get the current IRQ state */
+#define NFC_GET_IRQ_STATE _IO(NFC_MAGIC, 0x06)
+
+extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
+
+class NfccI2cTransport : public NfccTransport {
+ private:
+  bool_t bFwDnldFlag = false;
+  sem_t mTxRxSemaphore;
+  /*****************************************************************************
+   **
+   ** Function         SemTimedWait
+   **
+   ** Description      Timed sem_wait for avoiding i2c_read & write overlap
+   **
+   ** Parameters       none
+   **
+   ** Returns          Sem_wait return status
+   ****************************************************************************/
+  int SemTimedWait();
+
+  /*****************************************************************************
+   **
+   ** Function         SemPost
+   **
+   ** Description      sem_post 2c_read / write
+   **
+   ** Parameters       none
+   **
+   ** Returns          none
+   ****************************************************************************/
+  void SemPost();
+
+  int Flushdata(void* pDevHandle, uint8_t* pBuffer, int numRead);
+
+ public:
+  /*****************************************************************************
+  **
+  ** Function         Close
+  **
+  ** Description      Closes NFCC device
+  **
+  ** Parameters       pDevHandle - device handle
+  **
+  ** Returns          None
+  **
+  *****************************************************************************/
+  void Close(void *pDevHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         OpenAndConfigure
+   **
+   ** Description      Open and configure NFCC device
+   **
+   ** Parameters       pConfig     - hardware information
+   **                  pLinkHandle - device handle
+   **
+   ** Returns          NFC status:
+   **                  NFCSTATUS_SUCCESS - open_and_configure operation success
+   **                  NFCSTATUS_INVALID_DEVICE - device open operation failure
+   **
+   ****************************************************************************/
+  NFCSTATUS OpenAndConfigure(pphTmlNfc_Config_t pConfig, void **pLinkHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         Read
+   **
+   ** Description      Reads requested number of bytes from NFCC device into
+   *given
+   **                  buffer
+   **
+   ** Parameters       pDevHandle       - valid device handle
+   **                  pBuffer          - buffer for read data
+   **                  nNbBytesToRead   - number of bytes requested to be read
+   **
+   ** Returns          numRead   - number of successfully read bytes
+   **                  -1        - read operation failure
+   **
+   ****************************************************************************/
+  int Read(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToRead);
+
+  /*****************************************************************************
+  **
+  ** Function         Write
+  **
+  ** Description      Writes requested number of bytes from given buffer into
+  **                  NFCC device
+  **
+  ** Parameters       pDevHandle       - valid device handle
+  **                  pBuffer          - buffer for read data
+  **                  nNbBytesToWrite  - number of bytes requested to be written
+  **
+  ** Returns          numWrote   - number of successfully written bytes
+  **                  -1         - write operation failure
+  **
+  *****************************************************************************/
+  int Write(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToWrite);
+
+  /*****************************************************************************
+   **
+   ** Function         Reset
+   **
+   ** Description      Reset NFCC device, using VEN pin
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  level          - reset level
+   **
+   ** Returns           0   - reset operation success
+   **                  -1   - reset operation failure
+   **
+   ****************************************************************************/
+  int NfccReset(void *pDevHandle, NfccResetType eType);
+
+  /*****************************************************************************
+   **
+   ** Function         EseReset
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  eType          - EseResetType
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  int EseReset(void *pDevHandle, EseResetType eType);
+
+  /*****************************************************************************
+   **
+   ** Function         EseGetPower
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  level          - reset level
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  int EseGetPower(void *pDevHandle, long level);
+
+  /*****************************************************************************
+   **
+   ** Function         GetPlatform
+   **
+   ** Description      Get platform interface type (i2c or i3c) for common mw
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **
+   ** Returns           0   - i2c
+   **                   1   - i3c
+   **
+   ****************************************************************************/
+  int GetPlatform(void *pDevHandle);
+
+  /*****************************************************************************
+  **
+  ** Function         GetNfcState
+  **
+  ** Description      Get Nfc state
+  **
+  ** Parameters       pDevHandle     - valid device handle
+  ** Returns           0   - unknown
+  **                   1   - FW DWL
+  **                   2   - NCI
+  **
+  *****************************************************************************/
+  int GetNfcState(void *pDevHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         EnableFwDnldMode
+   **
+   ** Description      updates the state to Download mode
+   **
+   ** Parameters       True/False
+   **
+   ** Returns          None
+   ****************************************************************************/
+  void EnableFwDnldMode(bool mode);
+
+  /*****************************************************************************
+   **
+   ** Function         IsFwDnldModeEnabled
+   **
+   ** Description      Returns the current mode
+   **
+   ** Parameters       none
+   **
+   ** Returns           Current mode download/NCI
+   ****************************************************************************/
+  bool_t IsFwDnldModeEnabled(void);
+
+  /*******************************************************************************
+   **
+   ** Function         GetIrqState
+   **
+   ** Description      Get state of IRQ GPIO
+   **
+   ** Parameters       pDevHandle - valid device handle
+   **
+   ** Returns          The state of IRQ line i.e. +ve if read is pending else Zer0.
+   **                  In the case of IOCTL error, it returns -ve value.
+   **
+   *******************************************************************************/
+  int GetIrqState(void *pDevHandle);
+};
diff --git a/pn8x/halimpl/tml/transport/NfccSpiTransport.cc b/pn8x/halimpl/tml/transport/NfccSpiTransport.cc
new file mode 100755
index 0000000..82cf97f
--- /dev/null
+++ b/pn8x/halimpl/tml/transport/NfccSpiTransport.cc
@@ -0,0 +1,533 @@
+/******************************************************************************
+ *  Copyright 2020-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <errno.h>
+#include <fcntl.h>
+#include <hardware/nfc.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/select.h>
+#include <termios.h>
+#include <unistd.h>
+
+#include "phNxpNciHal_utils.h"
+#include <NfccSpiTransport.h>
+#include <phNfcStatus.h>
+#include <phNxpLog.h>
+#include <string.h>
+
+#define CRC_LEN 2
+#define NORMAL_MODE_HEADER_LEN 3
+#define FW_DNLD_HEADER_LEN 2
+#define FW_DNLD_LEN_OFFSET 1
+#define NORMAL_MODE_LEN_OFFSET 2
+#define FRAGMENTSIZE_MAX PHNFC_I2C_FRAGMENT_SIZE
+extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
+extern phTmlNfc_Context_t *gpphTmlNfc_Context;
+/*******************************************************************************
+**
+** Function         Close
+**
+** Description      Closes NFCC device
+**
+** Parameters       pDevHandle - device handle
+**
+** Returns          None
+**
+*******************************************************************************/
+void NfccSpiTransport::Close(void *pDevHandle) {
+  if (NULL != pDevHandle) {
+    close((intptr_t)pDevHandle);
+  }
+  sem_destroy(&mTxRxSemaphore);
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         OpenAndConfigure
+**
+** Description      Open and configure NFCC device
+**
+** Parameters       pConfig     - hardware information
+**                  pLinkHandle - device handle
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - open_and_configure operation success
+**                  NFCSTATUS_INVALID_DEVICE - device open operation failure
+**
+*******************************************************************************/
+NFCSTATUS NfccSpiTransport::OpenAndConfigure(pphTmlNfc_Config_t pConfig,
+                                             void **pLinkHandle) {
+  int nHandle;
+
+  NXPLOG_TML_D("%s Opening port=%s\n", __func__, pConfig->pDevName);
+  /* open port */
+  nHandle = open((const char *)pConfig->pDevName, O_RDWR);
+  if (nHandle < 0) {
+    NXPLOG_TML_E("_i2c_open() Failed: retval %x", nHandle);
+    *pLinkHandle = NULL;
+    return NFCSTATUS_INVALID_DEVICE;
+  }
+
+  *pLinkHandle = (void *)((intptr_t)nHandle);
+  if (0 != sem_init(&mTxRxSemaphore, 0, 1)) {
+    NXPLOG_TML_E("%s Failed: reason sem_init : retval %x", __func__, nHandle);
+  }
+  /*Reset PN54X*/
+  NfccReset((void *)((intptr_t)nHandle), MODE_POWER_OFF);
+  usleep(10 * 1000);
+  NfccReset((void *)((intptr_t)nHandle), MODE_POWER_ON);
+
+  return NFCSTATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         Flushdata
+**
+** Description      Reads payload of FW rsp from NFCC device into given buffer
+**
+** Parameters       pDevHandle - valid device handle
+**                  pBuffer    - buffer for read data
+**                  numRead    - number of bytes read by calling function
+**
+** Returns          always returns -1
+**
+*******************************************************************************/
+int NfccSpiTransport::Flushdata(void* pDevHandle, uint8_t* pBuffer, int numRead) {
+  int retRead = 0;
+  uint16_t totalBtyesToRead = pBuffer[FW_DNLD_LEN_OFFSET] + FW_DNLD_HEADER_LEN + CRC_LEN;
+  /* we shall read totalBtyesToRead-1 as one byte is already read by calling function*/
+  retRead = read((intptr_t)pDevHandle, pBuffer + numRead, totalBtyesToRead - 1);
+  if (retRead > 0) {
+    numRead += retRead;
+    phNxpNciHal_print_packet("RECV", pBuffer, numRead);
+  } else if (retRead == 0) {
+    NXPLOG_TML_E("%s _i2c_read() [pyld] EOF", __func__);
+  } else {
+    if (bFwDnldFlag == false) {
+      NXPLOG_TML_D("%s _i2c_read() [hdr] received", __func__);
+      phNxpNciHal_print_packet("RECV", pBuffer - numRead, NORMAL_MODE_HEADER_LEN);
+    }
+    NXPLOG_TML_E("%s _i2c_read() [pyld] errno : %x", __func__, errno);
+  }
+  SemPost();
+  return -1;
+}
+
+/*******************************************************************************
+**
+** Function         Read
+**
+** Description      Reads requested number of bytes from NFCC device into given
+**                  buffer
+**
+** Parameters       pDevHandle       - valid device handle
+**                  pBuffer          - buffer for read data
+**                  nNbBytesToRead   - number of bytes requested to be read
+**
+** Returns          numRead   - number of successfully read bytes
+**                  -1        - read operation failure
+**
+*******************************************************************************/
+int NfccSpiTransport::Read(void *pDevHandle, uint8_t *pBuffer,
+                           int nNbBytesToRead) {
+  int ret_Read;
+  int ret_Select;
+  int numRead = 0;
+  struct timeval tv;
+  fd_set rfds;
+  uint16_t totalBtyesToRead = 0;
+
+  UNUSED(nNbBytesToRead);
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+
+  if (bFwDnldFlag == false) {
+    totalBtyesToRead = NORMAL_MODE_HEADER_LEN;
+  } else {
+    totalBtyesToRead = FW_DNLD_HEADER_LEN;
+  }
+
+  /* Read with 2 second timeout, so that the read thread can be aborted
+     when the NFCC does not respond and we need to switch to FW download
+     mode. This should be done via a control socket instead. */
+  FD_ZERO(&rfds);
+  FD_SET((intptr_t)pDevHandle, &rfds);
+  tv.tv_sec = 2;
+  tv.tv_usec = 1;
+
+  ret_Select =
+      select((int)((intptr_t)pDevHandle + (int)1), &rfds, NULL, NULL, &tv);
+  if (ret_Select < 0) {
+    NXPLOG_TML_D("%s errno : %x", __func__, errno);
+    return -1;
+  } else if (ret_Select == 0) {
+    NXPLOG_TML_D("%s Timeout", __func__);
+    return -1;
+  } else {
+    ret_Read = read((intptr_t)pDevHandle, pBuffer, totalBtyesToRead - numRead);
+    if (ret_Read > 0 && !(pBuffer[0] == 0xFF && pBuffer[1] == 0xFF)) {
+      SemTimedWait();
+      numRead += ret_Read;
+    } else if (ret_Read == 0) {
+      NXPLOG_TML_E("%s [hdr]EOF", __func__);
+      return -1;
+    } else {
+      NXPLOG_TML_E("%s [hdr] errno : %x", __func__, errno);
+      NXPLOG_TML_E(" %s pBuffer[0] = %x pBuffer[1]= %x", __func__, pBuffer[0],
+                   pBuffer[1]);
+      return -1;
+    }
+
+    if (bFwDnldFlag == false) {
+      totalBtyesToRead = NORMAL_MODE_HEADER_LEN;
+#if(NXP_EXTNS == TRUE)
+      if (gpphTmlNfc_Context->tReadInfo.pContext != NULL &&
+              !memcmp(gpphTmlNfc_Context->tReadInfo.pContext, "MinOpen", 0x07) &&
+              !pBuffer[0] && pBuffer[1]) {
+        return Flushdata(pDevHandle, pBuffer, numRead);
+      }
+#endif
+    } else {
+      totalBtyesToRead = FW_DNLD_HEADER_LEN;
+    }
+
+    if (numRead < totalBtyesToRead) {
+      ret_Read = read((intptr_t)pDevHandle, (pBuffer + numRead), totalBtyesToRead - numRead);
+
+      if (ret_Read != totalBtyesToRead - numRead) {
+        SemPost();
+        NXPLOG_TML_E("%s [hdr] errno : %x", __func__, errno);
+        return -1;
+      } else {
+        numRead += ret_Read;
+      }
+    }
+    if (bFwDnldFlag == true) {
+      totalBtyesToRead = pBuffer[FW_DNLD_LEN_OFFSET] + FW_DNLD_HEADER_LEN + CRC_LEN;
+    } else {
+      totalBtyesToRead = pBuffer[NORMAL_MODE_LEN_OFFSET] + NORMAL_MODE_HEADER_LEN;
+    }
+    if ((totalBtyesToRead - numRead) != 0) {
+      ret_Read = read((intptr_t)pDevHandle, (pBuffer + numRead), totalBtyesToRead - numRead);
+      if (ret_Read > 0) {
+        numRead += ret_Read;
+      } else if (ret_Read == 0) {
+        SemPost();
+        NXPLOG_TML_E("%s [pyld] EOF", __func__);
+        return -1;
+      } else {
+        if (bFwDnldFlag == false) {
+          NXPLOG_TML_D("_i2c_read() [hdr] received");
+          phNxpNciHal_print_packet("RECV", pBuffer, NORMAL_MODE_HEADER_LEN);
+        }
+        SemPost();
+        NXPLOG_TML_E("%s [pyld] errno : %x", __func__, errno);
+        return -1;
+      }
+    } else {
+      NXPLOG_TML_E("%s _>>>>> Empty packet recieved !!", __func__);
+    }
+  }
+  SemPost();
+  return numRead;
+}
+
+/*******************************************************************************
+**
+** Function         Write
+**
+** Description      Writes requested number of bytes from given buffer into
+**                  NFCC device
+**
+** Parameters       pDevHandle       - valid device handle
+**                  pBuffer          - buffer for read data
+**                  nNbBytesToWrite  - number of bytes requested to be written
+**
+** Returns          numWrote   - number of successfully written bytes
+**                  -1         - write operation failure
+**
+*******************************************************************************/
+int NfccSpiTransport::Write(void *pDevHandle, uint8_t *pBuffer,
+                            int nNbBytesToWrite) {
+  int ret;
+  int numWrote = 0;
+  int numBytes = nNbBytesToWrite;
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+  if (fragmentation_enabled == I2C_FRAGMENATATION_DISABLED &&
+      nNbBytesToWrite > FRAGMENTSIZE_MAX) {
+    NXPLOG_TML_D(
+        "%s data larger than maximum I2C  size,enable I2C fragmentation",
+        __func__);
+    return -1;
+  }
+  while (numWrote < nNbBytesToWrite) {
+    if (fragmentation_enabled == I2C_FRAGMENTATION_ENABLED &&
+        nNbBytesToWrite > FRAGMENTSIZE_MAX) {
+      if (nNbBytesToWrite - numWrote > FRAGMENTSIZE_MAX) {
+        numBytes = numWrote + FRAGMENTSIZE_MAX;
+      } else {
+        numBytes = nNbBytesToWrite;
+      }
+    }
+    SemTimedWait();
+    ret = write((intptr_t)pDevHandle, pBuffer + numWrote, numBytes - numWrote);
+    SemPost();
+    if (ret > 0) {
+      numWrote += ret;
+      if (fragmentation_enabled == I2C_FRAGMENTATION_ENABLED &&
+          numWrote < nNbBytesToWrite) {
+        usleep(500);
+      }
+    } else if (ret == 0) {
+      NXPLOG_TML_D("%s EOF", __func__);
+      return -1;
+    } else {
+      NXPLOG_TML_D("%s errno : %x", __func__, errno);
+      if (errno == EINTR || errno == EAGAIN) {
+        continue;
+      }
+      return -1;
+    }
+  }
+
+  return numWrote;
+}
+
+/*******************************************************************************
+**
+** Function         NfccReset
+**
+** Description      Reset NFCC device, using VEN pin
+**
+** Parameters       pDevHandle     - valid device handle
+**                  eType          - reset level
+**
+** Returns           0   - reset operation success
+**                  -1   - reset operation failure
+**
+*******************************************************************************/
+int NfccSpiTransport::NfccReset(void *pDevHandle, NfccResetType eType) {
+  int ret = -1;
+  NXPLOG_TML_D("%s, VEN eType %ld", __func__, eType);
+
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+
+  ret = ioctl((intptr_t)pDevHandle, NFC_SET_PWR, eType);
+  if (ret < 0) {
+    NXPLOG_TML_E("%s :failed errno = 0x%x", __func__, errno);
+  }
+  if ((eType != MODE_FW_DWNLD_WITH_VEN && eType != MODE_FW_DWND_HIGH) &&
+      ret == 0) {
+    EnableFwDnldMode(false);
+  }
+  if ((((eType == MODE_FW_DWNLD_WITH_VEN) || (eType == MODE_FW_DWND_HIGH)) && (ret == 0))) {
+    EnableFwDnldMode(true);
+  }
+
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         EseReset
+**
+** Description      Request NFCC to reset the eSE
+**
+** Parameters       pDevHandle     - valid device handle
+**                  eType          - EseResetType
+**
+** Returns           0   - reset operation success
+**                  else - reset operation failure
+**
+*******************************************************************************/
+int NfccSpiTransport::EseReset(void *pDevHandle, EseResetType eType) {
+  int ret = -1;
+  NXPLOG_TML_D("%s, eType %ld", __func__, eType);
+
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+  ret = ioctl((intptr_t)pDevHandle, ESE_SET_PWR, eType);
+  if (ret < 0) {
+    NXPLOG_TML_E("%s :failed errno = 0x%x", __func__, errno);
+  }
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         EseGetPower
+**
+** Description      Request NFCC to reset the eSE
+**
+** Parameters       pDevHandle     - valid device handle
+**                  level          - reset level
+**
+** Returns           0   - reset operation success
+**                  else - reset operation failure
+**
+*******************************************************************************/
+int NfccSpiTransport::EseGetPower(void *pDevHandle, long level) {
+  return ioctl((intptr_t)pDevHandle, ESE_GET_PWR, level);
+}
+
+/*******************************************************************************
+**
+** Function         GetPlatform
+**
+** Description      Get platform interface type (i2c or i3c) for common mw
+**
+** Parameters       pDevHandle     - valid device handle
+**
+** Returns           0   - i2c
+**                   1   - i3c
+**
+*******************************************************************************/
+int NfccSpiTransport::GetPlatform(void *pDevHandle) {
+  int ret = -1;
+  NXPLOG_TML_D("%s ", __func__);
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+  ret = ioctl((intptr_t)pDevHandle, NFC_GET_PLATFORM_TYPE);
+  NXPLOG_TML_D("%s :platform = %d", __func__, ret);
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         GetNfcState
+**
+** Description      Get NFC state
+**
+** Parameters       pDevHandle     - valid device handle
+** Returns           0   - unknown
+**                   1   - FW DWL
+**                   2 	 - NCI
+**
+*******************************************************************************/
+int NfccSpiTransport::GetNfcState(void *pDevHandle) {
+  int ret = NFC_STATE_UNKNOWN;
+  NXPLOG_TML_D("%s ", __func__);
+  if (NULL == pDevHandle) {
+    return ret;
+  }
+  ret = ioctl((intptr_t)pDevHandle, NFC_GET_NFC_STATE);
+  NXPLOG_TML_D("%s :nfc state = %d", __func__, ret);
+  return ret;
+}
+/*******************************************************************************
+**
+** Function         EnableFwDnldMode
+**
+** Description      updates the state to Download mode
+**
+** Parameters       True/False
+**
+** Returns          None
+*******************************************************************************/
+void NfccSpiTransport::EnableFwDnldMode(bool mode) { bFwDnldFlag = mode; }
+
+/*******************************************************************************
+**
+** Function         IsFwDnldModeEnabled
+**
+** Description      Returns the current mode
+**
+** Parameters       none
+**
+** Returns           Current mode download/NCI
+*******************************************************************************/
+bool_t NfccSpiTransport::IsFwDnldModeEnabled(void) { return bFwDnldFlag; }
+
+/*******************************************************************************
+**
+** Function         SemPost
+**
+** Description      sem_post 2c_read / write
+**
+** Parameters       none
+**
+** Returns          none
+*******************************************************************************/
+void NfccSpiTransport::SemPost() {
+  int sem_val = 0;
+  sem_getvalue(&mTxRxSemaphore, &sem_val);
+  if (sem_val == 0) {
+    sem_post(&mTxRxSemaphore);
+  }
+}
+
+/*******************************************************************************
+**
+** Function         SemTimedWait
+**
+** Description      Timed sem_wait for avoiding i2c_read & write overlap
+**
+** Parameters       none
+**
+** Returns          Sem_wait return status
+*******************************************************************************/
+int NfccSpiTransport::SemTimedWait() {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  long sem_timedout = 500 * 1000 * 1000;
+  int s = 0;
+  struct timespec ts;
+  clock_gettime(CLOCK_REALTIME, &ts);
+  ts.tv_sec += 0;
+  ts.tv_nsec += sem_timedout;
+  while ((s = sem_timedwait(&mTxRxSemaphore, &ts)) == -1 && errno == EINTR) {
+    continue; /* Restart if interrupted by handler */
+  }
+  if (s != -1) {
+    status = NFCSTATUS_SUCCESS;
+  } else if (errno == ETIMEDOUT && s == -1) {
+    NXPLOG_TML_E("%s :timed out errno = 0x%x", __func__, errno);
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         GetIrqState
+**
+** Description      Get state of IRQ GPIO
+**
+** Parameters       pDevHandle - valid device handle
+**
+** Returns          The state of IRQ line i.e. +ve if read is pending else Zer0.
+**                  In the case of IOCTL error, it returns -ve value.
+**
+*******************************************************************************/
+int NfccSpiTransport::GetIrqState(void *pDevHandle) {
+  int ret = -1;
+
+  NXPLOG_TML_D("%s Enter",__func__);
+  if (NULL != pDevHandle) {
+    ret = ioctl((intptr_t)pDevHandle, NFC_GET_IRQ_STATE);
+  }
+  NXPLOG_TML_D("%s exit: state = %d", __func__, ret);
+  return ret;
+}
diff --git a/pn8x/halimpl/tml/transport/NfccSpiTransport.h b/pn8x/halimpl/tml/transport/NfccSpiTransport.h
new file mode 100755
index 0000000..d46ca18
--- /dev/null
+++ b/pn8x/halimpl/tml/transport/NfccSpiTransport.h
@@ -0,0 +1,266 @@
+/******************************************************************************
+ *
+ *  Copyright 2020-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#pragma once
+#include <NfccTransport.h>
+
+#define NFC_MAGIC 0xE9
+/*
+ * NFCC power control via ioctl
+ * NFC_SET_PWR(0): power off
+ * NFC_SET_PWR(1): power on
+ * NFC_SET_PWR(2): reset and power on with firmware download enabled
+ */
+#define NFC_SET_PWR _IOW(NFC_MAGIC, 0x01, long)
+/*
+ * 1. SPI Request NFCC to enable ESE power, only in param
+ *   Only for SPI
+ *   level 1 = Enable power
+ *   level 0 = Disable power
+ * 2. NFC Request the eSE cold reset, only with MODE_ESE_COLD_RESET
+ */
+#define ESE_SET_PWR _IOW(NFC_MAGIC, 0x02, long)
+
+/*
+ * SPI or DWP can call this ioctl to get the current
+ * power state of ESE
+ */
+#define ESE_GET_PWR _IOR(NFC_MAGIC, 0x03, long)
+
+/*
+ * get platform interface type(i2c or i3c) for common MW
+ * return 0 - i2c, 1 - i3c
+ */
+#define NFC_GET_PLATFORM_TYPE _IO(NFC_MAGIC, 0x04)
+/*
+ * get boot state
+ * return unknown, fw dwl, fw teared, nci
+ */
+#define NFC_GET_NFC_STATE _IO(NFC_MAGIC, 0x05)
+
+/* NFC HAL can call this ioctl to get the current IRQ state */
+#define NFC_GET_IRQ_STATE _IO(NFC_MAGIC, 0x06)
+
+extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
+
+class NfccSpiTransport : public NfccTransport {
+ private:
+  bool_t bFwDnldFlag = false;
+  sem_t mTxRxSemaphore;
+  /*****************************************************************************
+   **
+   ** Function         SemTimedWait
+   **
+   ** Description      Timed sem_wait for avoiding i2c_read & write overlap
+   **
+   ** Parameters       none
+   **
+   ** Returns          Sem_wait return status
+   ****************************************************************************/
+  int SemTimedWait();
+
+  /*****************************************************************************
+   **
+   ** Function         SemPost
+   **
+   ** Description      sem_post 2c_read / write
+   **
+   ** Parameters       none
+   **
+   ** Returns          none
+   ****************************************************************************/
+  void SemPost();
+
+  int Flushdata(void* pDevHandle, uint8_t* pBuffer, int numRead);
+
+ public:
+  /*****************************************************************************
+  **
+  ** Function         Close
+  **
+  ** Description      Closes NFCC device
+  **
+  ** Parameters       pDevHandle - device handle
+  **
+  ** Returns          None
+  **
+  *****************************************************************************/
+  void Close(void *pDevHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         OpenAndConfigure
+   **
+   ** Description      Open and configure NFCC device
+   **
+   ** Parameters       pConfig     - hardware information
+   **                  pLinkHandle - device handle
+   **
+   ** Returns          NFC status:
+   **                  NFCSTATUS_SUCCESS - open_and_configure operation success
+   **                  NFCSTATUS_INVALID_DEVICE - device open operation failure
+   **
+   ****************************************************************************/
+  NFCSTATUS OpenAndConfigure(pphTmlNfc_Config_t pConfig, void **pLinkHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         Read
+   **
+   ** Description      Reads requested number of bytes from NFCC device into
+   *given
+   **                  buffer
+   **
+   ** Parameters       pDevHandle       - valid device handle
+   **                  pBuffer          - buffer for read data
+   **                  nNbBytesToRead   - number of bytes requested to be read
+   **
+   ** Returns          numRead   - number of successfully read bytes
+   **                  -1        - read operation failure
+   **
+   ****************************************************************************/
+  int Read(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToRead);
+
+  /*****************************************************************************
+  **
+  ** Function         Write
+  **
+  ** Description      Writes requested number of bytes from given buffer into
+  **                  NFCC device
+  **
+  ** Parameters       pDevHandle       - valid device handle
+  **                  pBuffer          - buffer for read data
+  **                  nNbBytesToWrite  - number of bytes requested to be written
+  **
+  ** Returns          numWrote   - number of successfully written bytes
+  **                  -1         - write operation failure
+  **
+  *****************************************************************************/
+  int Write(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToWrite);
+
+  /*****************************************************************************
+   **
+   ** Function         NfccReset
+   **
+   ** Description      Reset NFCC device, using VEN pin
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  level          - reset level
+   **
+   ** Returns           0   - reset operation success
+   **                  -1   - reset operation failure
+   **
+   ****************************************************************************/
+  int NfccReset(void *pDevHandle, NfccResetType eType);
+
+  /*****************************************************************************
+   **
+   ** Function         EseReset
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  eType          - EseResetType
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  int EseReset(void *pDevHandle, EseResetType eType);
+
+  /*****************************************************************************
+   **
+   ** Function         EseGetPower
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  level          - reset level
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  int EseGetPower(void *pDevHandle, long level);
+
+  /*****************************************************************************
+   **
+   ** Function         GetPlatform
+   **
+   ** Description      Get platform interface type (i2c or i3c) for common mw
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **
+   ** Returns           0   - i2c
+   **                   1   - i3c
+   **
+   ****************************************************************************/
+  int GetPlatform(void *pDevHandle);
+
+  /*****************************************************************************
+  **
+  ** Function         GetNfcState
+  **
+  ** Description      Get Nfc state
+  **
+  ** Parameters       pDevHandle     - valid device handle
+  ** Returns           0   - unknown
+  **                   1   - FW DWL
+  **                   2   - NCI
+  **
+  *****************************************************************************/
+  int GetNfcState(void *pDevHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         EnableFwDnldMode
+   **
+   ** Description      updates the state to Download mode
+   **
+   ** Parameters       True/False
+   **
+   ** Returns          None
+   ****************************************************************************/
+  void EnableFwDnldMode(bool mode);
+
+  /*****************************************************************************
+   **
+   ** Function         IsFwDnldModeEnabled
+   **
+   ** Description      Returns the current mode
+   **
+   ** Parameters       none
+   **
+   ** Returns           Current mode download/NCI
+   ****************************************************************************/
+  bool_t IsFwDnldModeEnabled(void);
+
+  /*******************************************************************************
+   **
+   ** Function         GetIrqState
+   **
+   ** Description      Get state of IRQ GPIO
+   **
+   ** Parameters       pDevHandle - valid device handle
+   **
+   ** Returns          The state of IRQ line i.e. +ve if read is pending else Zer0.
+   **                  In the case of IOCTL error, it returns -ve value.
+   **
+   *******************************************************************************/
+  int GetIrqState(void *pDevHandle);
+};
diff --git a/pn8x/halimpl/tml/transport/NfccTransport.cc b/pn8x/halimpl/tml/transport/NfccTransport.cc
new file mode 100755
index 0000000..4380035
--- /dev/null
+++ b/pn8x/halimpl/tml/transport/NfccTransport.cc
@@ -0,0 +1,50 @@
+/******************************************************************************
+ *
+ *  Copyright 2020-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <NfccTransport.h>
+
+int NfccTransport::NfccReset(__attribute__((unused)) void *pDevHandle,
+                             __attribute__((unused)) NfccResetType eType) {
+  return NFCSTATUS_SUCCESS;
+}
+
+int NfccTransport::EseReset(__attribute__((unused)) void *pDevHandle,
+                            __attribute__((unused)) EseResetType eType) {
+  return NFCSTATUS_SUCCESS;
+}
+int NfccTransport::EseGetPower(__attribute__((unused)) void *pDevHandle,
+                               __attribute__((unused)) long level) {
+  return NFCSTATUS_SUCCESS;
+}
+
+int NfccTransport::GetPlatform(__attribute__((unused)) void *pDevHandle) {
+  return 0x00;
+}
+
+int NfccTransport::GetNfcState(__attribute__((unused)) void *pDevHandle) {
+  return NFC_STATE_UNKNOWN;
+}
+
+void NfccTransport::EnableFwDnldMode(__attribute__((unused)) bool mode) {
+  return;
+}
+int NfccTransport::GetIrqState(__attribute__((unused)) void *pDevHandle) {
+  return -1;
+}
+
+bool_t NfccTransport::IsFwDnldModeEnabled(void) { return false; }
diff --git a/pn8x/halimpl/tml/transport/NfccTransport.h b/pn8x/halimpl/tml/transport/NfccTransport.h
new file mode 100755
index 0000000..2d2f2d3
--- /dev/null
+++ b/pn8x/halimpl/tml/transport/NfccTransport.h
@@ -0,0 +1,246 @@
+/******************************************************************************
+ *
+ *  Copyright 2020-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#pragma once
+#include <phNfcTypes.h>
+#include <phTmlNfc.h>
+
+enum NfccResetType : long {
+  MODE_POWER_OFF = 0x00,
+  MODE_POWER_ON,
+  MODE_FW_DWNLD_WITH_VEN,
+  MODE_ISO_RST,
+  MODE_FW_DWND_HIGH,
+  MODE_POWER_RESET,
+  MODE_FW_GPIO_LOW
+};
+
+enum EseResetCallSrc : long {
+  SRC_SPI = 0x0,
+  SRC_NFC = 0x10,
+};
+
+enum EseResetType : long {
+  MODE_ESE_POWER_ON = 0,
+  MODE_ESE_POWER_OFF,
+  MODE_ESE_POWER_STATE,
+  /*Request from eSE HAL/Service*/
+  MODE_ESE_COLD_RESET,
+  MODE_ESE_RESET_PROTECTION_ENABLE,
+  MODE_ESE_RESET_PROTECTION_DISABLE,
+  /*Request from NFC HAL/Service*/
+  MODE_ESE_COLD_RESET_NFC = MODE_ESE_COLD_RESET | SRC_NFC,
+  MODE_ESE_RESET_PROTECTION_ENABLE_NFC =
+      MODE_ESE_RESET_PROTECTION_ENABLE | SRC_NFC,
+  MODE_ESE_RESET_PROTECTION_DISABLE_NFC =
+      MODE_ESE_RESET_PROTECTION_DISABLE | SRC_NFC,
+};
+
+extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
+
+class NfccTransport {
+public:
+  /*****************************************************************************
+   **
+   ** Function         Close
+   **
+   ** Description      Closes NFCC device
+   **
+   ** Parameters       pDevHandle - device handle
+   **
+   ** Returns          None
+   **
+   *****************************************************************************/
+  virtual void Close(void *pDevHandle) = 0;
+
+  /*****************************************************************************
+   **
+   ** Function         OpenAndConfigure
+   **
+   ** Description      Open and configure NFCC device and transport layer
+   **
+   ** Parameters       pConfig     - hardware information
+   **                  pLinkHandle - device handle
+   **
+   ** Returns          NFC status:
+   **                  NFCSTATUS_SUCCESS - open_and_configure operation success
+   **                  NFCSTATUS_INVALID_DEVICE - device open operation failure
+   **
+   ****************************************************************************/
+  virtual NFCSTATUS OpenAndConfigure(pphTmlNfc_Config_t pConfig,
+                                     void **pLinkHandle) = 0;
+
+  /*****************************************************************************
+   **
+   ** Function         Read
+   **
+   ** Description      Reads requested number of bytes from NFCC device into
+   **                 given buffer
+   **
+   ** Parameters       pDevHandle       - valid device handle
+   **                  pBuffer          - buffer for read data
+   **                  nNbBytesToRead   - number of bytes requested to be read
+   **
+   ** Returns          numRead   - number of successfully read bytes
+   **                  -1        - read operation failure
+   **
+   ****************************************************************************/
+  virtual int Read(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToRead) = 0;
+
+  /*****************************************************************************
+   **
+   ** Function         Write
+   **
+   ** Description      Writes requested number of bytes from given buffer into
+   **                  NFCC device
+   **
+   ** Parameters       pDevHandle       - valid device handle
+   **                  pBuffer          - buffer for read data
+   **                  nNbBytesToWrite  - number of bytes requested to be
+   *written
+   **
+   ** Returns          numWrote   - number of successfully written bytes
+   **                  -1         - write operation failure
+   **
+   *****************************************************************************/
+  virtual int Write(void *pDevHandle, uint8_t *pBuffer,
+                    int nNbBytesToWrite) = 0;
+
+  /*****************************************************************************
+   **
+   ** Function         Reset
+   **
+   ** Description      Reset NFCC device, using VEN pin
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  eType          - NfccResetType
+   **
+   ** Returns           0   - reset operation success
+   **                  -1   - reset operation failure
+   **
+   ****************************************************************************/
+  virtual int NfccReset(void *pDevHandle, NfccResetType eType);
+
+  /*****************************************************************************
+  **
+  ** Function         GetNfcState
+  **
+  ** Description      Get NFC state
+  **
+  ** Parameters       pDevHandle     - valid device handle
+  ** Returns           0   - unknown
+  **                   1   - FW DWL
+  **                   2   - NCI
+  **
+  *****************************************************************************/
+  virtual int GetNfcState(void *pDevHandle);
+  /*****************************************************************************
+   **
+   ** Function         EseReset
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  eType          - EseResetType
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  virtual int EseReset(void *pDevHandle, EseResetType eType);
+
+  /*****************************************************************************
+   **
+   ** Function         EseGetPower
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  level          - reset level
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  virtual int EseGetPower(void *pDevHandle, long level);
+
+  /*****************************************************************************
+   **
+   ** Function         GetPlatform
+   **
+   ** Description      Get platform interface type (i2c or i3c) for common mw
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **
+   ** Returns           0   - i2c
+   **                   1   - i3c
+   **
+   ****************************************************************************/
+  virtual int GetPlatform(void *pDevHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         EnableFwDnldMode
+   **
+   ** Description      updates the state to Download mode
+   **
+   ** Parameters       True/False
+   **
+   ** Returns          None
+   ****************************************************************************/
+  virtual void EnableFwDnldMode(bool mode);
+
+  /*****************************************************************************
+   **
+   ** Function         IsFwDnldModeEnabled
+   **
+   ** Description      Returns the current mode
+   **
+   ** Parameters       none
+   **
+   ** Returns          Current mode download/NCI
+   ****************************************************************************/
+  virtual bool_t IsFwDnldModeEnabled(void);
+
+  /*******************************************************************************
+   **
+   ** Function         GetIrqState
+   **
+   ** Description      Get state of IRQ GPIO
+   **
+   ** Parameters       pDevHandle - valid device handle
+   **
+   ** Returns          The state of IRQ line i.e. +ve if read is pending else
+   *Zer0.
+   **                  In the case of IOCTL error, it returns -ve value.
+   **
+   *******************************************************************************/
+  virtual int GetIrqState(void *pDevHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         ~NfccTransport
+   **
+   ** Description      TransportLayer destructor
+   **
+   ** Parameters       none
+   **
+   ** Returns          None
+   ****************************************************************************/
+  virtual ~NfccTransport(){};
+};
diff --git a/pn8x/halimpl/utils/NxpNfcCapability.cpp b/pn8x/halimpl/utils/NxpNfcCapability.cpp
index 720ed08..2601f3c 100644
--- a/pn8x/halimpl/utils/NxpNfcCapability.cpp
+++ b/pn8x/halimpl/utils/NxpNfcCapability.cpp
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015,2021 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -57,7 +57,11 @@ tNFC_chipType capability::getChipType(uint8_t* msg, uint16_t msg_len) {
         case 0x40:  // PN553 A0
         case 0x41:  // PN553 B0
           // NQ310
-          chipType = pn553;
+          if (msg[offsetFwVersion] == 0x12) {
+            chipType = pn557;
+          } else{
+            chipType = pn553;
+          }
           break;
 
         case 0x50:  // PN553 A0 + P73
@@ -72,9 +76,12 @@ tNFC_chipType capability::getChipType(uint8_t* msg, uint16_t msg_len) {
           }
           break;
 
-        case 0x61:
+        case 0x61:// PN7160 (no ECP support)
+        case 0x71:// PN7161 (ECP support)
           if (msg[offsetFwVersion] == 0x11) {
             chipType = pn553;
+          } else if (msg[offsetFwVersion] == 0x12) {
+            chipType = pn557;
           }
           break;
 
@@ -89,6 +96,7 @@ tNFC_chipType capability::getChipType(uint8_t* msg, uint16_t msg_len) {
 
         case 0x28:
         case 0x48:  // NQ210
+        case 0x88:
           chipType = pn548C2;
           break;
 
diff --git a/pn8x/halimpl/utils/phNxpConfig.h b/pn8x/halimpl/utils/phNxpConfig.h
index cc39097..30a2e7c 100755
--- a/pn8x/halimpl/utils/phNxpConfig.h
+++ b/pn8x/halimpl/utils/phNxpConfig.h
@@ -20,7 +20,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2013-2014 NXP Semiconductors
+ *  Copyright (C) 2013-2014,2021 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -107,6 +107,12 @@ int updateNxpConfigTimestamp();
 #define NAME_OFFHOST_ROUTE_ESE "OFFHOST_ROUTE_ESE"
 #define NAME_OFFHOST_ROUTE_UICC "OFFHOST_ROUTE_UICC"
 #define NAME_DEFAULT_ISODEP_ROUTE "DEFAULT_ISODEP_ROUTE"
+#if(NXP_EXTNS == TRUE)
+#define NAME_NXP_TRANSPORT "NXP_TRANSPORT"
+#define NAME_NXP_AGC_DEBUG_ENABLE "NXP_AGC_DEBUG_ENABLE"
+#define NAME_NXP_T4T_NFCEE_ENABLE "NXP_T4T_NFCEE_ENABLE"
+#define NAME_DEFAULT_T4TNFCEE_AID_POWER_STATE "DEFAULT_T4TNFCEE_AID_POWER_STATE"
+#endif
 
 /* default configuration */
 #define default_storage_location "/data/vendor/nfc"
diff --git a/pn8x/halimpl/utils/phNxpNciHal_utils.cc b/pn8x/halimpl/utils/phNxpNciHal_utils.cc
index 3ab9ba5..c3288cd 100644
--- a/pn8x/halimpl/utils/phNxpNciHal_utils.cc
+++ b/pn8x/halimpl/utils/phNxpNciHal_utils.cc
@@ -1,6 +1,6 @@
 /*
  *
- *  Copyright (C) 2013-2014 NXP Semiconductors
+ *  Copyright (C) 2013-2014,2021 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -23,6 +23,10 @@
 #include <phNxpNciHal.h>
 #include <phNxpNciHal_utils.h>
 
+extern uint8_t discovery_cmd[50];
+extern uint8_t discovery_cmd_len;
+extern uint8_t nfcdep_detected;
+
 /*********************** Link list functions **********************************/
 
 /*******************************************************************************
@@ -457,6 +461,16 @@ void phNxpNciHal_print_packet(const char* pString, const uint8_t* p_data,
 *******************************************************************************/
 
 void phNxpNciHal_emergency_recovery(void) {
+  if (nfcFL.chipType == pn548C2 && nfcdep_detected && discovery_cmd_len != 0) {
+    pthread_t pthread;
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+    if (pthread_create(&pthread, &attr, (void *(*)(void *))phNxpNciHal_core_reset_recovery,
+                       NULL) == 0) {
+      return;
+    }
+  }
   NXPLOG_NCIHAL_E("%s: abort()", __func__);
   abort();
 }
-- 
2.35.1


From 0e8db625112d51476f21b3aae8998e81a29aa02e Mon Sep 17 00:00:00 2001
From: nxf36764 <kumarnarayan.bhat@nxp.com>
Date: Tue, 2 Nov 2021 20:49:47 +0530
Subject: [PATCH 2/3] [artf902241][Bring up] Initial NFC bringup

Removing SNXXX related files from Android.bp
---
 Android.bp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Android.bp b/Android.bp
index 2c557a6..d3eb133 100644
--- a/Android.bp
+++ b/Android.bp
@@ -32,5 +32,5 @@ license {
 }
 
 subdirs = [
-    "snxxx","intf","pn8x",
+    "intf","pn8x",
 ]
-- 
2.35.1


From a90c6de555b4abd54353e10462b948b483919f4a Mon Sep 17 00:00:00 2001
From: nxf36764 <kumarnarayan.bhat@nxp.com>
Date: Thu, 24 Feb 2022 12:45:15 +0530
Subject: [PATCH 3/3] [artf944911][ANDROID 12]:Removing duplicated halimpl
 folder inside nfcandroid_nfc_hidlimpl repo for pn7160 platform

---
 halimpl/tml/NfccTransportFactory.cc       |  79 ----
 halimpl/tml/NfccTransportFactory.h        |  67 ---
 halimpl/tml/transport/NfccI2cTransport.cc | 533 ----------------------
 halimpl/tml/transport/NfccI2cTransport.h  | 266 -----------
 halimpl/tml/transport/NfccSpiTransport.cc | 533 ----------------------
 halimpl/tml/transport/NfccSpiTransport.h  | 266 -----------
 halimpl/tml/transport/NfccTransport.cc    |  50 --
 halimpl/tml/transport/NfccTransport.h     | 246 ----------
 8 files changed, 2040 deletions(-)
 delete mode 100644 halimpl/tml/NfccTransportFactory.cc
 delete mode 100644 halimpl/tml/NfccTransportFactory.h
 delete mode 100644 halimpl/tml/transport/NfccI2cTransport.cc
 delete mode 100644 halimpl/tml/transport/NfccI2cTransport.h
 delete mode 100644 halimpl/tml/transport/NfccSpiTransport.cc
 delete mode 100644 halimpl/tml/transport/NfccSpiTransport.h
 delete mode 100644 halimpl/tml/transport/NfccTransport.cc
 delete mode 100644 halimpl/tml/transport/NfccTransport.h

diff --git a/halimpl/tml/NfccTransportFactory.cc b/halimpl/tml/NfccTransportFactory.cc
deleted file mode 100644
index b626cf2..0000000
--- a/halimpl/tml/NfccTransportFactory.cc
+++ /dev/null
@@ -1,79 +0,0 @@
-/******************************************************************************
- *
- *  Copyright 2020-2021 NXP
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-#include <NfccI2cTransport.h>
-#include <NfccSpiTransport.h>
-#include <NfccTransportFactory.h>
-#include <phNxpLog.h>
-
-/*******************************************************************************
- **
- ** Function         NfccTransportFactory
- **
- ** Description      Constructor for transportFactory. This will be private to
- **                  support singleton
- **
- ** Parameters       none
- **
- ** Returns          none
- ******************************************************************************/
-NfccTransportFactory::NfccTransportFactory() {}
-
-/*******************************************************************************
-**
-** Function         getTransport
-**
-** Description      selects and returns transport channel based on the input
-**                  parameter
-**
-** Parameters       Required transport Type
-**
-** Returns          Selected transport channel
-******************************************************************************/
-NfccTransportFactory &NfccTransportFactory::getInstance() {
-  static NfccTransportFactory mTransprtFactoryInstance;
-  return mTransprtFactoryInstance;
-}
-
-/*******************************************************************************
-**
-** Function         getTransport
-**
-** Description      selects and returns transport channel based on the input
-**                  parameter
-**
-** Parameters       Required transport Type
-**
-** Returns          Selected transport channel
-******************************************************************************/
-spTransport NfccTransportFactory::getTransport(transportIntf transportType) {
-  NXPLOG_TML_D("%s Requested transportType: %d\n", __func__, transportType);
-  spTransport mspTransportInterface;
-  switch (transportType) {
-    case I2C:
-    case UNKNOWN:
-      mspTransportInterface = std::make_shared<NfccI2cTransport>();
-      break;
-    case SPI:
-      mspTransportInterface = std::make_shared<NfccSpiTransport>();
-    default:
-      mspTransportInterface = std::make_shared<NfccI2cTransport>();
-      break;
-  }
-  return mspTransportInterface;
-}
diff --git a/halimpl/tml/NfccTransportFactory.h b/halimpl/tml/NfccTransportFactory.h
deleted file mode 100644
index 34cec36..0000000
--- a/halimpl/tml/NfccTransportFactory.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/******************************************************************************
- *
- *  Copyright 2020-2021 NXP
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-#pragma once
-#include <NfccTransport.h>
-#include <memory>
-
-#define transportFactory (NfccTransportFactory::getInstance())
-typedef std::shared_ptr<NfccTransport> spTransport;
-enum transportIntf { I2C, SPI, UNKNOWN };
-
-extern spTransport gpTransportObj;
-class NfccTransportFactory {
-  /*****************************************************************************
-   **
-   ** Function         NfccTransportFactory
-   **
-   ** Description      Constructor for transportFactory. This will be private to
-   **                  support singleton
-   **
-   ** Parameters       none
-   **
-   ** Returns          none
-   ****************************************************************************/
-  NfccTransportFactory();
-
-public:
-  /*****************************************************************************
-   **
-   ** Function         getInstance
-   **
-   ** Description      returns the static instance of TransportFactory
-   **
-   ** Parameters       none
-   **
-   ** Returns          TransportFactory instance
-   ****************************************************************************/
-  static NfccTransportFactory &getInstance();
-
-  /*****************************************************************************
-  **
-  ** Function         getTransport
-  **
-  ** Description      selects and returns transport channel based on the input
-  **                  parameter
-  **
-  ** Parameters       Required transport Type
-  **
-  ** Returns          Selected transport channel
-  ****************************************************************************/
-  spTransport getTransport(transportIntf transportType);
-};
diff --git a/halimpl/tml/transport/NfccI2cTransport.cc b/halimpl/tml/transport/NfccI2cTransport.cc
deleted file mode 100644
index cc76f11..0000000
--- a/halimpl/tml/transport/NfccI2cTransport.cc
+++ /dev/null
@@ -1,533 +0,0 @@
-/******************************************************************************
- *  Copyright 2020-2021 NXP
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-#include <errno.h>
-#include <fcntl.h>
-#include <hardware/nfc.h>
-#include <stdlib.h>
-#include <sys/ioctl.h>
-#include <sys/select.h>
-#include <termios.h>
-#include <unistd.h>
-
-#include "phNxpNciHal_utils.h"
-#include <NfccI2cTransport.h>
-#include <phNfcStatus.h>
-#include <phNxpLog.h>
-#include <string.h>
-
-#define CRC_LEN 2
-#define NORMAL_MODE_HEADER_LEN 3
-#define FW_DNLD_HEADER_LEN 2
-#define FW_DNLD_LEN_OFFSET 1
-#define NORMAL_MODE_LEN_OFFSET 2
-#define FRAGMENTSIZE_MAX PHNFC_I2C_FRAGMENT_SIZE
-extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
-extern phTmlNfc_Context_t *gpphTmlNfc_Context;
-/*******************************************************************************
-**
-** Function         Close
-**
-** Description      Closes NFCC device
-**
-** Parameters       pDevHandle - device handle
-**
-** Returns          None
-**
-*******************************************************************************/
-void NfccI2cTransport::Close(void *pDevHandle) {
-  if (NULL != pDevHandle) {
-    close((intptr_t)pDevHandle);
-  }
-  sem_destroy(&mTxRxSemaphore);
-  return;
-}
-
-/*******************************************************************************
-**
-** Function         OpenAndConfigure
-**
-** Description      Open and configure NFCC device
-**
-** Parameters       pConfig     - hardware information
-**                  pLinkHandle - device handle
-**
-** Returns          NFC status:
-**                  NFCSTATUS_SUCCESS - open_and_configure operation success
-**                  NFCSTATUS_INVALID_DEVICE - device open operation failure
-**
-*******************************************************************************/
-NFCSTATUS NfccI2cTransport::OpenAndConfigure(pphTmlNfc_Config_t pConfig,
-                                             void **pLinkHandle) {
-  int nHandle;
-
-  NXPLOG_TML_D("%s Opening port=%s\n", __func__, pConfig->pDevName);
-  /* open port */
-  nHandle = open((const char *)pConfig->pDevName, O_RDWR);
-  if (nHandle < 0) {
-    NXPLOG_TML_E("_i2c_open() Failed: retval %x", nHandle);
-    *pLinkHandle = NULL;
-    return NFCSTATUS_INVALID_DEVICE;
-  }
-
-  *pLinkHandle = (void *)((intptr_t)nHandle);
-  if (0 != sem_init(&mTxRxSemaphore, 0, 1)) {
-    NXPLOG_TML_E("%s Failed: reason sem_init : retval %x", __func__, nHandle);
-  }
-  /*Reset PN54X*/
-  NfccReset((void *)((intptr_t)nHandle), MODE_POWER_OFF);
-  usleep(10 * 1000);
-  NfccReset((void *)((intptr_t)nHandle), MODE_POWER_ON);
-
-  return NFCSTATUS_SUCCESS;
-}
-
-/*******************************************************************************
-**
-** Function         Flushdata
-**
-** Description      Reads payload of FW rsp from NFCC device into given buffer
-**
-** Parameters       pDevHandle - valid device handle
-**                  pBuffer    - buffer for read data
-**                  numRead    - number of bytes read by calling function
-**
-** Returns          always returns -1
-**
-*******************************************************************************/
-int NfccI2cTransport::Flushdata(void* pDevHandle, uint8_t* pBuffer, int numRead) {
-  int retRead = 0;
-  uint16_t totalBtyesToRead = pBuffer[FW_DNLD_LEN_OFFSET] + FW_DNLD_HEADER_LEN + CRC_LEN;
-  /* we shall read totalBtyesToRead-1 as one byte is already read by calling function*/
-  retRead = read((intptr_t)pDevHandle, pBuffer + numRead, totalBtyesToRead - 1);
-  if (retRead > 0) {
-    numRead += retRead;
-    phNxpNciHal_print_packet("RECV", pBuffer, numRead);
-  } else if (retRead == 0) {
-    NXPLOG_TML_E("%s _i2c_read() [pyld] EOF", __func__);
-  } else {
-    if (bFwDnldFlag == false) {
-      NXPLOG_TML_D("%s _i2c_read() [hdr] received", __func__);
-      phNxpNciHal_print_packet("RECV", pBuffer - numRead, NORMAL_MODE_HEADER_LEN);
-    }
-    NXPLOG_TML_E("%s _i2c_read() [pyld] errno : %x", __func__, errno);
-  }
-  SemPost();
-  return -1;
-}
-
-/*******************************************************************************
-**
-** Function         Read
-**
-** Description      Reads requested number of bytes from NFCC device into given
-**                  buffer
-**
-** Parameters       pDevHandle       - valid device handle
-**                  pBuffer          - buffer for read data
-**                  nNbBytesToRead   - number of bytes requested to be read
-**
-** Returns          numRead   - number of successfully read bytes
-**                  -1        - read operation failure
-**
-*******************************************************************************/
-int NfccI2cTransport::Read(void *pDevHandle, uint8_t *pBuffer,
-                           int nNbBytesToRead) {
-  int ret_Read;
-  int ret_Select;
-  int numRead = 0;
-  struct timeval tv;
-  fd_set rfds;
-  uint16_t totalBtyesToRead = 0;
-
-  UNUSED(nNbBytesToRead);
-  if (NULL == pDevHandle) {
-    return -1;
-  }
-
-  if (bFwDnldFlag == false) {
-    totalBtyesToRead = NORMAL_MODE_HEADER_LEN;
-  } else {
-    totalBtyesToRead = FW_DNLD_HEADER_LEN;
-  }
-
-  /* Read with 2 second timeout, so that the read thread can be aborted
-     when the NFCC does not respond and we need to switch to FW download
-     mode. This should be done via a control socket instead. */
-  FD_ZERO(&rfds);
-  FD_SET((intptr_t)pDevHandle, &rfds);
-  tv.tv_sec = 2;
-  tv.tv_usec = 1;
-
-  ret_Select =
-      select((int)((intptr_t)pDevHandle + (int)1), &rfds, NULL, NULL, &tv);
-  if (ret_Select < 0) {
-    NXPLOG_TML_D("%s errno : %x", __func__, errno);
-    return -1;
-  } else if (ret_Select == 0) {
-    NXPLOG_TML_D("%s Timeout", __func__);
-    return -1;
-  } else {
-    ret_Read = read((intptr_t)pDevHandle, pBuffer, totalBtyesToRead - numRead);
-    if (ret_Read > 0 && !(pBuffer[0] == 0xFF && pBuffer[1] == 0xFF)) {
-      SemTimedWait();
-      numRead += ret_Read;
-    } else if (ret_Read == 0) {
-      NXPLOG_TML_E("%s [hdr]EOF", __func__);
-      return -1;
-    } else {
-      NXPLOG_TML_E("%s [hdr] errno : %x", __func__, errno);
-      NXPLOG_TML_E(" %s pBuffer[0] = %x pBuffer[1]= %x", __func__, pBuffer[0],
-                   pBuffer[1]);
-      return -1;
-    }
-
-    if (bFwDnldFlag == false) {
-      totalBtyesToRead = NORMAL_MODE_HEADER_LEN;
-#if(NXP_EXTNS == TRUE)
-      if (gpphTmlNfc_Context->tReadInfo.pContext != NULL &&
-              !memcmp(gpphTmlNfc_Context->tReadInfo.pContext, "MinOpen", 0x07) &&
-              !pBuffer[0] && pBuffer[1]) {
-        return Flushdata(pDevHandle, pBuffer, numRead);
-      }
-#endif
-    } else {
-      totalBtyesToRead = FW_DNLD_HEADER_LEN;
-    }
-
-    if (numRead < totalBtyesToRead) {
-      ret_Read = read((intptr_t)pDevHandle, (pBuffer + numRead), totalBtyesToRead - numRead);
-
-      if (ret_Read != totalBtyesToRead - numRead) {
-        SemPost();
-        NXPLOG_TML_E("%s [hdr] errno : %x", __func__, errno);
-        return -1;
-      } else {
-        numRead += ret_Read;
-      }
-    }
-    if (bFwDnldFlag == true) {
-      totalBtyesToRead = pBuffer[FW_DNLD_LEN_OFFSET] + FW_DNLD_HEADER_LEN + CRC_LEN;
-    } else {
-      totalBtyesToRead = pBuffer[NORMAL_MODE_LEN_OFFSET] + NORMAL_MODE_HEADER_LEN;
-    }
-    if ((totalBtyesToRead - numRead) != 0) {
-      ret_Read = read((intptr_t)pDevHandle, (pBuffer + numRead), totalBtyesToRead - numRead);
-      if (ret_Read > 0) {
-        numRead += ret_Read;
-      } else if (ret_Read == 0) {
-        SemPost();
-        NXPLOG_TML_E("%s [pyld] EOF", __func__);
-        return -1;
-      } else {
-        if (bFwDnldFlag == false) {
-          NXPLOG_TML_D("_i2c_read() [hdr] received");
-          phNxpNciHal_print_packet("RECV", pBuffer, NORMAL_MODE_HEADER_LEN);
-        }
-        SemPost();
-        NXPLOG_TML_E("%s [pyld] errno : %x", __func__, errno);
-        return -1;
-      }
-    } else {
-      NXPLOG_TML_E("%s _>>>>> Empty packet recieved !!", __func__);
-    }
-  }
-  SemPost();
-  return numRead;
-}
-
-/*******************************************************************************
-**
-** Function         Write
-**
-** Description      Writes requested number of bytes from given buffer into
-**                  NFCC device
-**
-** Parameters       pDevHandle       - valid device handle
-**                  pBuffer          - buffer for read data
-**                  nNbBytesToWrite  - number of bytes requested to be written
-**
-** Returns          numWrote   - number of successfully written bytes
-**                  -1         - write operation failure
-**
-*******************************************************************************/
-int NfccI2cTransport::Write(void *pDevHandle, uint8_t *pBuffer,
-                            int nNbBytesToWrite) {
-  int ret;
-  int numWrote = 0;
-  int numBytes = nNbBytesToWrite;
-  if (NULL == pDevHandle) {
-    return -1;
-  }
-  if (fragmentation_enabled == I2C_FRAGMENATATION_DISABLED &&
-      nNbBytesToWrite > FRAGMENTSIZE_MAX) {
-    NXPLOG_TML_D(
-        "%s data larger than maximum I2C  size,enable I2C fragmentation",
-        __func__);
-    return -1;
-  }
-  while (numWrote < nNbBytesToWrite) {
-    if (fragmentation_enabled == I2C_FRAGMENTATION_ENABLED &&
-        nNbBytesToWrite > FRAGMENTSIZE_MAX) {
-      if (nNbBytesToWrite - numWrote > FRAGMENTSIZE_MAX) {
-        numBytes = numWrote + FRAGMENTSIZE_MAX;
-      } else {
-        numBytes = nNbBytesToWrite;
-      }
-    }
-    SemTimedWait();
-    ret = write((intptr_t)pDevHandle, pBuffer + numWrote, numBytes - numWrote);
-    SemPost();
-    if (ret > 0) {
-      numWrote += ret;
-      if (fragmentation_enabled == I2C_FRAGMENTATION_ENABLED &&
-          numWrote < nNbBytesToWrite) {
-        usleep(500);
-      }
-    } else if (ret == 0) {
-      NXPLOG_TML_D("%s EOF", __func__);
-      return -1;
-    } else {
-      NXPLOG_TML_D("%s errno : %x", __func__, errno);
-      if (errno == EINTR || errno == EAGAIN) {
-        continue;
-      }
-      return -1;
-    }
-  }
-
-  return numWrote;
-}
-
-/*******************************************************************************
-**
-** Function         Reset
-**
-** Description      Reset NFCC device, using VEN pin
-**
-** Parameters       pDevHandle     - valid device handle
-**                  eType          - reset level
-**
-** Returns           0   - reset operation success
-**                  -1   - reset operation failure
-**
-*******************************************************************************/
-int NfccI2cTransport::NfccReset(void *pDevHandle, NfccResetType eType) {
-  int ret = -1;
-  NXPLOG_TML_D("%s, VEN eType %ld", __func__, eType);
-
-  if (NULL == pDevHandle) {
-    return -1;
-  }
-
-  ret = ioctl((intptr_t)pDevHandle, NFC_SET_PWR, eType);
-  if (ret < 0) {
-    NXPLOG_TML_E("%s :failed errno = 0x%x", __func__, errno);
-  }
-  if ((eType != MODE_FW_DWNLD_WITH_VEN && eType != MODE_FW_DWND_HIGH) &&
-      ret == 0) {
-    EnableFwDnldMode(false);
-  }
-  if ((((eType == MODE_FW_DWNLD_WITH_VEN) || (eType == MODE_FW_DWND_HIGH)) && (ret == 0))) {
-    EnableFwDnldMode(true);
-  }
-
-  return ret;
-}
-
-/*******************************************************************************
-**
-** Function         EseReset
-**
-** Description      Request NFCC to reset the eSE
-**
-** Parameters       pDevHandle     - valid device handle
-**                  eType          - EseResetType
-**
-** Returns           0   - reset operation success
-**                  else - reset operation failure
-**
-*******************************************************************************/
-int NfccI2cTransport::EseReset(void *pDevHandle, EseResetType eType) {
-  int ret = -1;
-  NXPLOG_TML_D("%s, eType %ld", __func__, eType);
-
-  if (NULL == pDevHandle) {
-    return -1;
-  }
-  ret = ioctl((intptr_t)pDevHandle, ESE_SET_PWR, eType);
-  if (ret < 0) {
-    NXPLOG_TML_E("%s :failed errno = 0x%x", __func__, errno);
-  }
-  return ret;
-}
-
-/*******************************************************************************
-**
-** Function         EseGetPower
-**
-** Description      Request NFCC to reset the eSE
-**
-** Parameters       pDevHandle     - valid device handle
-**                  level          - reset level
-**
-** Returns           0   - reset operation success
-**                  else - reset operation failure
-**
-*******************************************************************************/
-int NfccI2cTransport::EseGetPower(void *pDevHandle, long level) {
-  return ioctl((intptr_t)pDevHandle, ESE_GET_PWR, level);
-}
-
-/*******************************************************************************
-**
-** Function         GetPlatform
-**
-** Description      Get platform interface type (i2c or i3c) for common mw
-**
-** Parameters       pDevHandle     - valid device handle
-**
-** Returns           0   - i2c
-**                   1   - i3c
-**
-*******************************************************************************/
-int NfccI2cTransport::GetPlatform(void *pDevHandle) {
-  int ret = -1;
-  NXPLOG_TML_D("%s ", __func__);
-  if (NULL == pDevHandle) {
-    return -1;
-  }
-  ret = ioctl((intptr_t)pDevHandle, NFC_GET_PLATFORM_TYPE);
-  NXPLOG_TML_D("%s :platform = %d", __func__, ret);
-  return ret;
-}
-
-/*******************************************************************************
-**
-** Function         GetNfcState
-**
-** Description      Get NFC state
-**
-** Parameters       pDevHandle     - valid device handle
-** Returns           0   - unknown
-**                   1   - FW DWL
-**                   2 	 - NCI
-**
-*******************************************************************************/
-int NfccI2cTransport::GetNfcState(void *pDevHandle) {
-  int ret = NFC_STATE_UNKNOWN;
-  NXPLOG_TML_D("%s ", __func__);
-  if (NULL == pDevHandle) {
-    return ret;
-  }
-  ret = ioctl((intptr_t)pDevHandle, NFC_GET_NFC_STATE);
-  NXPLOG_TML_D("%s :nfc state = %d", __func__, ret);
-  return ret;
-}
-/*******************************************************************************
-**
-** Function         EnableFwDnldMode
-**
-** Description      updates the state to Download mode
-**
-** Parameters       True/False
-**
-** Returns          None
-*******************************************************************************/
-void NfccI2cTransport::EnableFwDnldMode(bool mode) { bFwDnldFlag = mode; }
-
-/*******************************************************************************
-**
-** Function         IsFwDnldModeEnabled
-**
-** Description      Returns the current mode
-**
-** Parameters       none
-**
-** Returns           Current mode download/NCI
-*******************************************************************************/
-bool_t NfccI2cTransport::IsFwDnldModeEnabled(void) { return bFwDnldFlag; }
-
-/*******************************************************************************
-**
-** Function         SemPost
-**
-** Description      sem_post 2c_read / write
-**
-** Parameters       none
-**
-** Returns          none
-*******************************************************************************/
-void NfccI2cTransport::SemPost() {
-  int sem_val = 0;
-  sem_getvalue(&mTxRxSemaphore, &sem_val);
-  if (sem_val == 0) {
-    sem_post(&mTxRxSemaphore);
-  }
-}
-
-/*******************************************************************************
-**
-** Function         SemTimedWait
-**
-** Description      Timed sem_wait for avoiding i2c_read & write overlap
-**
-** Parameters       none
-**
-** Returns          Sem_wait return status
-*******************************************************************************/
-int NfccI2cTransport::SemTimedWait() {
-  NFCSTATUS status = NFCSTATUS_FAILED;
-  long sem_timedout = 500 * 1000 * 1000;
-  int s = 0;
-  struct timespec ts;
-  clock_gettime(CLOCK_REALTIME, &ts);
-  ts.tv_sec += 0;
-  ts.tv_nsec += sem_timedout;
-  while ((s = sem_timedwait(&mTxRxSemaphore, &ts)) == -1 && errno == EINTR) {
-    continue; /* Restart if interrupted by handler */
-  }
-  if (s != -1) {
-    status = NFCSTATUS_SUCCESS;
-  } else if (errno == ETIMEDOUT && s == -1) {
-    NXPLOG_TML_E("%s :timed out errno = 0x%x", __func__, errno);
-  }
-  return status;
-}
-
-/*******************************************************************************
-**
-** Function         GetIrqState
-**
-** Description      Get state of IRQ GPIO
-**
-** Parameters       pDevHandle - valid device handle
-**
-** Returns          The state of IRQ line i.e. +ve if read is pending else Zer0.
-**                  In the case of IOCTL error, it returns -ve value.
-**
-*******************************************************************************/
-int NfccI2cTransport::GetIrqState(void *pDevHandle) {
-  int ret = -1;
-
-  NXPLOG_TML_D("%s Enter",__func__);
-  if (NULL != pDevHandle) {
-    ret = ioctl((intptr_t)pDevHandle, NFC_GET_IRQ_STATE);
-  }
-  NXPLOG_TML_D("%s exit: state = %d", __func__, ret);
-  return ret;
-}
diff --git a/halimpl/tml/transport/NfccI2cTransport.h b/halimpl/tml/transport/NfccI2cTransport.h
deleted file mode 100644
index ae684b8..0000000
--- a/halimpl/tml/transport/NfccI2cTransport.h
+++ /dev/null
@@ -1,266 +0,0 @@
-/******************************************************************************
- *
- *  Copyright 2020-2021 NXP
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-#pragma once
-#include <NfccTransport.h>
-
-#define NFC_MAGIC 0xE9
-/*
- * NFCC power control via ioctl
- * NFC_SET_PWR(0): power off
- * NFC_SET_PWR(1): power on
- * NFC_SET_PWR(2): reset and power on with firmware download enabled
- */
-#define NFC_SET_PWR _IOW(NFC_MAGIC, 0x01, long)
-/*
- * 1. SPI Request NFCC to enable ESE power, only in param
- *   Only for SPI
- *   level 1 = Enable power
- *   level 0 = Disable power
- * 2. NFC Request the eSE cold reset, only with MODE_ESE_COLD_RESET
- */
-#define ESE_SET_PWR _IOW(NFC_MAGIC, 0x02, long)
-
-/*
- * SPI or DWP can call this ioctl to get the current
- * power state of ESE
- */
-#define ESE_GET_PWR _IOR(NFC_MAGIC, 0x03, long)
-
-/*
- * get platform interface type(i2c or i3c) for common MW
- * return 0 - i2c, 1 - i3c
- */
-#define NFC_GET_PLATFORM_TYPE _IO(NFC_MAGIC, 0x04)
-/*
- * get boot state
- * return unknown, fw dwl, fw teared, nci
- */
-#define NFC_GET_NFC_STATE _IO(NFC_MAGIC, 0x05)
-
-/* NFC HAL can call this ioctl to get the current IRQ state */
-#define NFC_GET_IRQ_STATE _IO(NFC_MAGIC, 0x06)
-
-extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
-
-class NfccI2cTransport : public NfccTransport {
- private:
-  bool_t bFwDnldFlag = false;
-  sem_t mTxRxSemaphore;
-  /*****************************************************************************
-   **
-   ** Function         SemTimedWait
-   **
-   ** Description      Timed sem_wait for avoiding i2c_read & write overlap
-   **
-   ** Parameters       none
-   **
-   ** Returns          Sem_wait return status
-   ****************************************************************************/
-  int SemTimedWait();
-
-  /*****************************************************************************
-   **
-   ** Function         SemPost
-   **
-   ** Description      sem_post 2c_read / write
-   **
-   ** Parameters       none
-   **
-   ** Returns          none
-   ****************************************************************************/
-  void SemPost();
-
-  int Flushdata(void* pDevHandle, uint8_t* pBuffer, int numRead);
-
- public:
-  /*****************************************************************************
-  **
-  ** Function         Close
-  **
-  ** Description      Closes NFCC device
-  **
-  ** Parameters       pDevHandle - device handle
-  **
-  ** Returns          None
-  **
-  *****************************************************************************/
-  void Close(void *pDevHandle);
-
-  /*****************************************************************************
-   **
-   ** Function         OpenAndConfigure
-   **
-   ** Description      Open and configure NFCC device
-   **
-   ** Parameters       pConfig     - hardware information
-   **                  pLinkHandle - device handle
-   **
-   ** Returns          NFC status:
-   **                  NFCSTATUS_SUCCESS - open_and_configure operation success
-   **                  NFCSTATUS_INVALID_DEVICE - device open operation failure
-   **
-   ****************************************************************************/
-  NFCSTATUS OpenAndConfigure(pphTmlNfc_Config_t pConfig, void **pLinkHandle);
-
-  /*****************************************************************************
-   **
-   ** Function         Read
-   **
-   ** Description      Reads requested number of bytes from NFCC device into
-   *given
-   **                  buffer
-   **
-   ** Parameters       pDevHandle       - valid device handle
-   **                  pBuffer          - buffer for read data
-   **                  nNbBytesToRead   - number of bytes requested to be read
-   **
-   ** Returns          numRead   - number of successfully read bytes
-   **                  -1        - read operation failure
-   **
-   ****************************************************************************/
-  int Read(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToRead);
-
-  /*****************************************************************************
-  **
-  ** Function         Write
-  **
-  ** Description      Writes requested number of bytes from given buffer into
-  **                  NFCC device
-  **
-  ** Parameters       pDevHandle       - valid device handle
-  **                  pBuffer          - buffer for read data
-  **                  nNbBytesToWrite  - number of bytes requested to be written
-  **
-  ** Returns          numWrote   - number of successfully written bytes
-  **                  -1         - write operation failure
-  **
-  *****************************************************************************/
-  int Write(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToWrite);
-
-  /*****************************************************************************
-   **
-   ** Function         Reset
-   **
-   ** Description      Reset NFCC device, using VEN pin
-   **
-   ** Parameters       pDevHandle     - valid device handle
-   **                  level          - reset level
-   **
-   ** Returns           0   - reset operation success
-   **                  -1   - reset operation failure
-   **
-   ****************************************************************************/
-  int NfccReset(void *pDevHandle, NfccResetType eType);
-
-  /*****************************************************************************
-   **
-   ** Function         EseReset
-   **
-   ** Description      Request NFCC to reset the eSE
-   **
-   ** Parameters       pDevHandle     - valid device handle
-   **                  eType          - EseResetType
-   **
-   ** Returns           0   - reset operation success
-   **                  else - reset operation failure
-   **
-   ****************************************************************************/
-  int EseReset(void *pDevHandle, EseResetType eType);
-
-  /*****************************************************************************
-   **
-   ** Function         EseGetPower
-   **
-   ** Description      Request NFCC to reset the eSE
-   **
-   ** Parameters       pDevHandle     - valid device handle
-   **                  level          - reset level
-   **
-   ** Returns           0   - reset operation success
-   **                  else - reset operation failure
-   **
-   ****************************************************************************/
-  int EseGetPower(void *pDevHandle, long level);
-
-  /*****************************************************************************
-   **
-   ** Function         GetPlatform
-   **
-   ** Description      Get platform interface type (i2c or i3c) for common mw
-   **
-   ** Parameters       pDevHandle     - valid device handle
-   **
-   ** Returns           0   - i2c
-   **                   1   - i3c
-   **
-   ****************************************************************************/
-  int GetPlatform(void *pDevHandle);
-
-  /*****************************************************************************
-  **
-  ** Function         GetNfcState
-  **
-  ** Description      Get Nfc state
-  **
-  ** Parameters       pDevHandle     - valid device handle
-  ** Returns           0   - unknown
-  **                   1   - FW DWL
-  **                   2   - NCI
-  **
-  *****************************************************************************/
-  int GetNfcState(void *pDevHandle);
-
-  /*****************************************************************************
-   **
-   ** Function         EnableFwDnldMode
-   **
-   ** Description      updates the state to Download mode
-   **
-   ** Parameters       True/False
-   **
-   ** Returns          None
-   ****************************************************************************/
-  void EnableFwDnldMode(bool mode);
-
-  /*****************************************************************************
-   **
-   ** Function         IsFwDnldModeEnabled
-   **
-   ** Description      Returns the current mode
-   **
-   ** Parameters       none
-   **
-   ** Returns           Current mode download/NCI
-   ****************************************************************************/
-  bool_t IsFwDnldModeEnabled(void);
-
-  /*******************************************************************************
-   **
-   ** Function         GetIrqState
-   **
-   ** Description      Get state of IRQ GPIO
-   **
-   ** Parameters       pDevHandle - valid device handle
-   **
-   ** Returns          The state of IRQ line i.e. +ve if read is pending else Zer0.
-   **                  In the case of IOCTL error, it returns -ve value.
-   **
-   *******************************************************************************/
-  int GetIrqState(void *pDevHandle);
-};
diff --git a/halimpl/tml/transport/NfccSpiTransport.cc b/halimpl/tml/transport/NfccSpiTransport.cc
deleted file mode 100644
index 82cf97f..0000000
--- a/halimpl/tml/transport/NfccSpiTransport.cc
+++ /dev/null
@@ -1,533 +0,0 @@
-/******************************************************************************
- *  Copyright 2020-2021 NXP
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-#include <errno.h>
-#include <fcntl.h>
-#include <hardware/nfc.h>
-#include <stdlib.h>
-#include <sys/ioctl.h>
-#include <sys/select.h>
-#include <termios.h>
-#include <unistd.h>
-
-#include "phNxpNciHal_utils.h"
-#include <NfccSpiTransport.h>
-#include <phNfcStatus.h>
-#include <phNxpLog.h>
-#include <string.h>
-
-#define CRC_LEN 2
-#define NORMAL_MODE_HEADER_LEN 3
-#define FW_DNLD_HEADER_LEN 2
-#define FW_DNLD_LEN_OFFSET 1
-#define NORMAL_MODE_LEN_OFFSET 2
-#define FRAGMENTSIZE_MAX PHNFC_I2C_FRAGMENT_SIZE
-extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
-extern phTmlNfc_Context_t *gpphTmlNfc_Context;
-/*******************************************************************************
-**
-** Function         Close
-**
-** Description      Closes NFCC device
-**
-** Parameters       pDevHandle - device handle
-**
-** Returns          None
-**
-*******************************************************************************/
-void NfccSpiTransport::Close(void *pDevHandle) {
-  if (NULL != pDevHandle) {
-    close((intptr_t)pDevHandle);
-  }
-  sem_destroy(&mTxRxSemaphore);
-  return;
-}
-
-/*******************************************************************************
-**
-** Function         OpenAndConfigure
-**
-** Description      Open and configure NFCC device
-**
-** Parameters       pConfig     - hardware information
-**                  pLinkHandle - device handle
-**
-** Returns          NFC status:
-**                  NFCSTATUS_SUCCESS - open_and_configure operation success
-**                  NFCSTATUS_INVALID_DEVICE - device open operation failure
-**
-*******************************************************************************/
-NFCSTATUS NfccSpiTransport::OpenAndConfigure(pphTmlNfc_Config_t pConfig,
-                                             void **pLinkHandle) {
-  int nHandle;
-
-  NXPLOG_TML_D("%s Opening port=%s\n", __func__, pConfig->pDevName);
-  /* open port */
-  nHandle = open((const char *)pConfig->pDevName, O_RDWR);
-  if (nHandle < 0) {
-    NXPLOG_TML_E("_i2c_open() Failed: retval %x", nHandle);
-    *pLinkHandle = NULL;
-    return NFCSTATUS_INVALID_DEVICE;
-  }
-
-  *pLinkHandle = (void *)((intptr_t)nHandle);
-  if (0 != sem_init(&mTxRxSemaphore, 0, 1)) {
-    NXPLOG_TML_E("%s Failed: reason sem_init : retval %x", __func__, nHandle);
-  }
-  /*Reset PN54X*/
-  NfccReset((void *)((intptr_t)nHandle), MODE_POWER_OFF);
-  usleep(10 * 1000);
-  NfccReset((void *)((intptr_t)nHandle), MODE_POWER_ON);
-
-  return NFCSTATUS_SUCCESS;
-}
-
-/*******************************************************************************
-**
-** Function         Flushdata
-**
-** Description      Reads payload of FW rsp from NFCC device into given buffer
-**
-** Parameters       pDevHandle - valid device handle
-**                  pBuffer    - buffer for read data
-**                  numRead    - number of bytes read by calling function
-**
-** Returns          always returns -1
-**
-*******************************************************************************/
-int NfccSpiTransport::Flushdata(void* pDevHandle, uint8_t* pBuffer, int numRead) {
-  int retRead = 0;
-  uint16_t totalBtyesToRead = pBuffer[FW_DNLD_LEN_OFFSET] + FW_DNLD_HEADER_LEN + CRC_LEN;
-  /* we shall read totalBtyesToRead-1 as one byte is already read by calling function*/
-  retRead = read((intptr_t)pDevHandle, pBuffer + numRead, totalBtyesToRead - 1);
-  if (retRead > 0) {
-    numRead += retRead;
-    phNxpNciHal_print_packet("RECV", pBuffer, numRead);
-  } else if (retRead == 0) {
-    NXPLOG_TML_E("%s _i2c_read() [pyld] EOF", __func__);
-  } else {
-    if (bFwDnldFlag == false) {
-      NXPLOG_TML_D("%s _i2c_read() [hdr] received", __func__);
-      phNxpNciHal_print_packet("RECV", pBuffer - numRead, NORMAL_MODE_HEADER_LEN);
-    }
-    NXPLOG_TML_E("%s _i2c_read() [pyld] errno : %x", __func__, errno);
-  }
-  SemPost();
-  return -1;
-}
-
-/*******************************************************************************
-**
-** Function         Read
-**
-** Description      Reads requested number of bytes from NFCC device into given
-**                  buffer
-**
-** Parameters       pDevHandle       - valid device handle
-**                  pBuffer          - buffer for read data
-**                  nNbBytesToRead   - number of bytes requested to be read
-**
-** Returns          numRead   - number of successfully read bytes
-**                  -1        - read operation failure
-**
-*******************************************************************************/
-int NfccSpiTransport::Read(void *pDevHandle, uint8_t *pBuffer,
-                           int nNbBytesToRead) {
-  int ret_Read;
-  int ret_Select;
-  int numRead = 0;
-  struct timeval tv;
-  fd_set rfds;
-  uint16_t totalBtyesToRead = 0;
-
-  UNUSED(nNbBytesToRead);
-  if (NULL == pDevHandle) {
-    return -1;
-  }
-
-  if (bFwDnldFlag == false) {
-    totalBtyesToRead = NORMAL_MODE_HEADER_LEN;
-  } else {
-    totalBtyesToRead = FW_DNLD_HEADER_LEN;
-  }
-
-  /* Read with 2 second timeout, so that the read thread can be aborted
-     when the NFCC does not respond and we need to switch to FW download
-     mode. This should be done via a control socket instead. */
-  FD_ZERO(&rfds);
-  FD_SET((intptr_t)pDevHandle, &rfds);
-  tv.tv_sec = 2;
-  tv.tv_usec = 1;
-
-  ret_Select =
-      select((int)((intptr_t)pDevHandle + (int)1), &rfds, NULL, NULL, &tv);
-  if (ret_Select < 0) {
-    NXPLOG_TML_D("%s errno : %x", __func__, errno);
-    return -1;
-  } else if (ret_Select == 0) {
-    NXPLOG_TML_D("%s Timeout", __func__);
-    return -1;
-  } else {
-    ret_Read = read((intptr_t)pDevHandle, pBuffer, totalBtyesToRead - numRead);
-    if (ret_Read > 0 && !(pBuffer[0] == 0xFF && pBuffer[1] == 0xFF)) {
-      SemTimedWait();
-      numRead += ret_Read;
-    } else if (ret_Read == 0) {
-      NXPLOG_TML_E("%s [hdr]EOF", __func__);
-      return -1;
-    } else {
-      NXPLOG_TML_E("%s [hdr] errno : %x", __func__, errno);
-      NXPLOG_TML_E(" %s pBuffer[0] = %x pBuffer[1]= %x", __func__, pBuffer[0],
-                   pBuffer[1]);
-      return -1;
-    }
-
-    if (bFwDnldFlag == false) {
-      totalBtyesToRead = NORMAL_MODE_HEADER_LEN;
-#if(NXP_EXTNS == TRUE)
-      if (gpphTmlNfc_Context->tReadInfo.pContext != NULL &&
-              !memcmp(gpphTmlNfc_Context->tReadInfo.pContext, "MinOpen", 0x07) &&
-              !pBuffer[0] && pBuffer[1]) {
-        return Flushdata(pDevHandle, pBuffer, numRead);
-      }
-#endif
-    } else {
-      totalBtyesToRead = FW_DNLD_HEADER_LEN;
-    }
-
-    if (numRead < totalBtyesToRead) {
-      ret_Read = read((intptr_t)pDevHandle, (pBuffer + numRead), totalBtyesToRead - numRead);
-
-      if (ret_Read != totalBtyesToRead - numRead) {
-        SemPost();
-        NXPLOG_TML_E("%s [hdr] errno : %x", __func__, errno);
-        return -1;
-      } else {
-        numRead += ret_Read;
-      }
-    }
-    if (bFwDnldFlag == true) {
-      totalBtyesToRead = pBuffer[FW_DNLD_LEN_OFFSET] + FW_DNLD_HEADER_LEN + CRC_LEN;
-    } else {
-      totalBtyesToRead = pBuffer[NORMAL_MODE_LEN_OFFSET] + NORMAL_MODE_HEADER_LEN;
-    }
-    if ((totalBtyesToRead - numRead) != 0) {
-      ret_Read = read((intptr_t)pDevHandle, (pBuffer + numRead), totalBtyesToRead - numRead);
-      if (ret_Read > 0) {
-        numRead += ret_Read;
-      } else if (ret_Read == 0) {
-        SemPost();
-        NXPLOG_TML_E("%s [pyld] EOF", __func__);
-        return -1;
-      } else {
-        if (bFwDnldFlag == false) {
-          NXPLOG_TML_D("_i2c_read() [hdr] received");
-          phNxpNciHal_print_packet("RECV", pBuffer, NORMAL_MODE_HEADER_LEN);
-        }
-        SemPost();
-        NXPLOG_TML_E("%s [pyld] errno : %x", __func__, errno);
-        return -1;
-      }
-    } else {
-      NXPLOG_TML_E("%s _>>>>> Empty packet recieved !!", __func__);
-    }
-  }
-  SemPost();
-  return numRead;
-}
-
-/*******************************************************************************
-**
-** Function         Write
-**
-** Description      Writes requested number of bytes from given buffer into
-**                  NFCC device
-**
-** Parameters       pDevHandle       - valid device handle
-**                  pBuffer          - buffer for read data
-**                  nNbBytesToWrite  - number of bytes requested to be written
-**
-** Returns          numWrote   - number of successfully written bytes
-**                  -1         - write operation failure
-**
-*******************************************************************************/
-int NfccSpiTransport::Write(void *pDevHandle, uint8_t *pBuffer,
-                            int nNbBytesToWrite) {
-  int ret;
-  int numWrote = 0;
-  int numBytes = nNbBytesToWrite;
-  if (NULL == pDevHandle) {
-    return -1;
-  }
-  if (fragmentation_enabled == I2C_FRAGMENATATION_DISABLED &&
-      nNbBytesToWrite > FRAGMENTSIZE_MAX) {
-    NXPLOG_TML_D(
-        "%s data larger than maximum I2C  size,enable I2C fragmentation",
-        __func__);
-    return -1;
-  }
-  while (numWrote < nNbBytesToWrite) {
-    if (fragmentation_enabled == I2C_FRAGMENTATION_ENABLED &&
-        nNbBytesToWrite > FRAGMENTSIZE_MAX) {
-      if (nNbBytesToWrite - numWrote > FRAGMENTSIZE_MAX) {
-        numBytes = numWrote + FRAGMENTSIZE_MAX;
-      } else {
-        numBytes = nNbBytesToWrite;
-      }
-    }
-    SemTimedWait();
-    ret = write((intptr_t)pDevHandle, pBuffer + numWrote, numBytes - numWrote);
-    SemPost();
-    if (ret > 0) {
-      numWrote += ret;
-      if (fragmentation_enabled == I2C_FRAGMENTATION_ENABLED &&
-          numWrote < nNbBytesToWrite) {
-        usleep(500);
-      }
-    } else if (ret == 0) {
-      NXPLOG_TML_D("%s EOF", __func__);
-      return -1;
-    } else {
-      NXPLOG_TML_D("%s errno : %x", __func__, errno);
-      if (errno == EINTR || errno == EAGAIN) {
-        continue;
-      }
-      return -1;
-    }
-  }
-
-  return numWrote;
-}
-
-/*******************************************************************************
-**
-** Function         NfccReset
-**
-** Description      Reset NFCC device, using VEN pin
-**
-** Parameters       pDevHandle     - valid device handle
-**                  eType          - reset level
-**
-** Returns           0   - reset operation success
-**                  -1   - reset operation failure
-**
-*******************************************************************************/
-int NfccSpiTransport::NfccReset(void *pDevHandle, NfccResetType eType) {
-  int ret = -1;
-  NXPLOG_TML_D("%s, VEN eType %ld", __func__, eType);
-
-  if (NULL == pDevHandle) {
-    return -1;
-  }
-
-  ret = ioctl((intptr_t)pDevHandle, NFC_SET_PWR, eType);
-  if (ret < 0) {
-    NXPLOG_TML_E("%s :failed errno = 0x%x", __func__, errno);
-  }
-  if ((eType != MODE_FW_DWNLD_WITH_VEN && eType != MODE_FW_DWND_HIGH) &&
-      ret == 0) {
-    EnableFwDnldMode(false);
-  }
-  if ((((eType == MODE_FW_DWNLD_WITH_VEN) || (eType == MODE_FW_DWND_HIGH)) && (ret == 0))) {
-    EnableFwDnldMode(true);
-  }
-
-  return ret;
-}
-
-/*******************************************************************************
-**
-** Function         EseReset
-**
-** Description      Request NFCC to reset the eSE
-**
-** Parameters       pDevHandle     - valid device handle
-**                  eType          - EseResetType
-**
-** Returns           0   - reset operation success
-**                  else - reset operation failure
-**
-*******************************************************************************/
-int NfccSpiTransport::EseReset(void *pDevHandle, EseResetType eType) {
-  int ret = -1;
-  NXPLOG_TML_D("%s, eType %ld", __func__, eType);
-
-  if (NULL == pDevHandle) {
-    return -1;
-  }
-  ret = ioctl((intptr_t)pDevHandle, ESE_SET_PWR, eType);
-  if (ret < 0) {
-    NXPLOG_TML_E("%s :failed errno = 0x%x", __func__, errno);
-  }
-  return ret;
-}
-
-/*******************************************************************************
-**
-** Function         EseGetPower
-**
-** Description      Request NFCC to reset the eSE
-**
-** Parameters       pDevHandle     - valid device handle
-**                  level          - reset level
-**
-** Returns           0   - reset operation success
-**                  else - reset operation failure
-**
-*******************************************************************************/
-int NfccSpiTransport::EseGetPower(void *pDevHandle, long level) {
-  return ioctl((intptr_t)pDevHandle, ESE_GET_PWR, level);
-}
-
-/*******************************************************************************
-**
-** Function         GetPlatform
-**
-** Description      Get platform interface type (i2c or i3c) for common mw
-**
-** Parameters       pDevHandle     - valid device handle
-**
-** Returns           0   - i2c
-**                   1   - i3c
-**
-*******************************************************************************/
-int NfccSpiTransport::GetPlatform(void *pDevHandle) {
-  int ret = -1;
-  NXPLOG_TML_D("%s ", __func__);
-  if (NULL == pDevHandle) {
-    return -1;
-  }
-  ret = ioctl((intptr_t)pDevHandle, NFC_GET_PLATFORM_TYPE);
-  NXPLOG_TML_D("%s :platform = %d", __func__, ret);
-  return ret;
-}
-
-/*******************************************************************************
-**
-** Function         GetNfcState
-**
-** Description      Get NFC state
-**
-** Parameters       pDevHandle     - valid device handle
-** Returns           0   - unknown
-**                   1   - FW DWL
-**                   2 	 - NCI
-**
-*******************************************************************************/
-int NfccSpiTransport::GetNfcState(void *pDevHandle) {
-  int ret = NFC_STATE_UNKNOWN;
-  NXPLOG_TML_D("%s ", __func__);
-  if (NULL == pDevHandle) {
-    return ret;
-  }
-  ret = ioctl((intptr_t)pDevHandle, NFC_GET_NFC_STATE);
-  NXPLOG_TML_D("%s :nfc state = %d", __func__, ret);
-  return ret;
-}
-/*******************************************************************************
-**
-** Function         EnableFwDnldMode
-**
-** Description      updates the state to Download mode
-**
-** Parameters       True/False
-**
-** Returns          None
-*******************************************************************************/
-void NfccSpiTransport::EnableFwDnldMode(bool mode) { bFwDnldFlag = mode; }
-
-/*******************************************************************************
-**
-** Function         IsFwDnldModeEnabled
-**
-** Description      Returns the current mode
-**
-** Parameters       none
-**
-** Returns           Current mode download/NCI
-*******************************************************************************/
-bool_t NfccSpiTransport::IsFwDnldModeEnabled(void) { return bFwDnldFlag; }
-
-/*******************************************************************************
-**
-** Function         SemPost
-**
-** Description      sem_post 2c_read / write
-**
-** Parameters       none
-**
-** Returns          none
-*******************************************************************************/
-void NfccSpiTransport::SemPost() {
-  int sem_val = 0;
-  sem_getvalue(&mTxRxSemaphore, &sem_val);
-  if (sem_val == 0) {
-    sem_post(&mTxRxSemaphore);
-  }
-}
-
-/*******************************************************************************
-**
-** Function         SemTimedWait
-**
-** Description      Timed sem_wait for avoiding i2c_read & write overlap
-**
-** Parameters       none
-**
-** Returns          Sem_wait return status
-*******************************************************************************/
-int NfccSpiTransport::SemTimedWait() {
-  NFCSTATUS status = NFCSTATUS_FAILED;
-  long sem_timedout = 500 * 1000 * 1000;
-  int s = 0;
-  struct timespec ts;
-  clock_gettime(CLOCK_REALTIME, &ts);
-  ts.tv_sec += 0;
-  ts.tv_nsec += sem_timedout;
-  while ((s = sem_timedwait(&mTxRxSemaphore, &ts)) == -1 && errno == EINTR) {
-    continue; /* Restart if interrupted by handler */
-  }
-  if (s != -1) {
-    status = NFCSTATUS_SUCCESS;
-  } else if (errno == ETIMEDOUT && s == -1) {
-    NXPLOG_TML_E("%s :timed out errno = 0x%x", __func__, errno);
-  }
-  return status;
-}
-
-/*******************************************************************************
-**
-** Function         GetIrqState
-**
-** Description      Get state of IRQ GPIO
-**
-** Parameters       pDevHandle - valid device handle
-**
-** Returns          The state of IRQ line i.e. +ve if read is pending else Zer0.
-**                  In the case of IOCTL error, it returns -ve value.
-**
-*******************************************************************************/
-int NfccSpiTransport::GetIrqState(void *pDevHandle) {
-  int ret = -1;
-
-  NXPLOG_TML_D("%s Enter",__func__);
-  if (NULL != pDevHandle) {
-    ret = ioctl((intptr_t)pDevHandle, NFC_GET_IRQ_STATE);
-  }
-  NXPLOG_TML_D("%s exit: state = %d", __func__, ret);
-  return ret;
-}
diff --git a/halimpl/tml/transport/NfccSpiTransport.h b/halimpl/tml/transport/NfccSpiTransport.h
deleted file mode 100644
index d46ca18..0000000
--- a/halimpl/tml/transport/NfccSpiTransport.h
+++ /dev/null
@@ -1,266 +0,0 @@
-/******************************************************************************
- *
- *  Copyright 2020-2021 NXP
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-#pragma once
-#include <NfccTransport.h>
-
-#define NFC_MAGIC 0xE9
-/*
- * NFCC power control via ioctl
- * NFC_SET_PWR(0): power off
- * NFC_SET_PWR(1): power on
- * NFC_SET_PWR(2): reset and power on with firmware download enabled
- */
-#define NFC_SET_PWR _IOW(NFC_MAGIC, 0x01, long)
-/*
- * 1. SPI Request NFCC to enable ESE power, only in param
- *   Only for SPI
- *   level 1 = Enable power
- *   level 0 = Disable power
- * 2. NFC Request the eSE cold reset, only with MODE_ESE_COLD_RESET
- */
-#define ESE_SET_PWR _IOW(NFC_MAGIC, 0x02, long)
-
-/*
- * SPI or DWP can call this ioctl to get the current
- * power state of ESE
- */
-#define ESE_GET_PWR _IOR(NFC_MAGIC, 0x03, long)
-
-/*
- * get platform interface type(i2c or i3c) for common MW
- * return 0 - i2c, 1 - i3c
- */
-#define NFC_GET_PLATFORM_TYPE _IO(NFC_MAGIC, 0x04)
-/*
- * get boot state
- * return unknown, fw dwl, fw teared, nci
- */
-#define NFC_GET_NFC_STATE _IO(NFC_MAGIC, 0x05)
-
-/* NFC HAL can call this ioctl to get the current IRQ state */
-#define NFC_GET_IRQ_STATE _IO(NFC_MAGIC, 0x06)
-
-extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
-
-class NfccSpiTransport : public NfccTransport {
- private:
-  bool_t bFwDnldFlag = false;
-  sem_t mTxRxSemaphore;
-  /*****************************************************************************
-   **
-   ** Function         SemTimedWait
-   **
-   ** Description      Timed sem_wait for avoiding i2c_read & write overlap
-   **
-   ** Parameters       none
-   **
-   ** Returns          Sem_wait return status
-   ****************************************************************************/
-  int SemTimedWait();
-
-  /*****************************************************************************
-   **
-   ** Function         SemPost
-   **
-   ** Description      sem_post 2c_read / write
-   **
-   ** Parameters       none
-   **
-   ** Returns          none
-   ****************************************************************************/
-  void SemPost();
-
-  int Flushdata(void* pDevHandle, uint8_t* pBuffer, int numRead);
-
- public:
-  /*****************************************************************************
-  **
-  ** Function         Close
-  **
-  ** Description      Closes NFCC device
-  **
-  ** Parameters       pDevHandle - device handle
-  **
-  ** Returns          None
-  **
-  *****************************************************************************/
-  void Close(void *pDevHandle);
-
-  /*****************************************************************************
-   **
-   ** Function         OpenAndConfigure
-   **
-   ** Description      Open and configure NFCC device
-   **
-   ** Parameters       pConfig     - hardware information
-   **                  pLinkHandle - device handle
-   **
-   ** Returns          NFC status:
-   **                  NFCSTATUS_SUCCESS - open_and_configure operation success
-   **                  NFCSTATUS_INVALID_DEVICE - device open operation failure
-   **
-   ****************************************************************************/
-  NFCSTATUS OpenAndConfigure(pphTmlNfc_Config_t pConfig, void **pLinkHandle);
-
-  /*****************************************************************************
-   **
-   ** Function         Read
-   **
-   ** Description      Reads requested number of bytes from NFCC device into
-   *given
-   **                  buffer
-   **
-   ** Parameters       pDevHandle       - valid device handle
-   **                  pBuffer          - buffer for read data
-   **                  nNbBytesToRead   - number of bytes requested to be read
-   **
-   ** Returns          numRead   - number of successfully read bytes
-   **                  -1        - read operation failure
-   **
-   ****************************************************************************/
-  int Read(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToRead);
-
-  /*****************************************************************************
-  **
-  ** Function         Write
-  **
-  ** Description      Writes requested number of bytes from given buffer into
-  **                  NFCC device
-  **
-  ** Parameters       pDevHandle       - valid device handle
-  **                  pBuffer          - buffer for read data
-  **                  nNbBytesToWrite  - number of bytes requested to be written
-  **
-  ** Returns          numWrote   - number of successfully written bytes
-  **                  -1         - write operation failure
-  **
-  *****************************************************************************/
-  int Write(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToWrite);
-
-  /*****************************************************************************
-   **
-   ** Function         NfccReset
-   **
-   ** Description      Reset NFCC device, using VEN pin
-   **
-   ** Parameters       pDevHandle     - valid device handle
-   **                  level          - reset level
-   **
-   ** Returns           0   - reset operation success
-   **                  -1   - reset operation failure
-   **
-   ****************************************************************************/
-  int NfccReset(void *pDevHandle, NfccResetType eType);
-
-  /*****************************************************************************
-   **
-   ** Function         EseReset
-   **
-   ** Description      Request NFCC to reset the eSE
-   **
-   ** Parameters       pDevHandle     - valid device handle
-   **                  eType          - EseResetType
-   **
-   ** Returns           0   - reset operation success
-   **                  else - reset operation failure
-   **
-   ****************************************************************************/
-  int EseReset(void *pDevHandle, EseResetType eType);
-
-  /*****************************************************************************
-   **
-   ** Function         EseGetPower
-   **
-   ** Description      Request NFCC to reset the eSE
-   **
-   ** Parameters       pDevHandle     - valid device handle
-   **                  level          - reset level
-   **
-   ** Returns           0   - reset operation success
-   **                  else - reset operation failure
-   **
-   ****************************************************************************/
-  int EseGetPower(void *pDevHandle, long level);
-
-  /*****************************************************************************
-   **
-   ** Function         GetPlatform
-   **
-   ** Description      Get platform interface type (i2c or i3c) for common mw
-   **
-   ** Parameters       pDevHandle     - valid device handle
-   **
-   ** Returns           0   - i2c
-   **                   1   - i3c
-   **
-   ****************************************************************************/
-  int GetPlatform(void *pDevHandle);
-
-  /*****************************************************************************
-  **
-  ** Function         GetNfcState
-  **
-  ** Description      Get Nfc state
-  **
-  ** Parameters       pDevHandle     - valid device handle
-  ** Returns           0   - unknown
-  **                   1   - FW DWL
-  **                   2   - NCI
-  **
-  *****************************************************************************/
-  int GetNfcState(void *pDevHandle);
-
-  /*****************************************************************************
-   **
-   ** Function         EnableFwDnldMode
-   **
-   ** Description      updates the state to Download mode
-   **
-   ** Parameters       True/False
-   **
-   ** Returns          None
-   ****************************************************************************/
-  void EnableFwDnldMode(bool mode);
-
-  /*****************************************************************************
-   **
-   ** Function         IsFwDnldModeEnabled
-   **
-   ** Description      Returns the current mode
-   **
-   ** Parameters       none
-   **
-   ** Returns           Current mode download/NCI
-   ****************************************************************************/
-  bool_t IsFwDnldModeEnabled(void);
-
-  /*******************************************************************************
-   **
-   ** Function         GetIrqState
-   **
-   ** Description      Get state of IRQ GPIO
-   **
-   ** Parameters       pDevHandle - valid device handle
-   **
-   ** Returns          The state of IRQ line i.e. +ve if read is pending else Zer0.
-   **                  In the case of IOCTL error, it returns -ve value.
-   **
-   *******************************************************************************/
-  int GetIrqState(void *pDevHandle);
-};
diff --git a/halimpl/tml/transport/NfccTransport.cc b/halimpl/tml/transport/NfccTransport.cc
deleted file mode 100644
index 4380035..0000000
--- a/halimpl/tml/transport/NfccTransport.cc
+++ /dev/null
@@ -1,50 +0,0 @@
-/******************************************************************************
- *
- *  Copyright 2020-2021 NXP
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-#include <NfccTransport.h>
-
-int NfccTransport::NfccReset(__attribute__((unused)) void *pDevHandle,
-                             __attribute__((unused)) NfccResetType eType) {
-  return NFCSTATUS_SUCCESS;
-}
-
-int NfccTransport::EseReset(__attribute__((unused)) void *pDevHandle,
-                            __attribute__((unused)) EseResetType eType) {
-  return NFCSTATUS_SUCCESS;
-}
-int NfccTransport::EseGetPower(__attribute__((unused)) void *pDevHandle,
-                               __attribute__((unused)) long level) {
-  return NFCSTATUS_SUCCESS;
-}
-
-int NfccTransport::GetPlatform(__attribute__((unused)) void *pDevHandle) {
-  return 0x00;
-}
-
-int NfccTransport::GetNfcState(__attribute__((unused)) void *pDevHandle) {
-  return NFC_STATE_UNKNOWN;
-}
-
-void NfccTransport::EnableFwDnldMode(__attribute__((unused)) bool mode) {
-  return;
-}
-int NfccTransport::GetIrqState(__attribute__((unused)) void *pDevHandle) {
-  return -1;
-}
-
-bool_t NfccTransport::IsFwDnldModeEnabled(void) { return false; }
diff --git a/halimpl/tml/transport/NfccTransport.h b/halimpl/tml/transport/NfccTransport.h
deleted file mode 100644
index 2d2f2d3..0000000
--- a/halimpl/tml/transport/NfccTransport.h
+++ /dev/null
@@ -1,246 +0,0 @@
-/******************************************************************************
- *
- *  Copyright 2020-2021 NXP
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-#pragma once
-#include <phNfcTypes.h>
-#include <phTmlNfc.h>
-
-enum NfccResetType : long {
-  MODE_POWER_OFF = 0x00,
-  MODE_POWER_ON,
-  MODE_FW_DWNLD_WITH_VEN,
-  MODE_ISO_RST,
-  MODE_FW_DWND_HIGH,
-  MODE_POWER_RESET,
-  MODE_FW_GPIO_LOW
-};
-
-enum EseResetCallSrc : long {
-  SRC_SPI = 0x0,
-  SRC_NFC = 0x10,
-};
-
-enum EseResetType : long {
-  MODE_ESE_POWER_ON = 0,
-  MODE_ESE_POWER_OFF,
-  MODE_ESE_POWER_STATE,
-  /*Request from eSE HAL/Service*/
-  MODE_ESE_COLD_RESET,
-  MODE_ESE_RESET_PROTECTION_ENABLE,
-  MODE_ESE_RESET_PROTECTION_DISABLE,
-  /*Request from NFC HAL/Service*/
-  MODE_ESE_COLD_RESET_NFC = MODE_ESE_COLD_RESET | SRC_NFC,
-  MODE_ESE_RESET_PROTECTION_ENABLE_NFC =
-      MODE_ESE_RESET_PROTECTION_ENABLE | SRC_NFC,
-  MODE_ESE_RESET_PROTECTION_DISABLE_NFC =
-      MODE_ESE_RESET_PROTECTION_DISABLE | SRC_NFC,
-};
-
-extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
-
-class NfccTransport {
-public:
-  /*****************************************************************************
-   **
-   ** Function         Close
-   **
-   ** Description      Closes NFCC device
-   **
-   ** Parameters       pDevHandle - device handle
-   **
-   ** Returns          None
-   **
-   *****************************************************************************/
-  virtual void Close(void *pDevHandle) = 0;
-
-  /*****************************************************************************
-   **
-   ** Function         OpenAndConfigure
-   **
-   ** Description      Open and configure NFCC device and transport layer
-   **
-   ** Parameters       pConfig     - hardware information
-   **                  pLinkHandle - device handle
-   **
-   ** Returns          NFC status:
-   **                  NFCSTATUS_SUCCESS - open_and_configure operation success
-   **                  NFCSTATUS_INVALID_DEVICE - device open operation failure
-   **
-   ****************************************************************************/
-  virtual NFCSTATUS OpenAndConfigure(pphTmlNfc_Config_t pConfig,
-                                     void **pLinkHandle) = 0;
-
-  /*****************************************************************************
-   **
-   ** Function         Read
-   **
-   ** Description      Reads requested number of bytes from NFCC device into
-   **                 given buffer
-   **
-   ** Parameters       pDevHandle       - valid device handle
-   **                  pBuffer          - buffer for read data
-   **                  nNbBytesToRead   - number of bytes requested to be read
-   **
-   ** Returns          numRead   - number of successfully read bytes
-   **                  -1        - read operation failure
-   **
-   ****************************************************************************/
-  virtual int Read(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToRead) = 0;
-
-  /*****************************************************************************
-   **
-   ** Function         Write
-   **
-   ** Description      Writes requested number of bytes from given buffer into
-   **                  NFCC device
-   **
-   ** Parameters       pDevHandle       - valid device handle
-   **                  pBuffer          - buffer for read data
-   **                  nNbBytesToWrite  - number of bytes requested to be
-   *written
-   **
-   ** Returns          numWrote   - number of successfully written bytes
-   **                  -1         - write operation failure
-   **
-   *****************************************************************************/
-  virtual int Write(void *pDevHandle, uint8_t *pBuffer,
-                    int nNbBytesToWrite) = 0;
-
-  /*****************************************************************************
-   **
-   ** Function         Reset
-   **
-   ** Description      Reset NFCC device, using VEN pin
-   **
-   ** Parameters       pDevHandle     - valid device handle
-   **                  eType          - NfccResetType
-   **
-   ** Returns           0   - reset operation success
-   **                  -1   - reset operation failure
-   **
-   ****************************************************************************/
-  virtual int NfccReset(void *pDevHandle, NfccResetType eType);
-
-  /*****************************************************************************
-  **
-  ** Function         GetNfcState
-  **
-  ** Description      Get NFC state
-  **
-  ** Parameters       pDevHandle     - valid device handle
-  ** Returns           0   - unknown
-  **                   1   - FW DWL
-  **                   2   - NCI
-  **
-  *****************************************************************************/
-  virtual int GetNfcState(void *pDevHandle);
-  /*****************************************************************************
-   **
-   ** Function         EseReset
-   **
-   ** Description      Request NFCC to reset the eSE
-   **
-   ** Parameters       pDevHandle     - valid device handle
-   **                  eType          - EseResetType
-   **
-   ** Returns           0   - reset operation success
-   **                  else - reset operation failure
-   **
-   ****************************************************************************/
-  virtual int EseReset(void *pDevHandle, EseResetType eType);
-
-  /*****************************************************************************
-   **
-   ** Function         EseGetPower
-   **
-   ** Description      Request NFCC to reset the eSE
-   **
-   ** Parameters       pDevHandle     - valid device handle
-   **                  level          - reset level
-   **
-   ** Returns           0   - reset operation success
-   **                  else - reset operation failure
-   **
-   ****************************************************************************/
-  virtual int EseGetPower(void *pDevHandle, long level);
-
-  /*****************************************************************************
-   **
-   ** Function         GetPlatform
-   **
-   ** Description      Get platform interface type (i2c or i3c) for common mw
-   **
-   ** Parameters       pDevHandle     - valid device handle
-   **
-   ** Returns           0   - i2c
-   **                   1   - i3c
-   **
-   ****************************************************************************/
-  virtual int GetPlatform(void *pDevHandle);
-
-  /*****************************************************************************
-   **
-   ** Function         EnableFwDnldMode
-   **
-   ** Description      updates the state to Download mode
-   **
-   ** Parameters       True/False
-   **
-   ** Returns          None
-   ****************************************************************************/
-  virtual void EnableFwDnldMode(bool mode);
-
-  /*****************************************************************************
-   **
-   ** Function         IsFwDnldModeEnabled
-   **
-   ** Description      Returns the current mode
-   **
-   ** Parameters       none
-   **
-   ** Returns          Current mode download/NCI
-   ****************************************************************************/
-  virtual bool_t IsFwDnldModeEnabled(void);
-
-  /*******************************************************************************
-   **
-   ** Function         GetIrqState
-   **
-   ** Description      Get state of IRQ GPIO
-   **
-   ** Parameters       pDevHandle - valid device handle
-   **
-   ** Returns          The state of IRQ line i.e. +ve if read is pending else
-   *Zer0.
-   **                  In the case of IOCTL error, it returns -ve value.
-   **
-   *******************************************************************************/
-  virtual int GetIrqState(void *pDevHandle);
-
-  /*****************************************************************************
-   **
-   ** Function         ~NfccTransport
-   **
-   ** Description      TransportLayer destructor
-   **
-   ** Parameters       none
-   **
-   ** Returns          None
-   ****************************************************************************/
-  virtual ~NfccTransport(){};
-};
-- 
2.35.1

