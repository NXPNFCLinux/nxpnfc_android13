diff --git a/Android.bp b/Android.bp
index 2c557a6..94dcce4 100644
--- a/Android.bp
+++ b/Android.bp
@@ -1,6 +1,6 @@
 /******************************************************************************
   *
-  *  Copyright 2021 NXP
+  *  Copyright 2021,2022 NXP
   *
   *  Licensed under the Apache License, Version 2.0 (the "License");
   *  you may not use this file except in compliance with the License.
@@ -32,5 +32,5 @@ license {
 }
 
 subdirs = [
-    "snxxx","intf","pn8x",
+    "intf","pn8x",
 ]
diff --git a/intf/nxpnfc/1.0/manifest.xml b/intf/nxpnfc/1.0/manifest.xml
index ceabdbd..fcb4033 100644
--- a/intf/nxpnfc/1.0/manifest.xml
+++ b/intf/nxpnfc/1.0/manifest.xml
@@ -3,12 +3,20 @@
         <name>android.hardware.nfc</name>
         <transport>hwbinder</transport>
         <impl level="generic"></impl>
-        <version>1.0</version>
+        <version>1.1</version>
+        <interface>
+            <name>INfc</name>
+            <instance>default</instance>
+        </interface>
     </hal>
     <hal format="hidl">
         <name>vendor.nxp.nxpnfc</name>
         <transport>hwbinder</transport>
         <impl level="generic"></impl>
         <version>1.0</version>
+        <interface>
+            <name>INfc</name>
+            <instance>default</instance>
+        </interface>
     </hal>
 </manifest>
diff --git a/pn8x/1.1/Nfc.h b/pn8x/1.1/Nfc.h
index ef467de..36b5cf6 100755
--- a/pn8x/1.1/Nfc.h
+++ b/pn8x/1.1/Nfc.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- *  Copyright 2018 NXP
+ *  Copyright 2018,2021-2022 NXP
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -95,7 +95,7 @@ struct Nfc : public V1_1::INfc, public hidl_death_recipient {
   }
 
   virtual void serviceDied(uint64_t /*cookie*/, const wp<IBase>& /*who*/) {
-    close();
+    abort();
   }
 
  private:
diff --git a/pn8x/1.2/Nfc.cpp b/pn8x/1.2/Nfc.cpp
index f47ec1a..a22dd51 100755
--- a/pn8x/1.2/Nfc.cpp
+++ b/pn8x/1.2/Nfc.cpp
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- *  Copyright 2018-2019 NXP
+ *  Copyright 2018-2019,2022 NXP
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -24,6 +24,12 @@
 #define CHK_STATUS(x) \
   ((x) == NFCSTATUS_SUCCESS) ? (V1_0::NfcStatus::OK) : (V1_0::NfcStatus::FAILED)
 
+#define NXP_EN_PN7150 1
+#define NXP_EN_PN7160 1
+#define NFC_NXP_MW_ANDROID_VER (13U)   /* Android version used by NFC MW */
+#define NFC_NXP_MW_VERSION_MAJ (0x01)  /* MW Major Version */
+#define NFC_NXP_MW_VERSION_MIN (0x00)  /* MW Minor Version */
+
 extern bool nfc_debug_enabled;
 
 namespace android {
@@ -35,6 +41,14 @@ namespace implementation {
 sp<V1_1::INfcClientCallback> Nfc::mCallbackV1_1 = nullptr;
 sp<V1_0::INfcClientCallback> Nfc::mCallbackV1_0 = nullptr;
 
+static void printNfcMwVersion() {
+  uint32_t validation = (NXP_EN_PN7160 << 1);
+
+  ALOGE("MW-HAL Version: NFC_AR_INFRA_%04X_%02d.%02x.%02x",
+        validation, NFC_NXP_MW_ANDROID_VER,
+        NFC_NXP_MW_VERSION_MAJ, NFC_NXP_MW_VERSION_MIN);
+}
+
 Return<V1_0::NfcStatus> Nfc::open_1_1(
     const sp<V1_1::INfcClientCallback>& clientCallback) {
   if (clientCallback == nullptr) {
@@ -59,6 +73,7 @@ Return<V1_0::NfcStatus> Nfc::open(
     mCallbackV1_0->linkToDeath(this, 0 /*cookie*/);
   }
 
+  printNfcMwVersion();
   NFCSTATUS status = phNxpNciHal_open(eventCallback, dataCallback);
   ALOGD_IF(nfc_debug_enabled, "Nfc::open Exit");
   return CHK_STATUS(status);
diff --git a/pn8x/Android.bp b/pn8x/Android.bp
index f196c5a..ede2cb6 100644
--- a/pn8x/Android.bp
+++ b/pn8x/Android.bp
@@ -32,6 +32,7 @@ cc_library_shared {
         "-Wextra",
         // Allow implicit fallthroughs in phDnldNfc_Internal.cc and phNxpConfig.cpp until they are fixed.
         "-Wno-implicit-fallthrough",
+	"-DNXP_EXTNS=TRUE",
     ],
 
     srcs: [
@@ -49,7 +50,8 @@ cc_library_shared {
         "halimpl/tml/phDal4Nfc_messageQueueLib.cc",
         "halimpl/tml/phOsalNfc_Timer.cc",
         "halimpl/tml/phTmlNfc.cc",
-        "halimpl/tml/phTmlNfc_i2c.cc",
+        "halimpl/tml/NfccTransportFactory.cc",
+        "halimpl/tml/transport/*.cc",
         "halimpl/tml/spi_spm.cc",
         "halimpl/utils/NxpNfcCapability.cpp",
         "halimpl/utils/phNxpConfig.cpp",
@@ -60,12 +62,14 @@ cc_library_shared {
     ],
 
     local_include_dirs: [
+        "halimpl/common",
         "halimpl/dnld",
         "halimpl/hal",
         "halimpl/log",
         "halimpl/self-test",
         "halimpl/src/include",
         "halimpl/tml",
+        "halimpl/tml/transport",
         "halimpl/utils",
         "halimpl/mifare",
     ],
diff --git a/pn8x/extns/impl/Nxp_Features.h b/pn8x/extns/impl/Nxp_Features.h
index 48f1745..2aacd66 100755
--- a/pn8x/extns/impl/Nxp_Features.h
+++ b/pn8x/extns/impl/Nxp_Features.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- *  Copyright 2018 NXP
+ *  Copyright 2018,2022 NXP
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -25,7 +25,9 @@
 #define FW_MOBILE_MAJOR_NUMBER_PN81A 0x02
 #define FW_MOBILE_MAJOR_NUMBER_PN551 0x05
 #define FW_MOBILE_MAJOR_NUMBER_PN557 0x01
-using namespace std;
+#define FW_MOBILE_MAJOR_NUMBER_PN548AD 0x01
+
+ using namespace std;
 typedef enum {
   unknown,
   pn547C2,
@@ -60,6 +62,8 @@ extern tNfc_featureList nfcFL;
       nfcFL.chipType = pn553;            \
     } else if (chipType == pn67T) {      \
       nfcFL.chipType = pn551;            \
+    } else if (chipType == pn66T) {      \
+      nfcFL.chipType = pn548C2;          \
     }                                    \
     CONFIGURE_FEATURELIST_NFCC(chipType) \
   }
@@ -70,8 +74,8 @@ extern tNfc_featureList nfcFL;
     nfcFL._PHDNLDNFC_USERDATA_EEPROM_LEN = 0x0C80U;                 \
                                                                     \
     if (chipType == pn557 || chipType == pn81T) {                   \
-      STRCPY_FW_LIB("libpn557_fw")                                  \
-      STRCPY_FW_BIN("pn557")                                        \
+      STRCPY_FW_LIB("libpn7160_fw")                                 \
+      STRCPY_FW_BIN("pn7160")                                       \
                                                                     \
       nfcFL._FW_MOBILE_MAJOR_NUMBER = FW_MOBILE_MAJOR_NUMBER_PN557; \
     } else if (chipType == pn553 || chipType == pn80T) {            \
@@ -87,7 +91,16 @@ extern tNfc_featureList nfcFL;
       nfcFL._PHDNLDNFC_USERDATA_EEPROM_OFFSET = 0x02BCU;            \
       nfcFL._PHDNLDNFC_USERDATA_EEPROM_LEN = 0x0C00U;               \
       nfcFL._FW_MOBILE_MAJOR_NUMBER = FW_MOBILE_MAJOR_NUMBER_PN551; \
-    }                                                               \
+                                                                            \
+    } else if (chipType == pn548C2 || chipType == pn66T) {                  \
+                                                                            \
+      STRCPY_FW_LIB("libpn548ad_fw")                                        \
+      STRCPY_FW_BIN("pn548")                                                \
+                                                                            \
+      nfcFL._PHDNLDNFC_USERDATA_EEPROM_OFFSET = 0x02BCU;                    \
+      nfcFL._PHDNLDNFC_USERDATA_EEPROM_LEN = 0x0C00U;                       \
+      nfcFL._FW_MOBILE_MAJOR_NUMBER = FW_MOBILE_MAJOR_NUMBER_PN548AD;       \
+     }                                                                      \
   }
 #define STRCPY_FW_LIB(str)                       \
   {                                              \
diff --git a/pn8x/extns/impl/hal_nxpnfc.h b/pn8x/extns/impl/hal_nxpnfc.h
index ac1b1ed..8d3c1d7 100755
--- a/pn8x/extns/impl/hal_nxpnfc.h
+++ b/pn8x/extns/impl/hal_nxpnfc.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- *  Copyright 2018 NXP
+ *  Copyright 2018,2021-2022 NXP
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -27,6 +27,11 @@ enum {
   // HAL_NFC_ENABLE_I2C_FRAGMENTATION_EVT = 0x07,
   HAL_NFC_POST_MIN_INIT_CPLT_EVT = 0x08
 };
+
+enum {
+  HAL_NFC_GET_NXP_CONFIG = 30,
+};
+
 /*
  * Data structures provided below are used of Hal Ioctl calls
  */
@@ -76,6 +81,12 @@ typedef struct {
   long level;
 } nfc_nci_ExtnInputData_t;
 
+typedef struct {
+  uint8_t wAgcDebugEnable;
+  uint8_t wT4TNdefEnable;
+  uint8_t wT4TPowerState;
+} nxp_nfc_config_t;
+
 /*
  * outputData_t :ioctl has multiple commands/responses
  * This contains the output types for each ioctl.
@@ -89,6 +100,7 @@ typedef union {
   uint16_t fwDwnldStatus;
   uint16_t fwMwVerStatus;
   uint8_t chipType;
+  nxp_nfc_config_t nxpConfigs;
 } outputData_t;
 
 /*
diff --git a/pn8x/halimpl/common/phNfcCommon.h b/pn8x/halimpl/common/phNfcCommon.h
index d4fb0b4..b4cdc72 100755
--- a/pn8x/halimpl/common/phNfcCommon.h
+++ b/pn8x/halimpl/common/phNfcCommon.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2010-2021 NXP
+ * Copyright 2010-2021,2022 NXP
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -77,6 +77,51 @@
 #define CLK_FREQ_26MHZ 4
 #define CLK_FREQ_38_4MHZ 5
 #define CLK_FREQ_52MHZ 6
+#define CLK_FREQ_32MHZ 7
+#define CLK_FREQ_48MHZ 8
+
+static const uint8_t PN557_SET_CONFIG_CMD_PLL_13MHZ[] = {
+    0x20, 0x02, 0x0C, 0x01, 0xA0, 0x20, 0x08, 0x08,
+    0x52, 0xA2, 0x02, 0x30, 0x01, 0xE1, 0x02};
+static const uint8_t PN557_SET_CONFIG_CMD_DPLL_13MHZ[] = {
+    0x20, 0x02, 0x0C, 0x01, 0xA0, 0x26, 0x08, 0x40,
+    0x42, 0xA3, 0x02, 0x88, 0x01, 0xE2, 0x02};
+static const uint8_t PN557_SET_CONFIG_CMD_PLL_19_2MHZ[] = {
+    0x20, 0x02, 0x0C, 0x01, 0xA0, 0x20, 0x08, 0x88,
+    0x51, 0xE3, 0x02, 0xB8, 0x21, 0xE1, 0x02};
+static const uint8_t PN557_SET_CONFIG_CMD_DPLL_19_2MHZ[] = {
+    0x20, 0x02, 0x0C, 0x01, 0xA0, 0x26, 0x08, 0x88,
+    0x01, 0xE2, 0x02, 0xF0, 0x00, 0xA2, 0x01};
+static const uint8_t PN557_SET_CONFIG_CMD_PLL_24MHZ[] = {
+    0x20, 0x02, 0x0C, 0x01, 0xA0, 0x20, 0x08, 0x28,
+    0xC2, 0xA2, 0x83, 0x88, 0x11, 0xE1, 0x02};
+static const uint8_t PN557_SET_CONFIG_CMD_DPLL_24MHZ[] = {
+    0x20, 0x02, 0x0C, 0x01, 0xA0, 0x26, 0x08, 0x38,
+    0x41, 0xD3, 0x02, 0x88, 0x01, 0xE2, 0x02};
+static const uint8_t PN557_SET_CONFIG_CMD_PLL_26MHZ[] = {
+    0x20, 0x02, 0x0C, 0x01, 0xA0, 0x20, 0x08, 0x08,
+    0x52, 0xA2, 0x82, 0x30, 0x01, 0xE1, 0x02};
+static const uint8_t PN557_SET_CONFIG_CMD_DPLL_26MHZ[] = {
+    0x20, 0x02, 0x0C, 0x01, 0xA0, 0x26, 0x08, 0x20,
+    0x41, 0xA3, 0x01, 0x88, 0x01, 0xE2, 0x02};
+static const uint8_t PN557_SET_CONFIG_CMD_PLL_32MHZ[] = {
+    0x20, 0x02, 0x0C, 0x01, 0xA0, 0x20, 0x08, 0xB8,
+    0x51, 0xA3, 0x82, 0x88, 0xF1, 0xF0, 0x02};
+static const uint8_t PN557_SET_CONFIG_CMD_DPLL_32MHZ[] = {
+    0x20, 0x02, 0x0C, 0x01, 0xA0, 0x26, 0x08, 0xB0,
+    0x01, 0xA3, 0x82, 0x88, 0x01, 0xE2, 0x02};
+static const uint8_t PN557_SET_CONFIG_CMD_PLL_38_4MHZ[] = {
+    0x20, 0x02, 0x0C, 0x01, 0xA0, 0x20, 0x08, 0x88,
+    0x51, 0xE3, 0x82, 0xB8, 0x21, 0xE1, 0x02};
+static const uint8_t PN557_SET_CONFIG_CMD_DPLL_38_4MHZ[] = {
+    0x20, 0x02, 0x0C, 0x01, 0xA0, 0x26, 0x08, 0x88,
+    0x01, 0xE2, 0x82, 0xF0, 0x00, 0xA2, 0x01};
+static const uint8_t PN557_SET_CONFIG_CMD_PLL_48MHZ[] = {
+    0x20, 0x02, 0x0C, 0x01, 0xA0, 0x20, 0x08, 0x38,
+    0x51, 0xD3, 0x82, 0x58, 0xE1, 0xE0, 0x02};
+static const uint8_t PN557_SET_CONFIG_CMD_DPLL_48MHZ[] = {
+    0x20, 0x02, 0x0C, 0x01, 0xA0, 0x26, 0x08, 0x38,
+    0x41, 0xD3, 0x82, 0x88, 0x01, 0xE2, 0x02};
 
 /* Set to one of CLK_FREQ_<value> */
 #define NXP_SYS_CLK_FREQ_SEL CLK_FREQ_19_2MHZ
diff --git a/pn8x/halimpl/dnld/phDnldNfc.cc b/pn8x/halimpl/dnld/phDnldNfc.cc
index 2427226..7831c87 100644
--- a/pn8x/halimpl/dnld/phDnldNfc.cc
+++ b/pn8x/halimpl/dnld/phDnldNfc.cc
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2014 NXP Semiconductors
+ * Copyright 2010-2014,2021,2022 NXP
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -243,6 +243,8 @@ NFCSTATUS phDnldNfc_CheckIntegrity(uint8_t bChipVer, pphDnldNfc_Buff_t pCRCData,
     } else {
       if ((PHDNLDNFC_HWVER_MRA2_1 == bChipVer) ||
           (PHDNLDNFC_HWVER_MRA2_2 == bChipVer) ||
+          ((nfcFL.chipType == pn548C2) &&
+           (PHDNLDNFC_HWVER_PN548AD_MRA1_0 == bChipVer)) ||
           ((nfcFL.chipType == pn551) &&
            (PHDNLDNFC_HWVER_PN551_MRA1_0 == bChipVer)) ||
           (((nfcFL.chipType == pn553) || (nfcFL.chipType == pn557)) &&
@@ -559,7 +561,11 @@ NFCSTATUS phDnldNfc_Force(pphDnldNfc_Buff_t pInputs, pphDnldNfc_RspCb_t pNotify,
             bClkFreq = phDnldNfc_ClkFreq_38_4Mhz;
           } else if (CLK_FREQ_52MHZ == (pInputs->pBuff[1])) {
             bClkFreq = phDnldNfc_ClkFreq_52Mhz;
-          } else {
+          } else if (CLK_FREQ_32MHZ == (pInputs->pBuff[1])) {
+            bClkFreq = phDnldNfc_ClkFreq_32Mhz;
+          } else if (CLK_FREQ_48MHZ == (pInputs->pBuff[1])) {
+            bClkFreq = phDnldNfc_ClkFreq_48Mhz;
+          }else {
             NXPLOG_FWDNLD_E(
                 "Invalid Clk Frequency !! Using default value of 19.2Mhz..");
             bClkFreq = phDnldNfc_ClkFreq_19_2Mhz;
diff --git a/pn8x/halimpl/dnld/phDnldNfc.h b/pn8x/halimpl/dnld/phDnldNfc.h
index ae672ef..0b8987d 100755
--- a/pn8x/halimpl/dnld/phDnldNfc.h
+++ b/pn8x/halimpl/dnld/phDnldNfc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2014 NXP Semiconductors
+ * Copyright 2010-2014,2021,2022 NXP
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -43,6 +43,8 @@ typedef void (*pphDnldNfc_RspCb_t)(void* pContext, NFCSTATUS wStatus,
 #define PHDNLDNFC_HWVER_MRA2_1 (0x04U) /* ChipVersion MRA2.1 */
 #define PHDNLDNFC_HWVER_MRA2_2 (0x05U) /* ChipVersion MRA2.2 */
 
+/* PN548AD ChipVersion MRA1.0 */
+#define PHDNLDNFC_HWVER_PN548AD_MRA1_0 (0x08U)
 /* PN551 ChipVersion MRA1.0 */
 #define PHDNLDNFC_HWVER_PN551_MRA1_0 (0x08U)
 /* PN553-NCI1.0 ChipVersion MRA1.0 */
@@ -81,7 +83,9 @@ typedef enum phDnldNfc_ClkFreq {
   phDnldNfc_ClkFreq_24Mhz = 2U,   /* 24Mhz Clk Frequency */
   phDnldNfc_ClkFreq_26Mhz = 3U,   /* 26Mhz Clk Frequency */
   phDnldNfc_ClkFreq_38_4Mhz = 4U, /* 38.4Mhz Clk Frequency */
-  phDnldNfc_ClkFreq_52Mhz = 5U    /* 52Mhz Clk Frequency */
+  phDnldNfc_ClkFreq_52Mhz = 5U,    /* 52Mhz Clk Frequency */
+  phDnldNfc_ClkFreq_32Mhz = 6U,   /* 32Mhz Clk Frequency */
+  phDnldNfc_ClkFreq_48Mhz = 0x0AU    /* 48Mhz Clk Frequency */
 } phDnldNfc_ClkFreq_t;
 
 /*
diff --git a/pn8x/halimpl/dnld/phNxpNciHal_Dnld.cc b/pn8x/halimpl/dnld/phNxpNciHal_Dnld.cc
index 58ccc4c..fe1d9c5 100644
--- a/pn8x/halimpl/dnld/phNxpNciHal_Dnld.cc
+++ b/pn8x/halimpl/dnld/phNxpNciHal_Dnld.cc
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2014 NXP Semiconductors
+ * Copyright 2012-2014,2021-2022 NXP
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -531,6 +531,8 @@ static void phNxpNciHal_fw_dnld_get_version_cb(void* pContext, NFCSTATUS status,
 
       if ((PHDNLDNFC_HWVER_MRA2_1 == bHwVer) ||
           (PHDNLDNFC_HWVER_MRA2_2 == bHwVer) ||
+          ((nfcFL.chipType == pn548C2) &&
+           (PHDNLDNFC_HWVER_PN548AD_MRA1_0 == bHwVer)) ||
           ((nfcFL.chipType == pn551) &&
            (PHDNLDNFC_HWVER_PN551_MRA1_0 == bHwVer)) ||
           (((nfcFL.chipType == pn553) || (nfcFL.chipType == pn557)) &&
diff --git a/pn8x/halimpl/hal/phNxpNciHal.cc b/pn8x/halimpl/hal/phNxpNciHal.cc
index bff811c..12ba1aa 100644
--- a/pn8x/halimpl/hal/phNxpNciHal.cc
+++ b/pn8x/halimpl/hal/phNxpNciHal.cc
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 NXP
+ * Copyright 2012-2022 NXP
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -47,16 +47,22 @@ bool bDisableLegacyMfcExtns = true;
 /* Processing of ISO 15693 EOF */
 extern uint8_t icode_send_eof;
 extern uint8_t icode_detected;
+#if (NXP_EXTNS != TRUE)
 static uint8_t cmd_icode_eof[] = {0x00, 0x00, 0x00};
+#endif
 
 /* FW download success flag */
 static uint8_t fw_download_success = 0;
+/* Anti-tearing mechanism sucess flag */
+uint8_t anti_tearing_recovery_success = 0;
 
 static uint8_t config_access = false;
 static uint8_t config_success = true;
 
 static ThreadMutex sHalFnLock;
 
+extern phNxpNciClock_t phNxpNciClock;
+
 /* NCI HAL Control structure */
 phNxpNciHal_Control_t nxpncihal_ctrl;
 
@@ -75,9 +81,13 @@ extern uint16_t wFwVer;
 extern uint16_t rom_version;
 extern uint8_t gRecFWDwnld;
 static uint8_t gRecFwRetryCount;  // variable to hold recovery FW retry count
+static void phNxpNciHal_nfccClockCfgRead(void);
+static NFCSTATUS phNxpNciHal_nfccClockCfgApply(void);
 static uint8_t Rx_data[NCI_MAX_DATA_LEN];
 extern int phPalEse_spi_ioctl(phPalEse_ControlCode_t eControlCode,
                               void* pDevHandle, long level);
+uint8_t discovery_cmd[50] = {0};
+uint8_t discovery_cmd_len = 0;
 uint32_t timeoutTimerId = 0;
 bool nfc_debug_enabled = true;
 static bool sIsForceFwDownloadReqd = false;
@@ -108,8 +118,6 @@ static void phNxpNciHal_power_cycle_complete(NFCSTATUS status);
 static void phNxpNciHal_kill_client_thread(
     phNxpNciHal_Control_t* p_nxpncihal_ctrl);
 static void* phNxpNciHal_client_thread(void* arg);
-static void phNxpNciHal_get_clk_freq(void);
-static void phNxpNciHal_set_clock(void);
 static void phNxpNciHal_hci_network_reset(void);
 static NFCSTATUS phNxpNciHal_do_se_session_reset(void);
 static void phNxpNciHal_print_res_status(uint8_t* p_rx_data, uint16_t* p_len);
@@ -117,6 +125,7 @@ static NFCSTATUS phNxpNciHal_CheckValidFwVersion(void);
 static void phNxpNciHal_enable_i2c_fragmentation();
 static NFCSTATUS phNxpNciHal_get_mw_eeprom(void);
 static NFCSTATUS phNxpNciHal_set_mw_eeprom(void);
+static NFCSTATUS phNxpNciHal_config_t4t_ndef(uint8_t t4tFlag);
 static int phNxpNciHal_fw_mw_ver_check();
 NFCSTATUS phNxpNciHal_check_clock_config(void);
 NFCSTATUS phNxpNciHal_china_tianjin_rf_setting(void);
@@ -322,6 +331,7 @@ static NFCSTATUS phNxpNciHal_fw_download(void) {
     return NFCSTATUS_REJECTED;
   }
 
+#if(NXP_EXTNS != TRUE)
   nfc_nci_IoctlInOutData_t data;
   memset(&data, 0x00, sizeof(nfc_nci_IoctlInOutData_t));
   data.inp.level =
@@ -332,15 +342,17 @@ static NFCSTATUS phNxpNciHal_fw_download(void) {
     NXPLOG_NCIHAL_E("FW download denied while SPI in use, Continue NFC init");
     return NFCSTATUS_REJECTED;
   }
-  nxpncihal_ctrl.phNxpNciGpioInfo.state = GPIO_UNKNOWN;
-  phNxpNciHal_gpio_restore(GPIO_STORE);
+#endif
+  if (!sIsForceFwDownloadReqd) {
+    nxpncihal_ctrl.phNxpNciGpioInfo.state = GPIO_UNKNOWN;
+    phNxpNciHal_gpio_restore(GPIO_STORE);
+  }
 
   int fw_retry_count = 0;
   NFCSTATUS status = NFCSTATUS_REJECTED;
   NXPLOG_NCIHAL_D("Starting FW update");
   do {
     fw_download_success = 0;
-    phNxpNciHal_get_clk_freq();
     status = phTmlNfc_IoCtl(phTmlNfc_e_EnableDownloadMode);
     if (NFCSTATUS_SUCCESS != status) {
       fw_retry_count++;
@@ -491,60 +503,6 @@ static NFCSTATUS phNxpNciHal_CheckValidFwVersion(void) {
   return status;
 }
 
-static void phNxpNciHal_get_clk_freq(void) {
-  unsigned long num = 0;
-  int isfound = 0;
-
-  nxpprofile_ctrl.bClkSrcVal = 0;
-  nxpprofile_ctrl.bClkFreqVal = 0;
-  nxpprofile_ctrl.bTimeout = 0;
-
-  isfound = GetNxpNumValue(NAME_NXP_SYS_CLK_SRC_SEL, &num, sizeof(num));
-  if (isfound > 0) {
-    nxpprofile_ctrl.bClkSrcVal = num;
-  }
-
-  num = 0;
-  isfound = 0;
-  isfound = GetNxpNumValue(NAME_NXP_SYS_CLK_FREQ_SEL, &num, sizeof(num));
-  if (isfound > 0) {
-    nxpprofile_ctrl.bClkFreqVal = num;
-  }
-
-  num = 0;
-  isfound = 0;
-  isfound = GetNxpNumValue(NAME_NXP_SYS_CLOCK_TO_CFG, &num, sizeof(num));
-  if (isfound > 0) {
-    nxpprofile_ctrl.bTimeout = num;
-  }
-
-  NXPLOG_FWDNLD_D("gphNxpNciHal_fw_IoctlCtx.bClkSrcVal = 0x%x",
-                  nxpprofile_ctrl.bClkSrcVal);
-  NXPLOG_FWDNLD_D("gphNxpNciHal_fw_IoctlCtx.bClkFreqVal = 0x%x",
-                  nxpprofile_ctrl.bClkFreqVal);
-  NXPLOG_FWDNLD_D("gphNxpNciHal_fw_IoctlCtx.bClkFreqVal = 0x%x",
-                  nxpprofile_ctrl.bTimeout);
-
-  if ((nxpprofile_ctrl.bClkSrcVal < CLK_SRC_XTAL) ||
-      (nxpprofile_ctrl.bClkSrcVal > CLK_SRC_PLL)) {
-    NXPLOG_FWDNLD_E(
-        "Clock source value is wrong in config file, setting it as default");
-    nxpprofile_ctrl.bClkSrcVal = NXP_SYS_CLK_SRC_SEL;
-  }
-  if (nxpprofile_ctrl.bClkFreqVal == CLK_SRC_PLL &&
-      (nxpprofile_ctrl.bClkFreqVal < CLK_FREQ_13MHZ ||
-       nxpprofile_ctrl.bClkFreqVal > CLK_FREQ_52MHZ)) {
-    NXPLOG_FWDNLD_E(
-        "Clock frequency value is wrong in config file, setting it as default");
-    nxpprofile_ctrl.bClkFreqVal = NXP_SYS_CLK_FREQ_SEL;
-  }
-  if ((nxpprofile_ctrl.bTimeout < CLK_TO_CFG_DEF) ||
-      (nxpprofile_ctrl.bTimeout > CLK_TO_CFG_MAX)) {
-    NXPLOG_FWDNLD_E(
-        "Clock timeout value is wrong in config file, setting it as default");
-    nxpprofile_ctrl.bTimeout = CLK_TO_CFG_DEF;
-  }
-}
 
 /******************************************************************************
  * Function         phNxpNciHal_MinOpen
@@ -638,6 +596,11 @@ int phNxpNciHal_MinOpen() {
   tOsalConfig.pLogFile = NULL;
   tTmlConfig.dwGetMsgThreadId = (uintptr_t)nxpncihal_ctrl.gDrvCfg.nClientId;
 
+  if (nfcFL.chipType == pn548C2) {
+    memset(discovery_cmd, 0, sizeof(discovery_cmd));
+    discovery_cmd_len = 0;
+  }
+
   /* Initialize TML layer */
   wConfigStatus = phTmlNfc_Init(&tTmlConfig);
   if (wConfigStatus != NFCSTATUS_SUCCESS) {
@@ -854,9 +817,81 @@ int phNxpNciHal_fw_mw_ver_check() {
   } else if (((nfcFL.chipType == pn551) || (nfcFL.chipType == pn67T)) &&
              (rom_version == FW_MOBILE_ROM_VERSION_PN551)) {
     status = NFCSTATUS_SUCCESS;
-  }
+  } else if ((nfcFL.chipType == pn548C2) &&
+             (rom_version == FW_MOBILE_ROM_VERSION_PN548AD)) {
+    status = NFCSTATUS_SUCCESS;
+   }
   return status;
 }
+
+NFCSTATUS phNxpNciHal_core_reset_recovery() {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+
+  /*NCI_INIT_CMD*/
+  static uint8_t cmd_init_nci[] = {0x20, 0x01, 0x00};
+  /*NCI_RESET_CMD*/
+  static uint8_t cmd_reset_nci[] = {0x20, 0x00, 0x01,
+                                    0x00};  // keep configuration
+  static uint8_t cmd_init_nci2_0[] = {0x20, 0x01, 0x02, 0x00, 0x00};
+  /* reset config cache */
+  uint8_t retry_core_init_cnt = 0;
+
+  if (discovery_cmd_len == 0) {
+    goto FAILURE;
+  }
+  NXPLOG_NCIHAL_D("%s: recovery", __func__);
+
+retry_core_init:
+  if (retry_core_init_cnt > 3) {
+    goto FAILURE;
+  }
+
+  status = phTmlNfc_IoCtl(phTmlNfc_e_ResetDevice);
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_D("PN54X Reset - FAILED\n");
+    goto FAILURE;
+  }
+  status = phNxpNciHal_send_ext_cmd(sizeof(cmd_reset_nci), cmd_reset_nci);
+  if ((status != NFCSTATUS_SUCCESS) &&
+      (nxpncihal_ctrl.retry_cnt >= MAX_RETRY_COUNT)) {
+    retry_core_init_cnt++;
+    goto retry_core_init;
+  } else if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_D("NCI_CORE_RESET: Failed");
+    retry_core_init_cnt++;
+    goto retry_core_init;
+  }
+  if (nxpncihal_ctrl.nci_info.nci_version == NCI_VERSION_2_0) {
+    status = phNxpNciHal_send_ext_cmd(sizeof(cmd_init_nci2_0), cmd_init_nci2_0);
+  } else {
+    status = phNxpNciHal_send_ext_cmd(sizeof(cmd_init_nci), cmd_init_nci);
+  }
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_D("NCI_CORE_INIT : Failed");
+    retry_core_init_cnt++;
+    goto retry_core_init;
+  }
+
+  status = phNxpNciHal_send_ext_cmd(discovery_cmd_len, discovery_cmd);
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_D("RF_DISCOVERY : Failed");
+    retry_core_init_cnt++;
+    goto retry_core_init;
+  }
+
+  return NFCSTATUS_SUCCESS;
+FAILURE:
+  abort();
+}
+
+void phNxpNciHal_discovery_cmd_ext(uint8_t* p_cmd_data, uint16_t cmd_len) {
+  NXPLOG_NCIHAL_D("phNxpNciHal_discovery_cmd_ext");
+  if (cmd_len > 0 && cmd_len <= sizeof(discovery_cmd)) {
+    memcpy(discovery_cmd, p_cmd_data, cmd_len);
+    discovery_cmd_len = cmd_len;
+  }
+}
+
 /******************************************************************************
  * Function         phNxpNciHal_MinOpen_complete
  *
@@ -922,6 +957,124 @@ int phNxpNciHal_write(uint16_t data_len, const uint8_t* p_data) {
   return phNxpNciHal_write_internal(data_len, p_data);
 }
 
+/******************************************************************************
+ * Function         phNxpNciHal_txNfccClockSetCmd
+ *
+ * Description      This function is called after successfull download
+ *                  to apply the clock setting provided in config file
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+void phNxpNciHal_txNfccClockSetCmd(void) {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  uint8_t set_clock_cmd[] = {0x20, 0x02, 0x05, 0x01,
+                                    0xA0, 0x03, 0x01, 0x08};
+  uint8_t setClkCmdLen = sizeof(set_clock_cmd);
+  unsigned long clockSource = 0;
+  unsigned long frequency = 0;
+  uint32_t pllSetRetryCount = 3, dpllSetRetryCount = 3,
+           setClockCmdWriteRetryCnt = 0;
+  uint8_t *pCmd4PllSetting = NULL;
+  uint8_t *pCmd4DpllSetting = NULL;
+  uint32_t pllCmdLen = 0, dpllCmdLen = 0;
+  int srcCfgFound = 0, freqCfgFound = 0;
+  srcCfgFound = (GetNxpNumValue(NAME_NXP_SYS_CLK_SRC_SEL, &clockSource,
+                                sizeof(clockSource)) > 0);
+  freqCfgFound = (GetNxpNumValue(NAME_NXP_SYS_CLK_FREQ_SEL, &frequency,
+                                 sizeof(frequency)) > 0);
+  NXPLOG_NCIHAL_D("%s : clock source = %lu, frequency = %lu", __FUNCTION__,
+                  clockSource, frequency);
+  if (srcCfgFound && freqCfgFound && (clockSource == CLK_SRC_PLL)) {
+    phNxpNciClock.isClockSet = TRUE;
+    switch (frequency) {
+    case CLK_FREQ_13MHZ: {
+      NXPLOG_NCIHAL_D("PLL setting for CLK_FREQ_13MHZ");
+      pCmd4PllSetting = (uint8_t *)PN557_SET_CONFIG_CMD_PLL_13MHZ;
+      pllCmdLen = sizeof(PN557_SET_CONFIG_CMD_PLL_13MHZ);
+      pCmd4DpllSetting = (uint8_t *)PN557_SET_CONFIG_CMD_DPLL_13MHZ;
+      dpllCmdLen = sizeof(PN557_SET_CONFIG_CMD_DPLL_13MHZ);
+      break;
+    }
+    case CLK_FREQ_19_2MHZ: {
+      NXPLOG_NCIHAL_D("PLL setting for CLK_FREQ_19_2MHZ");
+      pCmd4PllSetting = (uint8_t *)PN557_SET_CONFIG_CMD_PLL_19_2MHZ;
+      pllCmdLen = sizeof(PN557_SET_CONFIG_CMD_PLL_19_2MHZ);
+      pCmd4DpllSetting = (uint8_t *)PN557_SET_CONFIG_CMD_DPLL_19_2MHZ;
+      dpllCmdLen = sizeof(PN557_SET_CONFIG_CMD_DPLL_19_2MHZ);
+      break;
+    }
+    case CLK_FREQ_24MHZ: {
+      NXPLOG_NCIHAL_D("PLL setting for CLK_FREQ_24MHZ");
+      pCmd4PllSetting = (uint8_t *)PN557_SET_CONFIG_CMD_PLL_24MHZ;
+      pllCmdLen = sizeof(PN557_SET_CONFIG_CMD_PLL_24MHZ);
+      pCmd4DpllSetting = (uint8_t *)PN557_SET_CONFIG_CMD_DPLL_24MHZ;
+      dpllCmdLen = sizeof(PN557_SET_CONFIG_CMD_DPLL_24MHZ);
+      break;
+    }
+    case CLK_FREQ_26MHZ: {
+      NXPLOG_NCIHAL_D("PLL setting for CLK_FREQ_26MHZ");
+      pCmd4PllSetting = (uint8_t *)PN557_SET_CONFIG_CMD_PLL_26MHZ;
+      pllCmdLen = sizeof(PN557_SET_CONFIG_CMD_PLL_26MHZ);
+      pCmd4DpllSetting = (uint8_t *)PN557_SET_CONFIG_CMD_DPLL_26MHZ;
+      dpllCmdLen = sizeof(PN557_SET_CONFIG_CMD_DPLL_26MHZ);
+      break;
+    }
+    case CLK_FREQ_38_4MHZ: {
+      NXPLOG_NCIHAL_D("PLL setting for CLK_FREQ_38_4MHZ");
+      pCmd4PllSetting = (uint8_t *)PN557_SET_CONFIG_CMD_PLL_38_4MHZ;
+      pllCmdLen = sizeof(PN557_SET_CONFIG_CMD_PLL_38_4MHZ);
+      pCmd4DpllSetting = (uint8_t *)PN557_SET_CONFIG_CMD_DPLL_38_4MHZ;
+      dpllCmdLen = sizeof(PN557_SET_CONFIG_CMD_DPLL_38_4MHZ);
+      break;
+    }
+    case CLK_FREQ_48MHZ: {
+        NXPLOG_NCIHAL_D("PLL setting for CLK_FREQ_48MHZ");
+        pCmd4PllSetting = (uint8_t*)PN557_SET_CONFIG_CMD_PLL_48MHZ;
+        pllCmdLen = sizeof(PN557_SET_CONFIG_CMD_PLL_48MHZ);
+        pCmd4DpllSetting = (uint8_t*)PN557_SET_CONFIG_CMD_DPLL_48MHZ;
+        dpllCmdLen = sizeof(PN557_SET_CONFIG_CMD_DPLL_48MHZ);
+        break;
+    }
+    default:
+      phNxpNciClock.isClockSet = FALSE;
+      NXPLOG_NCIHAL_E("ERROR: Invalid clock frequency!!");
+      return;
+    }
+  }
+  switch (clockSource) {
+  case CLK_SRC_PLL: {
+    set_clock_cmd[setClkCmdLen - 1] = 0x00;
+    while (status != NFCSTATUS_SUCCESS &&
+           setClockCmdWriteRetryCnt++ < MAX_RETRY_COUNT)
+      status = phNxpNciHal_send_ext_cmd(setClkCmdLen, set_clock_cmd);
+    status = NFCSTATUS_FAILED;
+    while (status != NFCSTATUS_SUCCESS && pllSetRetryCount-- > 0)
+      status = phNxpNciHal_send_ext_cmd(pllCmdLen, pCmd4PllSetting);
+    status = NFCSTATUS_FAILED;
+    while (status != NFCSTATUS_SUCCESS && dpllSetRetryCount-- > 0)
+      status = phNxpNciHal_send_ext_cmd(dpllCmdLen, pCmd4DpllSetting);
+    break;
+  }
+  case CLK_SRC_XTAL: {
+    status = phNxpNciHal_send_ext_cmd(setClkCmdLen, set_clock_cmd);
+    if (status != NFCSTATUS_SUCCESS) {
+      NXPLOG_NCIHAL_E("XTAL clock setting failed !!");
+    }
+    break;
+  }
+  default:
+    NXPLOG_NCIHAL_E("Wrong clock source. Dont apply any modification");
+    return;
+  }
+  phNxpNciClock.isClockSet = FALSE;
+  if (status == NFCSTATUS_SUCCESS &&
+      phNxpNciClock.p_rx_data[3] == NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_D("PLL and DPLL settings applied successfully");
+  }
+  return;
+}
+
 /******************************************************************************
  * Function         phNxpNciHal_write_internal
  *
@@ -980,6 +1133,7 @@ int phNxpNciHal_write_internal(uint16_t data_len, const uint8_t* p_data) {
                                         nxpncihal_ctrl.p_cmd_data);
   CONCURRENCY_UNLOCK();
 
+#if (NXP_EXTNS != TRUE)
   if (icode_send_eof == 1) {
     usleep(10000);
     icode_send_eof = 2;
@@ -988,6 +1142,7 @@ int phNxpNciHal_write_internal(uint16_t data_len, const uint8_t* p_data) {
       NXPLOG_NCIHAL_E("ICODE end of frame command failed");
     }
   }
+#endif
 
 clean_and_return:
   /* No data written */
@@ -1026,7 +1181,7 @@ int phNxpNciHal_write_unlocked(uint16_t data_len, const uint8_t* p_data) {
   if (phNxpNciHal_check_ncicmd_write_window(nxpncihal_ctrl.cmd_len,
                                             nxpncihal_ctrl.p_cmd_data) !=
       NFCSTATUS_SUCCESS) {
-    NXPLOG_NCIHAL_D("phNxpNciHal_write_unlocked Create cb data failed");
+    NXPLOG_NCIHAL_D("phNxpNciHal_write_unlocked check nci write window failed");
     data_len = 0;
     goto clean_and_return;
   }
@@ -1292,6 +1447,7 @@ int phNxpNciHal_core_initialized(uint16_t core_init_rsp_params_len,
   static uint8_t cmd_init_nci2_0[] = {0x20, 0x01, 0x02, 0x00, 0x00};
   /* reset config cache */
   static uint8_t retry_core_init_cnt;
+
   if (nxpncihal_ctrl.halStatus != HAL_STATUS_OPEN) {
     return NFCSTATUS_FAILED;
   }
@@ -1367,7 +1523,6 @@ int phNxpNciHal_core_initialized(uint16_t core_init_rsp_params_len,
       goto retry_core_init;
     }
   }
-
   status = phNxpNciHal_send_ext_cmd(sizeof(cmd_ven_pulld_enable_nci),
                                     cmd_ven_pulld_enable_nci);
   if (status != NFCSTATUS_SUCCESS) {
@@ -1379,7 +1534,6 @@ int phNxpNciHal_core_initialized(uint16_t core_init_rsp_params_len,
   if (fw_download_success == 1) {
     phNxpNciHal_hci_network_reset();
   }
-
   // Check if firmware download success
   status = phNxpNciHal_get_mw_eeprom();
   if (status != NFCSTATUS_SUCCESS) {
@@ -1387,59 +1541,6 @@ int phNxpNciHal_core_initialized(uint16_t core_init_rsp_params_len,
     retry_core_init_cnt++;
     goto retry_core_init;
   }
-
-  //
-  status = phNxpNciHal_check_clock_config();
-  if (status != NFCSTATUS_SUCCESS) {
-    NXPLOG_NCIHAL_E("phNxpNciHal_check_clock_config failed");
-    retry_core_init_cnt++;
-    goto retry_core_init;
-  }
-
-#ifdef PN547C2_CLOCK_SETTING
-  if (isNxpConfigModified() || (fw_download_success == 1) ||
-      (phNxpNciClock.issetConfig)
-#if (NFC_NXP_HFO_SETTINGS == TRUE)
-      || temp_fix == 1
-#endif
-  ) {
-    // phNxpNciHal_get_clk_freq();
-    phNxpNciHal_set_clock();
-    phNxpNciClock.issetConfig = false;
-#if (NFC_NXP_HFO_SETTINGS == TRUE)
-    if (temp_fix == 1) {
-      NXPLOG_NCIHAL_D(
-          "Applying Default Clock setting and DPLL register at power on");
-      /*
-      # A0, 0D, 06, 06, 83, 55, 2A, 04, 00 RF_CLIF_CFG_TARGET CLIF_DPLL_GEAR_REG
-      # A0, 0D, 06, 06, 82, 33, 14, 17, 00 RF_CLIF_CFG_TARGET CLIF_DPLL_INIT_REG
-      # A0, 0D, 06, 06, 84, AA, 85, 00, 80 RF_CLIF_CFG_TARGET
-      CLIF_DPLL_INIT_FREQ_REG
-      # A0, 0D, 06, 06, 81, 63, 00, 00, 00 RF_CLIF_CFG_TARGET
-      CLIF_DPLL_CONTROL_REG
-      */
-      static uint8_t cmd_dpll_set_reg_nci[] = {
-          0x20, 0x02, 0x25, 0x04, 0xA0, 0x0D, 0x06, 0x06, 0x83, 0x55,
-          0x2A, 0x04, 0x00, 0xA0, 0x0D, 0x06, 0x06, 0x82, 0x33, 0x14,
-          0x17, 0x00, 0xA0, 0x0D, 0x06, 0x06, 0x84, 0xAA, 0x85, 0x00,
-          0x80, 0xA0, 0x0D, 0x06, 0x06, 0x81, 0x63, 0x00, 0x00, 0x00};
-
-      status = phNxpNciHal_send_ext_cmd(sizeof(cmd_dpll_set_reg_nci),
-                                        cmd_dpll_set_reg_nci);
-      if (status != NFCSTATUS_SUCCESS) {
-        NXPLOG_NCIHAL_E("NXP DPLL REG ACT Proprietary Ext failed");
-        retry_core_init_cnt++;
-        goto retry_core_init;
-      }
-      /* reset the NFCC after applying the clock setting and DPLL setting */
-      // phTmlNfc_IoCtl(phTmlNfc_e_ResetDevice);
-      temp_fix = 0;
-      goto retry_core_init;
-    }
-#endif
-  }
-#endif
-
   retlen = 0;
   config_access = true;
   isfound = GetNxpByteArrayValue(NAME_NXP_NFC_PROFILE_EXTN, (char*)buffer,
@@ -1454,7 +1555,10 @@ int phNxpNciHal_core_initialized(uint16_t core_init_rsp_params_len,
     }
   }
 
-  if (isNxpConfigModified() || (fw_download_success == 1)) {
+  if (isNxpConfigModified() || (fw_download_success == 1)  || (anti_tearing_recovery_success == 1)) {
+    NXPLOG_NCIHAL_D("Applying Settings: isNxpConfigModified()=%d, fw_download_success=%d, anti_tearing_recovery_success=%d",
+      isNxpConfigModified(), fw_download_success, anti_tearing_recovery_success);
+
     retlen = 0;
     fw_download_success = 0;
 
@@ -1660,8 +1764,8 @@ int phNxpNciHal_core_initialized(uint16_t core_init_rsp_params_len,
         goto retry_core_init;
       }
     }
-    config_access = true;
 
+    config_access = true;
     retlen = 0;
     /* NXP SWP switch timeout Setting*/
     if (GetNxpNumValue(NAME_NXP_SWP_SWITCH_TIMEOUT, (void*)&retlen,
@@ -1698,17 +1802,34 @@ int phNxpNciHal_core_initialized(uint16_t core_init_rsp_params_len,
       retry_core_init_cnt++;
       goto retry_core_init;
     }
+
+    if (!GetNxpNumValue(NAME_NXP_T4T_NFCEE_ENABLE, (void*)&retlen,
+                        sizeof(retlen))) {
+      retlen = 0x00;
+      NXPLOG_NCIHAL_D(
+          "T4T_NFCEE_ENABLE not found. Taking default value : 0x%02lx", retlen);
+    }
+
+    // Configure t4t ndef emulation
+    status = phNxpNciHal_config_t4t_ndef((uint8_t)retlen);
+    if (status != NFCSTATUS_SUCCESS) {
+      NXPLOG_NCIHAL_E("NXP Update MW EEPROM Proprietary Ext failed");
+    }
+
     // Update eeprom value
     status = phNxpNciHal_set_mw_eeprom();
     if (status != NFCSTATUS_SUCCESS) {
       NXPLOG_NCIHAL_E("NXP Update MW EEPROM Proprietary Ext failed");
     }
+
+    anti_tearing_recovery_success = 0;
   }
 
   retlen = 0;
-
+  NXPLOG_NCIHAL_D("Performing NAME_NXP_CORE_CONF Settings");
   isfound =
       GetNxpByteArrayValue(NAME_NXP_CORE_CONF, (char*)buffer, bufflen, &retlen);
+  NXPLOG_NCIHAL_D("NAME_NXP_CORE_CONF Settings Found - %d Len: %ld", isfound, retlen);
   if (retlen > 0) {
     /* NXP ACT Proprietary Ext */
     status = phNxpNciHal_send_ext_cmd(retlen, buffer);
@@ -1719,6 +1840,12 @@ int phNxpNciHal_core_initialized(uint16_t core_init_rsp_params_len,
     }
   }
 
+  if (phNxpNciHal_nfccClockCfgApply() != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("phNxpNciHal_nfccClockCfgApply failed");
+    retry_core_init_cnt++;
+    goto retry_core_init;
+  }
+
   config_access = false;
   // if recovery mode and length of last command is 0 then only reset the P2P
   // listen mode routing.
@@ -2298,6 +2425,44 @@ int phNxpNciHal_configDiscShutdown(void) {
   return NFCSTATUS_SUCCESS;
 }
 
+#if(NXP_EXTNS == TRUE)
+/******************************************************************************
+ * Function         phNxpNciHal_getNxp
+ *
+ * Description      This function can be used by HAL to inform
+ *                 to update vendor configuration parametres
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+void phNxpNciHal_getNxpConfig(nfc_nci_IoctlInOutData_t *pInpOutData) {
+  unsigned long num = 0;
+  uint8_t *buffer = NULL;
+  long bufflen = 260;
+
+  buffer = (uint8_t *)malloc(bufflen * sizeof(uint8_t));
+  memset(&pInpOutData->out.data.nxpConfigs, 0x00, sizeof(pInpOutData->out.data.nxpConfigs));
+  if (GetNxpNumValue(NAME_NXP_AGC_DEBUG_ENABLE, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.wAgcDebugEnable = num;
+  }else {
+    pInpOutData->out.data.nxpConfigs.wAgcDebugEnable = 0x00;
+  }
+
+  if (GetNxpNumValue(NAME_NXP_T4T_NFCEE_ENABLE, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.wT4TNdefEnable = num;
+  }else {
+    pInpOutData->out.data.nxpConfigs.wT4TNdefEnable = 0x00;
+  }
+
+  if (GetNxpNumValue(NAME_DEFAULT_T4TNFCEE_AID_POWER_STATE, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.wT4TPowerState = num;
+  }else {
+    pInpOutData->out.data.nxpConfigs.wT4TPowerState = 0x00;
+  }
+
+}
+#endif
+
 /******************************************************************************
  * Function         phNxpNciHal_getVendorConfig
  *
@@ -2669,7 +2834,13 @@ int phNxpNciHal_ioctl(long arg, void* p_data) {
                       pInpOutData->inp.data.nciCmd.p_cmd[0]);
       if (gpEseAdapt != NULL)
         ret = gpEseAdapt->HalIoctl(HAL_NFC_IOCTL_RF_STATUS_UPDATE, pInpOutData);
+        break;
+#if(NXP_EXTNS == TRUE)
+    case HAL_NFC_GET_NXP_CONFIG:
+      phNxpNciHal_getNxpConfig(pInpOutData);
+      ret = 0;
       break;
+#endif
     default:
       NXPLOG_NCIHAL_E("%s : Wrong arg = %ld", __func__, arg);
       break;
@@ -2748,115 +2919,34 @@ retry_send_ext:
 }
 
 /******************************************************************************
- * Function         phNxpNciHal_set_clock
+ * Function         phNxpNciHal_config_t4t_ndef
  *
- * Description      This function is called after successfull download
- *                  to apply the clock setting provided in config file
+ * Description      This function is called to configure T4T Ndef emulation
  *
  * Returns          void.
  *
  ******************************************************************************/
-static void phNxpNciHal_set_clock(void) {
-  NFCSTATUS status = NFCSTATUS_FAILED;
-  int retryCount = 0;
-
-retrySetclock:
-  phNxpNciClock.isClockSet = true;
-  if (nxpprofile_ctrl.bClkSrcVal == CLK_SRC_PLL) {
-    static uint8_t set_clock_cmd[] = {0x20, 0x02, 0x09, 0x02, 0xA0, 0x03,
-                                      0x01, 0x11, 0xA0, 0x04, 0x01, 0x01};
-    uint8_t param_clock_src = 0x00;
-    if ((nfcFL.chipType != pn553) && (nfcFL.chipType != pn557)) {
-      uint8_t param_clock_src = CLK_SRC_PLL;
-      param_clock_src = param_clock_src << 3;
-    }
-
-    if (nxpprofile_ctrl.bClkFreqVal == CLK_FREQ_13MHZ) {
-      param_clock_src |= 0x00;
-    } else if (nxpprofile_ctrl.bClkFreqVal == CLK_FREQ_19_2MHZ) {
-      param_clock_src |= 0x01;
-    } else if (nxpprofile_ctrl.bClkFreqVal == CLK_FREQ_24MHZ) {
-      param_clock_src |= 0x02;
-    } else if (nxpprofile_ctrl.bClkFreqVal == CLK_FREQ_26MHZ) {
-      param_clock_src |= 0x03;
-    } else if (nxpprofile_ctrl.bClkFreqVal == CLK_FREQ_38_4MHZ) {
-      param_clock_src |= 0x04;
-    } else if (nxpprofile_ctrl.bClkFreqVal == CLK_FREQ_52MHZ) {
-      param_clock_src |= 0x05;
-    } else {
-      NXPLOG_NCIHAL_E("Wrong clock freq, send default PLL@19.2MHz");
-      if ((nfcFL.chipType == pn553) || (nfcFL.chipType == pn557)) {
-        param_clock_src = 0x01;
-      } else {
-        param_clock_src = 0x11;
-      }
-    }
+static NFCSTATUS phNxpNciHal_config_t4t_ndef(uint8_t t4tFlag) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  NXPLOG_NCIHAL_D("NxpNci phNxpNciHal_enable_ndef");
+  uint8_t retry_cnt = 0;
+  uint8_t set_mw_eeprom_cmd[8] = {0};
+  uint8_t cmd_header[] = {0x20, 0x02, 0x05, 0x01, 0xA0, 0x95, 0x01, t4tFlag};
 
-    set_clock_cmd[7] = param_clock_src;
-    set_clock_cmd[11] = nxpprofile_ctrl.bTimeout;
-    status = phNxpNciHal_send_ext_cmd(sizeof(set_clock_cmd), set_clock_cmd);
-    if (status != NFCSTATUS_SUCCESS) {
-      NXPLOG_NCIHAL_E("PLL colck setting failed !!");
-    }
-  } else if (nxpprofile_ctrl.bClkSrcVal == CLK_SRC_XTAL) {
-    static uint8_t set_clock_cmd[] = {0x20, 0x02, 0x05, 0x01,
-                                      0xA0, 0x03, 0x01, 0x08};
-    status = phNxpNciHal_send_ext_cmd(sizeof(set_clock_cmd), set_clock_cmd);
-    if (status != NFCSTATUS_SUCCESS) {
-      NXPLOG_NCIHAL_E("XTAL colck setting failed !!");
-    }
-  } else {
-    NXPLOG_NCIHAL_E("Wrong clock source. Don't apply any modification")
-  }
+  memcpy(set_mw_eeprom_cmd, cmd_header, sizeof(cmd_header));
 
-  // Checking for SET CONFG SUCCESS, re-send the command  if not.
-  phNxpNciClock.isClockSet = false;
-  if (phNxpNciClock.p_rx_data[3] != NFCSTATUS_SUCCESS) {
-    if (retryCount++ < 3) {
-      NXPLOG_NCIHAL_D("Set-clk failed retry again ");
-      goto retrySetclock;
-    } else {
-      NXPLOG_NCIHAL_E("Set clk  failed -  max count = 0x%x exceeded ",
-                      retryCount);
-      //            NXPLOG_NCIHAL_E("Set Config is failed for Clock Due to
-      //            elctrical disturbances, aborting the NFC process");
-      //            abort ();
-    }
+retry_send_ext:
+  if (retry_cnt > 3) {
+    return NFCSTATUS_FAILED;
   }
-}
-
-/******************************************************************************
- * Function         phNxpNciHal_check_clock_config
- *
- * Description      This function is called after successfull download
- *                  to check if clock settings in config file and chip
- *                  is same
- *
- * Returns          void.
- *
- ******************************************************************************/
-NFCSTATUS phNxpNciHal_check_clock_config(void) {
-  NFCSTATUS status = NFCSTATUS_SUCCESS;
-  uint8_t param_clock_src;
-  static uint8_t get_clock_cmd[] = {0x20, 0x03, 0x07, 0x03, 0xA0,
-                                    0x02, 0xA0, 0x03, 0xA0, 0x04};
-  phNxpNciClock.isClockSet = true;
-  phNxpNciHal_get_clk_freq();
-  status = phNxpNciHal_send_ext_cmd(sizeof(get_clock_cmd), get_clock_cmd);
 
+  status =
+      phNxpNciHal_send_ext_cmd(sizeof(set_mw_eeprom_cmd), set_mw_eeprom_cmd);
   if (status != NFCSTATUS_SUCCESS) {
-    NXPLOG_NCIHAL_E("unable to retrieve get_clk_src_sel");
-    return status;
-  }
-  param_clock_src = check_config_parameter();
-  if (phNxpNciClock.p_rx_data[12] == param_clock_src &&
-      phNxpNciClock.p_rx_data[16] == nxpprofile_ctrl.bTimeout) {
-    phNxpNciClock.issetConfig = false;
-  } else {
-    phNxpNciClock.issetConfig = true;
+    NXPLOG_NCIHAL_D("unable to update the mw eeprom data");
+    retry_cnt++;
+    goto retry_send_ext;
   }
-  phNxpNciClock.isClockSet = false;
-
   return status;
 }
 
@@ -3086,6 +3176,10 @@ int check_config_parameter() {
       param_clock_src |= 0x04;
     } else if (nxpprofile_ctrl.bClkFreqVal == CLK_FREQ_52MHZ) {
       param_clock_src |= 0x05;
+    } else if (nxpprofile_ctrl.bClkFreqVal == CLK_FREQ_32MHZ) {
+      param_clock_src |= 0x06;
+    } else if (nxpprofile_ctrl.bClkFreqVal == CLK_FREQ_48MHZ) {
+      param_clock_src |= 0x0A;
     } else {
       NXPLOG_NCIHAL_E("Wrong clock freq, send default PLL@19.2MHz");
       param_clock_src = 0x11;
@@ -3371,3 +3465,183 @@ static void phNxpNciHal_initialize_mifare_flag() {
     bDisableLegacyMfcExtns = (num == 0) ? true : false;
   }
 }
+
+/******************************************************************************
+ * Function         phNxpNciHal_nfccClockCfgRead
+ *
+ * Description      This function is called for loading a data strcuture from
+ *                  the config file with clock source and clock frequency values
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+static void phNxpNciHal_nfccClockCfgRead(void)
+{
+    unsigned long num = 0;
+    int isfound = 0;
+
+    nxpprofile_ctrl.bClkSrcVal = 0;
+    nxpprofile_ctrl.bClkFreqVal = 0;
+    nxpprofile_ctrl.bTimeout = 0;
+
+    isfound = GetNxpNumValue(NAME_NXP_SYS_CLK_SRC_SEL, &num, sizeof(num));
+    if (isfound > 0)
+    {
+        nxpprofile_ctrl.bClkSrcVal = num;
+    }
+
+    num = 0;
+    isfound = 0;
+    isfound = GetNxpNumValue(NAME_NXP_SYS_CLK_FREQ_SEL, &num, sizeof(num));
+    if (isfound > 0)
+    {
+        nxpprofile_ctrl.bClkFreqVal = num;
+    }
+
+    num = 0;
+    isfound = 0;
+    isfound = GetNxpNumValue(NAME_NXP_SYS_CLOCK_TO_CFG, &num, sizeof(num));
+    if (isfound > 0)
+    {
+        nxpprofile_ctrl.bTimeout = num;
+    }
+
+    NXPLOG_FWDNLD_D("gphNxpNciHal_fw_IoctlCtx.bClkSrcVal = 0x%x", nxpprofile_ctrl.bClkSrcVal);
+    NXPLOG_FWDNLD_D("gphNxpNciHal_fw_IoctlCtx.bClkFreqVal = 0x%x", nxpprofile_ctrl.bClkFreqVal);
+    NXPLOG_FWDNLD_D("gphNxpNciHal_fw_IoctlCtx.bClkFreqVal = 0x%x", nxpprofile_ctrl.bTimeout);
+
+    if ((nxpprofile_ctrl.bClkSrcVal < CLK_SRC_XTAL) ||
+            (nxpprofile_ctrl.bClkSrcVal > CLK_SRC_PLL))
+    {
+        NXPLOG_FWDNLD_E("Clock source value is wrong in config file, setting it as default");
+        nxpprofile_ctrl.bClkSrcVal = NXP_SYS_CLK_SRC_SEL;
+    }
+    if ((nxpprofile_ctrl.bClkFreqVal < CLK_FREQ_13MHZ) ||
+            (nxpprofile_ctrl.bClkFreqVal > CLK_FREQ_48MHZ))
+    {
+        NXPLOG_FWDNLD_E("Clock frequency value is wrong in config file, setting it as default");
+        nxpprofile_ctrl.bClkFreqVal = NXP_SYS_CLK_FREQ_SEL;
+    }
+    if ((nxpprofile_ctrl.bTimeout < CLK_TO_CFG_DEF) || (nxpprofile_ctrl.bTimeout > CLK_TO_CFG_MAX))
+    {
+        NXPLOG_FWDNLD_E("Clock timeout value is wrong in config file, setting it as default");
+        nxpprofile_ctrl.bTimeout = CLK_TO_CFG_DEF;
+    }
+}
+
+/******************************************************************************
+ * Function         phNxpNciHal_determineConfiguredClockSrc
+ *
+ * Description      This function determines and encodes clock source based on
+ *                  clock frequency
+ *
+ * Returns          encoded form of clock source
+ *
+ *****************************************************************************/
+int  phNxpNciHal_determineConfiguredClockSrc()
+{
+    uint8_t param_clock_src = CLK_SRC_PLL;
+    if (nxpprofile_ctrl.bClkSrcVal == CLK_SRC_PLL)
+    {
+
+        param_clock_src = param_clock_src << 3;
+
+        if (nxpprofile_ctrl.bClkFreqVal == CLK_FREQ_13MHZ)
+        {
+            param_clock_src |= 0x00;
+        }
+        else if (nxpprofile_ctrl.bClkFreqVal == CLK_FREQ_19_2MHZ)
+        {
+            param_clock_src |= 0x01;
+        }
+        else if (nxpprofile_ctrl.bClkFreqVal == CLK_FREQ_24MHZ)
+        {
+            param_clock_src |= 0x02;
+        }
+        else if (nxpprofile_ctrl.bClkFreqVal == CLK_FREQ_26MHZ)
+        {
+            param_clock_src |= 0x03;
+        }
+        else if (nxpprofile_ctrl.bClkFreqVal == CLK_FREQ_38_4MHZ)
+        {
+            param_clock_src |= 0x04;
+        }
+        else if (nxpprofile_ctrl.bClkFreqVal == CLK_FREQ_52MHZ)
+        {
+            param_clock_src |= 0x05;
+        }
+        else if (nxpprofile_ctrl.bClkFreqVal == CLK_FREQ_32MHZ)
+        {
+            param_clock_src |= 0x06;
+        } 
+        else if (nxpprofile_ctrl.bClkFreqVal == CLK_FREQ_48MHZ) 
+        {
+            param_clock_src |= 0x0A;
+        }
+        else
+        {
+            NXPLOG_NCIHAL_E("Wrong clock freq, send default PLL@19.2MHz");
+                param_clock_src = 0x11;
+        }
+    }
+    else if(nxpprofile_ctrl.bClkSrcVal == CLK_SRC_XTAL)
+    {
+        param_clock_src = 0x08;
+
+    }
+    else
+    {
+        NXPLOG_NCIHAL_E("Wrong clock source. Dont apply any modification");
+    }
+    return param_clock_src;
+  }
+
+/******************************************************************************
+ * Function         phNxpNciHal_nfccClockCfgApply
+ *
+ * Description      This function is called after successfull download
+ *                  to check if clock settings in config file and chip
+ *                  is same
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+static NFCSTATUS phNxpNciHal_nfccClockCfgApply(void) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  uint8_t nfcc_cfg_clock_src, nfcc_cur_clock_src;
+  uint8_t nfcc_clock_set_needed;
+  static uint8_t* get_clock_cmd;
+  uint8_t get_clck_cmd[] = {0x20, 0x03, 0x07, 0x03, 0xA0,
+                                    0x02, 0xA0, 0x03, 0xA0, 0x04};
+//  uint8_t get_clck_cmd_sn100[] = {0x20, 0x03, 0x03, 0x01, 0xA0, 0x11};
+//  uint8_t set_clck_cmd[] = {0x20, 0x02, 0x0B, 0x01, 0xA0, 0x11,0x07,\
+ //     0x01, 0x0A, 0x32, 0x02, 0x01, 0xF6, 0xF6};
+  uint8_t get_clk_size = 0;
+
+
+  get_clock_cmd = get_clck_cmd;
+  get_clk_size = sizeof(get_clck_cmd);
+  phNxpNciHal_nfccClockCfgRead();
+  phNxpNciClock.isClockSet = true;
+  status = phNxpNciHal_send_ext_cmd(get_clk_size, get_clock_cmd);
+  phNxpNciClock.isClockSet = false;
+
+  if (status != NFCSTATUS_SUCCESS) {
+    NXPLOG_NCIHAL_E("unable to retrieve get_clk_src_sel");
+    return status;
+  }
+
+  nfcc_cfg_clock_src = phNxpNciHal_determineConfiguredClockSrc();
+  nfcc_cur_clock_src = phNxpNciClock.p_rx_data[12];
+
+  nfcc_clock_set_needed = (nfcc_cfg_clock_src != nfcc_cur_clock_src ||
+                                  phNxpNciClock.p_rx_data[16] == nxpprofile_ctrl.bTimeout) ?\
+                                  true : false;
+
+  if(nfcc_clock_set_needed) {
+    NXPLOG_NCIHAL_D ("Setting Clock Source and Frequency");
+    phNxpNciHal_txNfccClockSetCmd();
+    }
+
+  return status;
+}
\ No newline at end of file
diff --git a/pn8x/halimpl/hal/phNxpNciHal.h b/pn8x/halimpl/hal/phNxpNciHal.h
index e57c302..8991a74 100644
--- a/pn8x/halimpl/hal/phNxpNciHal.h
+++ b/pn8x/halimpl/hal/phNxpNciHal.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2019 NXP Semiconductors
+ * Copyright 2010-2019,2022 NXP
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,6 +20,7 @@
 #include <phNxpNciHal_utils.h>
 #include "NxpMfcReader.h"
 #include "NxpNfcCapability.h"
+#include "hal_nxpnfc.h"
 
 /********************* Definitions and structures *****************************/
 #define MAX_INIT_RETRY_COUNT 3
@@ -35,6 +36,7 @@
 typedef void(phNxpNciHal_control_granted_callback_t)();
 
 /*ROM CODE VERSION FW*/
+#define FW_MOBILE_ROM_VERSION_PN548AD 0x10
 #define FW_MOBILE_ROM_VERSION_PN551 0x10
 #define FW_MOBILE_ROM_VERSION_PN553 0x11
 #define FW_MOBILE_ROM_VERSION_PN557 0x12
@@ -179,6 +181,8 @@ int phNxpNciHal_check_ncicmd_write_window(uint16_t cmd_len, uint8_t* p_cmd);
 void phNxpNciHal_request_control(void);
 void phNxpNciHal_release_control(void);
 int phNxpNciHal_write_unlocked(uint16_t data_len, const uint8_t* p_data);
+NFCSTATUS phNxpNciHal_core_reset_recovery();
+void phNxpNciHal_discovery_cmd_ext(uint8_t* p_cmd_data, uint16_t cmd_len);
 /*******************************************************************************
 **
 ** Function         phNxpNciHal_configFeatureList
@@ -188,4 +192,28 @@ int phNxpNciHal_write_unlocked(uint16_t data_len, const uint8_t* p_data);
 ** Returns          none
 *******************************************************************************/
 void phNxpNciHal_configFeatureList(uint8_t* init_rsp, uint16_t rsp_len);
+#if(NXP_EXTNS == TRUE)
+/*******************************************************************************
+**
+** Function         phNxpNciHal_getNxpConfig
+**
+** Description      Read vendor configuration macro values
+**
+** Parameters       ioctl input/output struct.
+**
+** Returns          none
+*******************************************************************************/
+void phNxpNciHal_getNxpConfig(nfc_nci_IoctlInOutData_t *pInpOutData);
+#endif
 #endif /* _PHNXPNCIHAL_H_ */
+
+/******************************************************************************
+ * Function         phNxpNciHal_txNfccClockSetCmd
+ *
+ * Description      This function is called after successfull download
+ *                  to apply the clock setting provided in config file
+ *
+ * Returns          void.
+ *
+ ******************************************************************************/
+void phNxpNciHal_txNfccClockSetCmd(void);
diff --git a/pn8x/halimpl/hal/phNxpNciHal_ext.cc b/pn8x/halimpl/hal/phNxpNciHal_ext.cc
index 6918228..9c35ea0 100644
--- a/pn8x/halimpl/hal/phNxpNciHal_ext.cc
+++ b/pn8x/halimpl/hal/phNxpNciHal_ext.cc
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 NXP
+ * Copyright 2012-2023 NXP
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -32,10 +32,12 @@
 /******************* Global variables *****************************************/
 extern phNxpNciHal_Control_t nxpncihal_ctrl;
 extern phNxpNciProfile_Control_t nxpprofile_ctrl;
+extern uint8_t anti_tearing_recovery_success;
 extern uint32_t cleanup_timer;
 extern bool nfc_debug_enabled;
 uint8_t icode_detected = 0x00;
 uint8_t icode_send_eof = 0x00;
+uint8_t nfcdep_detected = 0x00;
 static uint8_t ee_disc_done = 0x00;
 uint8_t EnableP2P_PrioLogic = false;
 extern bool bEnableMfcExtns;
@@ -66,7 +68,13 @@ static void hal_extns_write_rsp_timeout_cb(uint32_t TimerId, void* pContext);
  */
 #define PROPRIETARY_CMD_FELICA_READER_MODE 0xFE
 static uint8_t gFelicaReaderMode;
+static uint8_t rf_discovery_idle[] = {0x21, 0x06, 0x01, 0x00}; /* IDLE */
+static uint8_t rf_discovery_emvco_cmd[] = {0x21, 0x03, 0x05, 0x02, 0x00,
+                                            0x01, 0x01, 0x01}; /* RF_DISCOVER */
 
+static NFCSTATUS phNxpNciHal_emvco_start_polling_loop(void);
+static NFCSTATUS phNxpNciHal_emvco_stop_polling_loop(void);
+int emvco_discover_type = 0xFF;
 static NFCSTATUS phNxpNciHal_ext_process_nfc_init_rsp(uint8_t* p_ntf,
                                                       uint16_t* p_len);
 /*******************************************************************************
@@ -94,9 +102,13 @@ void phNxpNciHal_ext_init(void) {
 *******************************************************************************/
 NFCSTATUS phNxpNciHal_process_ext_rsp(uint8_t* p_ntf, uint16_t* p_len) {
   NFCSTATUS status = NFCSTATUS_SUCCESS;
-
+  NXPLOG_NCIHAL_D("phNxpNciHal_process_ext_rsp");
   if (p_ntf[0] == 0x61 && p_ntf[1] == 0x05 && *p_len < 14) {
-    if (*p_len <= 6) {
+    if ((nfcFL.chipType == pn548C2) && (nfcdep_detected)) {
+      nfcdep_detected = 0x00;
+    }
+
+    if(*p_len <= 6) {
       android_errorWriteLog(0x534e4554, "118152591");
     }
     NXPLOG_NCIHAL_E("RF_INTF_ACTIVATED_NTF length error!");
@@ -112,6 +124,21 @@ NFCSTATUS phNxpNciHal_process_ext_rsp(uint8_t* p_ntf, uint16_t* p_len) {
     NXPLOG_NCIHAL_D("Nfc-Dep Detect in EmvCo profile - Restart polling");
   }
 
+  if ((p_ntf[0] == 0x61 && p_ntf[1] == 0x06 &&
+    p_ntf[2] == 0x02 && p_ntf[2] == 0x03 &&
+    p_ntf[2] == 0x02 && nxpprofile_ctrl.profile_type == EMV_CO_PROFILE)
+    || (p_ntf[0] == 0x60 &&
+    p_ntf[1] == 0x08 && p_ntf[2] == 0x02 &&
+    p_ntf[3] == 0xB2 && p_ntf[4] == 0x00 &&
+    nxpprofile_ctrl.profile_type == EMV_CO_PROFILE)) {
+    NXPLOG_NCIHAL_E("RF_LINK_LOSS in EMVCO work around form MW!");
+    status = phNxpNciHal_emvco_stop_polling_loop();
+    if(status == NFCSTATUS_SUCCESS) {
+          usleep(10 * 1000);
+          phNxpNciHal_emvco_start_polling_loop();
+    }
+  }
+
   if (p_ntf[0] == 0x61 && p_ntf[1] == 0x05 && p_ntf[4] == 0x01 &&
       p_ntf[5] == 0x05 && p_ntf[6] == 0x02 && gFelicaReaderMode) {
     /*If FelicaReaderMode is enabled,Change Protocol to T3T from NFC-DEP
@@ -171,6 +198,9 @@ NFCSTATUS phNxpNciHal_process_ext_rsp(uint8_t* p_ntf, uint16_t* p_len) {
         break;
       case 0x03:
         NXPLOG_NCIHAL_D("NxpNci: RF Interface = NFC-DEP");
+        if (nfcFL.chipType == pn548C2) {
+          nfcdep_detected = 0x01;
+        }
         break;
       case 0x80:
         NXPLOG_NCIHAL_D("NxpNci: RF Interface = MIFARE");
@@ -372,6 +402,12 @@ NFCSTATUS phNxpNciHal_process_ext_rsp(uint8_t* p_ntf, uint16_t* p_len) {
       *p_len = 5;
     }
   }
+  else if(p_ntf[0] == 0x60 && p_ntf[1] == 0x07 && p_ntf[3] == 0xE6)
+  {
+      NXPLOG_NCIHAL_E("CORE_GENERIC_ERROR_NTF received!");
+      /* register recovery success to force applying RF settings */
+      anti_tearing_recovery_success = 1;
+  }
 
   if (*p_len == 4 && p_ntf[0] == 0x61 && p_ntf[1] == 0x07) {
     unsigned long rf_update_enable = 0;
@@ -486,6 +522,14 @@ static NFCSTATUS phNxpNciHal_ext_process_nfc_init_rsp(uint8_t* p_ntf,
       }
       NXPLOG_NCIHAL_D("CORE_RESET_NTF received !");
       NXPLOG_NCIR_E("len = %3d > %s", *p_len, print_buffer);
+      if ((nfcFL.chipType == pn548C2) && nfcdep_detected &&
+          !(p_ntf[2] == 0x06 && p_ntf[3] == 0xA0 && p_ntf[4] == 0x00 &&
+            ((p_ntf[5] == 0xC9 && p_ntf[6] == 0x95 && p_ntf[7] == 0x00 &&
+              p_ntf[8] == 0x00) ||
+             (p_ntf[5] == 0x07 && p_ntf[6] == 0x39 && p_ntf[7] == 0xF2 &&
+              p_ntf[8] == 0x00)))) {
+        nfcdep_detected = 0x00;
+      }
       phNxpNciHal_emergency_recovery();
       status = NFCSTATUS_FAILED;
     } /* Parsing CORE_INIT_RSP*/
@@ -544,6 +588,22 @@ static NFCSTATUS phNxpNciHal_process_ext_cmd_rsp(uint16_t cmd_len,
 
   nxpncihal_ctrl.ext_cb_data.status = NFCSTATUS_SUCCESS;
 
+  if (p_cmd[0] == 0x20 && p_cmd[1] == 0x02 &&
+             p_cmd[2] == 0x05 && p_cmd[3] == 0x01 &&
+             p_cmd[4] == 0xA0 && p_cmd[5] == 0x44 &&
+             p_cmd[6] == 0x01 && p_cmd[7] == 0x01) {
+    nxpprofile_ctrl.profile_type = EMV_CO_PROFILE;
+    NXPLOG_NCIHAL_D("EMV_CO_PROFILE mode - Enabled");
+    status = NFCSTATUS_SUCCESS;
+  } else if (p_cmd[0] == 0x20 && p_cmd[1] == 0x02 &&
+             p_cmd[2] == 0x05 && p_cmd[3] == 0x01 &&
+             p_cmd[4] == 0xA0 && p_cmd[5] == 0x44 &&
+             p_cmd[6] == 0x01 && p_cmd[7] == 0x00) {
+    NXPLOG_NCIHAL_D("NFC_FORUM_PROFILE mode - Enabled");
+    nxpprofile_ctrl.profile_type = NFC_FORUM_PROFILE;
+    status = NFCSTATUS_SUCCESS;
+  }
+
   /* Send ext command */
   data_written = phNxpNciHal_write_unlocked(cmd_len, p_cmd);
   if (data_written != cmd_len) {
@@ -745,9 +805,11 @@ NFCSTATUS phNxpNciHal_write_ext(uint16_t* cmd_len, uint8_t* p_cmd_data,
          p_cmd_data[4] == 0x24 || p_cmd_data[4] == 0x27 ||
          p_cmd_data[4] == 0x28 || p_cmd_data[4] == 0x29 ||
          p_cmd_data[4] == 0x2a)) {
-      NXPLOG_NCIHAL_D("> Send EOF set");
-      icode_send_eof = 1;
+        if (nxpncihal_ctrl.nci_info.nci_version != NCI_VERSION_2_0) {
+            NXPLOG_NCIHAL_D("> Going through workaround - Send EOF set");
+            icode_send_eof = 1;
     }
+  }
 
     if (p_cmd_data[3] == 0x20 || p_cmd_data[3] == 0x24 ||
         p_cmd_data[3] == 0x60) {
@@ -758,6 +820,10 @@ NFCSTATUS phNxpNciHal_write_ext(uint16_t* cmd_len, uint8_t* p_cmd_data,
     NXPLOG_NCIHAL_D("> Polling Loop Started");
     icode_detected = 0;
     icode_send_eof = 0;
+    if (nfcFL.chipType == pn548C2) {
+      // Cache discovery cmd for recovery
+      phNxpNciHal_discovery_cmd_ext(p_cmd_data, *cmd_len);
+    }
   }
   // 22000100
   else if (p_cmd_data[0] == 0x22 && p_cmd_data[1] == 0x00 &&
@@ -912,6 +978,53 @@ NFCSTATUS phNxpNciHal_write_ext(uint16_t* cmd_len, uint8_t* p_cmd_data,
     }
   }
 
+  if (nfcFL.chipType == pn548C2 && p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02) {
+    uint8_t temp;
+    uint8_t* p = p_cmd_data + 4;
+    uint8_t* end = p_cmd_data + *cmd_len;
+    while (p < end) {
+      if (*p == 0x53)  // LF_T3T_FLAGS
+      {
+        NXPLOG_NCIHAL_D("> Going through workaround - LF_T3T_FLAGS swap");
+        temp = *(p + 3);
+        *(p + 3) = *(p + 2);
+        *(p + 2) = temp;
+        NXPLOG_NCIHAL_D("> Going through workaround - LF_T3T_FLAGS - End");
+        status = NFCSTATUS_SUCCESS;
+        break;
+      }
+      if (*p == 0xA0) {
+        p += *(p + 2) + 3;
+      } else {
+        p += *(p + 1) + 2;
+      }
+    }
+  }
+
+  if ((nfcFL.chipType == pn548C2) &&
+          (p_cmd_data[0] == 0x20 && p_cmd_data[1] == 0x02)) {
+      uint8_t temp;
+      uint8_t* p = p_cmd_data + 4;
+      uint8_t* end = p_cmd_data + *cmd_len;
+      while (p < end) {
+          if (*p == 0x53)  // LF_T3T_FLAGS
+          {
+              NXPLOG_NCIHAL_D("> Going through workaround - LF_T3T_FLAGS swap");
+              temp = *(p + 3);
+              *(p + 3) = *(p + 2);
+              *(p + 2) = temp;
+              NXPLOG_NCIHAL_D("> Going through workaround - LF_T3T_FLAGS - End");
+              status = NFCSTATUS_SUCCESS;
+              break;
+          }
+          if (*p == 0xA0) {
+              p += *(p + 2) + 3;
+          } else {
+              p += *(p + 1) + 2;
+          }
+      }
+  }
+
   return status;
 }
 
@@ -981,3 +1094,114 @@ static void hal_extns_write_rsp_timeout_cb(uint32_t timerId, void* pContext) {
 
   return;
 }
+/*******************************************************************************
+ **
+ ** Function         emvco_rf_timout_handler_thread
+ **
+ ** Description      Thread to execute emvco_rf_timout_handler_thread commands.
+ **
+ ** Returns          None
+ **
+ *******************************************************************************/
+void* emvco_rf_timout_handler_thread(void* tmp) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  uint16_t data_len;
+  NXPLOG_NCIHAL_W("emvco_rf_timout_handler_thread: enter type=0x0%x", *((int*)tmp));
+  usleep(10 * 1000);
+
+  switch (*((int*)tmp)) {
+    case START_POLLING: {
+      NXPLOG_NCIHAL_W("emvco_rf_timout_handler_thread  STOP_POLLING enter");
+      CONCURRENCY_LOCK();
+      data_len = phNxpNciHal_write_unlocked(sizeof(rf_discovery_idle),
+                                            rf_discovery_idle);
+      NXPLOG_NCIHAL_W("emvco_rf_timout_handler_thread  STOP_POLLING exit");
+      CONCURRENCY_UNLOCK();
+
+      if (data_len != sizeof(rf_discovery_idle)) {
+        NXPLOG_NCIHAL_E("phNxpNciHal_stop_emvco__polling_loop: data len mismatch");
+        status = NFCSTATUS_FAILED;
+      }
+      NXPLOG_NCIHAL_W("emvco_rf_timout_handler_thread  START_POLLING enter");
+      CONCURRENCY_LOCK();
+      data_len = phNxpNciHal_write_unlocked(sizeof(rf_discovery_emvco_cmd), rf_discovery_emvco_cmd);
+      NXPLOG_NCIHAL_W("emvco_rf_timout_handler_thread  START_POLLING exit");
+      CONCURRENCY_UNLOCK();
+
+      if (data_len != sizeof(rf_discovery_emvco_cmd)) {
+        NXPLOG_NCIHAL_E("phNxpNciHal_start_emvco_polling_loop: data len mismatch");
+        status = NFCSTATUS_FAILED;
+      }
+    } break;
+
+    case STOP_POLLING: {
+      NXPLOG_NCIHAL_W("emvco_rf_timout_handler_thread  STOP_POLLING enter");
+      CONCURRENCY_LOCK();
+      data_len = phNxpNciHal_write_unlocked(sizeof(rf_discovery_idle),
+                                            rf_discovery_idle);
+      NXPLOG_NCIHAL_W("emvco_rf_timout_handler_thread  STOP_POLLING exit");
+      CONCURRENCY_UNLOCK();
+
+      if (data_len != sizeof(rf_discovery_idle)) {
+        NXPLOG_NCIHAL_E("phNxpNciHal_stop_emvco__polling_loop: data len mismatch");
+        status = NFCSTATUS_FAILED;
+      }
+    } break;
+
+    default:
+      NXPLOG_NCIHAL_E("No Matching case");
+      status = NFCSTATUS_FAILED;
+      break;
+  }
+
+  NXPLOG_NCIHAL_W("emvco_rf_timout_handler_thread: exit");
+  return NULL;
+}
+/*******************************************************************************
+**
+** Function         phNxpNciHal_emvco_start_polling_loop
+**
+** Description      Sends start polling cmd to NFCC
+**
+** Returns          NFCSTATUS_SUCCESS if successful,otherwise NFCSTATUS_FAILED
+**
+*******************************************************************************/
+NFCSTATUS phNxpNciHal_emvco_start_polling_loop() {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  //phNxpNciHal_Sem_t cb_data;
+  pthread_t pthread;
+  emvco_discover_type = START_POLLING;
+
+  pthread_attr_t attr;
+  pthread_attr_init(&attr);
+  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+  if (pthread_create(&pthread, &attr, emvco_rf_timout_handler_thread, (void*)&emvco_discover_type) != 0) {
+    NXPLOG_NCIHAL_E("fail to create pthread");
+  }
+  pthread_attr_destroy(&attr);
+  return status;
+}
+/*******************************************************************************
+**
+** Function         phNxpNciHal_stop_polling_loop
+**
+** Description      Sends stop polling cmd to NFCC
+**
+** Returns          NFCSTATUS_SUCCESS if successful,otherwise NFCSTATUS_FAILED
+**
+*******************************************************************************/
+static NFCSTATUS phNxpNciHal_emvco_stop_polling_loop() {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  //phNxpNciHal_Sem_t cb_data;
+  pthread_t pthread;
+  emvco_discover_type = STOP_POLLING;
+
+  pthread_attr_t attr;
+  pthread_attr_init(&attr);
+  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+  if (pthread_create(&pthread, &attr, emvco_rf_timout_handler_thread, (void*)&emvco_discover_type) != 0) {
+    NXPLOG_NCIHAL_E("fail to create pthread");
+  }
+  pthread_attr_destroy(&attr);
+  return status;
+}
\ No newline at end of file
diff --git a/pn8x/halimpl/libnfc-nxp-PN548AD_example.conf b/pn8x/halimpl/libnfc-nxp-PN548AD_example.conf
index 53121b2..00ae0b0 100755
--- a/pn8x/halimpl/libnfc-nxp-PN548AD_example.conf
+++ b/pn8x/halimpl/libnfc-nxp-PN548AD_example.conf
@@ -32,6 +32,10 @@ VZW_FEATURE_ENABLE=0x01
 ###############################################################################
 # File name for Firmware
 NXP_FW_NAME="libpn548ad_fw.so"
+# Firmware file type
+#.so file   0x01
+#.bin file  0x02
+NXP_FW_TYPE=0x01
 
 ###############################################################################
 # System clock source selection configuration
diff --git a/pn8x/halimpl/libnfc-nxp-PN66T_example.conf b/pn8x/halimpl/libnfc-nxp-PN66T_example.conf
index d63881f..972866b 100755
--- a/pn8x/halimpl/libnfc-nxp-PN66T_example.conf
+++ b/pn8x/halimpl/libnfc-nxp-PN66T_example.conf
@@ -31,6 +31,10 @@ VZW_FEATURE_ENABLE=0x01
 ###############################################################################
 # File name for Firmware
 NXP_FW_NAME="libpn548ad_fw.so"
+# Firmware file type
+#.so file   0x01
+#.bin file  0x02
+NXP_FW_TYPE=0x01
 
 ###############################################################################
 # System clock source selection configuration
diff --git a/pn8x/halimpl/src/adaptation/EseAdaptation.cpp b/pn8x/halimpl/src/adaptation/EseAdaptation.cpp
index f45af70..6f46246 100755
--- a/pn8x/halimpl/src/adaptation/EseAdaptation.cpp
+++ b/pn8x/halimpl/src/adaptation/EseAdaptation.cpp
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright 2015,2021-2022 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -57,8 +57,6 @@ ThreadCondVar EseAdaptation::mHalCoreInitCompletedEvent;
 ThreadCondVar EseAdaptation::mHalInitCompletedEvent;
 #define SIGNAL_NONE 0
 #define SIGNAL_SIGNALED 1
-static uint8_t isSignaled = SIGNAL_NONE;
-static uint8_t evt_status;
 #endif
 
 /*******************************************************************************
diff --git a/pn8x/halimpl/tml/NfccTransportFactory.cc b/pn8x/halimpl/tml/NfccTransportFactory.cc
new file mode 100755
index 0000000..166879b
--- /dev/null
+++ b/pn8x/halimpl/tml/NfccTransportFactory.cc
@@ -0,0 +1,79 @@
+/******************************************************************************
+ *
+ *  Copyright 2020-2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <NfccI2cTransport.h>
+#include <NfccSpiTransport.h>
+#include <NfccTransportFactory.h>
+#include <phNxpLog.h>
+
+/*******************************************************************************
+ **
+ ** Function         NfccTransportFactory
+ **
+ ** Description      Constructor for transportFactory. This will be private to
+ **                  support singleton
+ **
+ ** Parameters       none
+ **
+ ** Returns          none
+ ******************************************************************************/
+NfccTransportFactory::NfccTransportFactory() {}
+
+/*******************************************************************************
+**
+** Function         getTransport
+**
+** Description      selects and returns transport channel based on the input
+**                  parameter
+**
+** Parameters       Required transport Type
+**
+** Returns          Selected transport channel
+******************************************************************************/
+NfccTransportFactory& NfccTransportFactory::getInstance() {
+  static NfccTransportFactory mTransprtFactoryInstance;
+  return mTransprtFactoryInstance;
+}
+
+/*******************************************************************************
+**
+** Function         getTransport
+**
+** Description      selects and returns transport channel based on the input
+**                  parameter
+**
+** Parameters       Required transport Type
+**
+** Returns          Selected transport channel
+******************************************************************************/
+spTransport NfccTransportFactory::getTransport(transportIntf transportType) {
+  NXPLOG_TML_D("%s Requested transportType: %d\n", __func__, transportType);
+  spTransport mspTransportInterface;
+  switch (transportType) {
+    case I2C:
+    case UNKNOWN:
+      mspTransportInterface = std::make_shared<NfccI2cTransport>();
+      break;
+    case SPI:
+      mspTransportInterface = std::make_shared<NfccSpiTransport>();
+    default:
+      mspTransportInterface = std::make_shared<NfccI2cTransport>();
+      break;
+  }
+  return mspTransportInterface;
+}
diff --git a/pn8x/halimpl/tml/NfccTransportFactory.h b/pn8x/halimpl/tml/NfccTransportFactory.h
new file mode 100755
index 0000000..6ea2e2d
--- /dev/null
+++ b/pn8x/halimpl/tml/NfccTransportFactory.h
@@ -0,0 +1,67 @@
+/******************************************************************************
+ *
+ *  Copyright 2020-2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#pragma once
+#include <NfccTransport.h>
+#include <memory>
+
+#define transportFactory (NfccTransportFactory::getInstance())
+typedef std::shared_ptr<NfccTransport> spTransport;
+enum transportIntf { I2C, SPI, UNKNOWN };
+
+extern spTransport gpTransportObj;
+class NfccTransportFactory {
+  /*****************************************************************************
+   **
+   ** Function         NfccTransportFactory
+   **
+   ** Description      Constructor for transportFactory. This will be private to
+   **                  support singleton
+   **
+   ** Parameters       none
+   **
+   ** Returns          none
+   ****************************************************************************/
+  NfccTransportFactory();
+
+ public:
+  /*****************************************************************************
+   **
+   ** Function         getInstance
+   **
+   ** Description      returns the static instance of TransportFactory
+   **
+   ** Parameters       none
+   **
+   ** Returns          TransportFactory instance
+   ****************************************************************************/
+  static NfccTransportFactory& getInstance();
+
+  /*****************************************************************************
+  **
+  ** Function         getTransport
+  **
+  ** Description      selects and returns transport channel based on the input
+  **                  parameter
+  **
+  ** Parameters       Required transport Type
+  **
+  ** Returns          Selected transport channel
+  ****************************************************************************/
+  spTransport getTransport(transportIntf transportType);
+};
diff --git a/pn8x/halimpl/tml/phTmlNfc.cc b/pn8x/halimpl/tml/phTmlNfc.cc
index 72b366e..d22db8f 100644
--- a/pn8x/halimpl/tml/phTmlNfc.cc
+++ b/pn8x/halimpl/tml/phTmlNfc.cc
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2014 NXP Semiconductors
+ * Copyright 2010-2021 NXP Semiconductors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,12 +18,13 @@
  * TML Implementation.
  */
 
+#include "NfccTransportFactory.h"
 #include <phDal4Nfc_messageQueueLib.h>
+#include <phNxpConfig.h>
 #include <phNxpLog.h>
 #include <phNxpNciHal_utils.h>
 #include <phOsalNfc_Timer.h>
 #include <phTmlNfc.h>
-#include <phTmlNfc_i2c.h>
 
 /*
  * Duration of Timer to wait after sending an Nci packet
@@ -51,6 +52,8 @@ static void* phTmlNfc_TmlWriterThread(void* pParam);
 static void phTmlNfc_ReTxTimerCb(uint32_t dwTimerId, void* pContext);
 static NFCSTATUS phTmlNfc_InitiateTimer(void);
 
+spTransport gpTransportObj;
+
 /* Function definitions */
 
 /*******************************************************************************
@@ -95,6 +98,10 @@ NFCSTATUS phTmlNfc_Init(pphTmlNfc_Config_t pConfig) {
     if (NULL == gpphTmlNfc_Context) {
       wInitStatus = PHNFCSTVAL(CID_NFC_TML, NFCSTATUS_FAILED);
     } else {
+      /*Configure transport layer for communication*/
+      if (NFCSTATUS_SUCCESS != phTmlNfc_ConfigTransport())
+        return NFCSTATUS_FAILED;
+
       /* Initialise all the internal TML variables */
       memset(gpphTmlNfc_Context, PH_TMLNFC_RESET_VALUE,
              sizeof(phTmlNfc_Context_t));
@@ -102,7 +109,7 @@ NFCSTATUS phTmlNfc_Init(pphTmlNfc_Config_t pConfig) {
       gpphTmlNfc_Context->bThreadDone = 1;
 
       /* Open the device file to which data is read/written */
-      wInitStatus = phTmlNfc_i2c_open_and_configure(
+      wInitStatus = gpTransportObj->OpenAndConfigure(
           pConfig, &(gpphTmlNfc_Context->pDevHandle));
 
       if (NFCSTATUS_SUCCESS != wInitStatus) {
@@ -159,6 +166,32 @@ NFCSTATUS phTmlNfc_Init(pphTmlNfc_Config_t pConfig) {
   return wInitStatus;
 }
 
+/*******************************************************************************
+**
+** Function         phTmlNfc_ConfigTransport
+**
+** Description      Configure Transport channel based on transport type provided
+**                  in config file
+**
+** Returns          NFCSTATUS_SUCCESS If transport channel is configured
+**                  NFCSTATUS_FAILED If transport channel configuration failed
+**
+*******************************************************************************/
+NFCSTATUS phTmlNfc_ConfigTransport() {
+  unsigned long transportType = UNKNOWN;
+  unsigned long value = 0;
+  int isfound = GetNxpNumValue(NAME_NXP_TRANSPORT, &value, sizeof(value));
+  if (isfound > 0) {
+    transportType = value;
+  }
+  gpTransportObj = transportFactory.getTransport((transportIntf)transportType);
+  if (gpTransportObj == nullptr) {
+    NXPLOG_TML_E("No Transport channel available \n");
+    return NFCSTATUS_FAILED;
+  }
+  return NFCSTATUS_SUCCESS;
+}
+
 /*******************************************************************************
 **
 ** Function         phTmlNfc_ConfigNciPktReTx
@@ -332,7 +365,7 @@ static void* phTmlNfc_TmlThread(void* pParam) {
       if (NULL != gpphTmlNfc_Context->pDevHandle) {
         NXPLOG_TML_D("PN54X - Invoking I2C Read.....\n");
         dwNoBytesWrRd =
-            phTmlNfc_i2c_read(gpphTmlNfc_Context->pDevHandle, temp, 260);
+            gpTransportObj->Read(gpphTmlNfc_Context->pDevHandle, temp, 260);
 
         if (-1 == dwNoBytesWrRd) {
           NXPLOG_TML_E("PN54X - Error in I2C Read.....\n");
@@ -453,13 +486,13 @@ static void* phTmlNfc_TmlWriterThread(void* pParam) {
         /* Write the data in the buffer onto the file */
         NXPLOG_TML_D("PN54X - Invoking I2C Write.....\n");
         dwNoBytesWrRd =
-            phTmlNfc_i2c_write(gpphTmlNfc_Context->pDevHandle,
-                               gpphTmlNfc_Context->tWriteInfo.pBuffer,
-                               gpphTmlNfc_Context->tWriteInfo.wLength);
+            gpTransportObj->Write(gpphTmlNfc_Context->pDevHandle,
+                                  gpphTmlNfc_Context->tWriteInfo.pBuffer,
+                                  gpphTmlNfc_Context->tWriteInfo.wLength);
 
         /* Try I2C Write Five Times, if it fails : Raju */
         if (-1 == dwNoBytesWrRd) {
-          if (getDownloadFlag() == true) {
+          if (gpTransportObj->IsFwDnldModeEnabled() == true) {
             if (retry_cnt++ < MAX_WRITE_RETRY_COUNT) {
               NXPLOG_TML_D("PN54X - Error in I2C Write  - Retry 0x%x",
                            retry_cnt);
@@ -558,13 +591,15 @@ void phTmlNfc_CleanUp(void) {
     return;
   }
   if (NULL != gpphTmlNfc_Context->pDevHandle) {
-    (void)phTmlNfc_i2c_reset(gpphTmlNfc_Context->pDevHandle, 0);
+    (void)gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle,
+                                    MODE_POWER_OFF);
     gpphTmlNfc_Context->bThreadDone = 0;
   }
   sem_destroy(&gpphTmlNfc_Context->rxSemaphore);
   sem_destroy(&gpphTmlNfc_Context->txSemaphore);
   sem_destroy(&gpphTmlNfc_Context->postMsgSemaphore);
-  phTmlNfc_i2c_close(gpphTmlNfc_Context->pDevHandle);
+  gpTransportObj->Close(gpphTmlNfc_Context->pDevHandle);
+  gpTransportObj = NULL;
   gpphTmlNfc_Context->pDevHandle = NULL;
   /* Clear memory allocated for storing Context variables */
   free((void*)gpphTmlNfc_Context);
@@ -876,24 +911,30 @@ NFCSTATUS phTmlNfc_IoCtl(phTmlNfc_ControlCode_t eControlCode) {
     switch (eControlCode) {
       case phTmlNfc_e_ResetDevice: {
         /*Reset PN54X*/
-        phTmlNfc_i2c_reset(gpphTmlNfc_Context->pDevHandle, 1);
+        gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle,
+                                  MODE_POWER_ON);
         usleep(100 * 1000);
-        phTmlNfc_i2c_reset(gpphTmlNfc_Context->pDevHandle, 0);
+        gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle,
+                                  MODE_POWER_OFF);
         usleep(100 * 1000);
-        phTmlNfc_i2c_reset(gpphTmlNfc_Context->pDevHandle, 1);
+        gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle,
+                                  MODE_POWER_ON);
         break;
       }
       case phTmlNfc_e_EnableNormalMode: {
         /*Reset PN54X*/
-        phTmlNfc_i2c_reset(gpphTmlNfc_Context->pDevHandle, 0);
+        gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle,
+                                  MODE_POWER_OFF);
         usleep(10 * 1000);
-        phTmlNfc_i2c_reset(gpphTmlNfc_Context->pDevHandle, 1);
+        gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle,
+                                  MODE_POWER_ON);
         usleep(100 * 1000);
         break;
       }
       case phTmlNfc_e_EnableDownloadMode: {
-        phTmlNfc_ConfigNciPktReTx(phTmlNfc_e_DisableRetrans, 0);
-        (void)phTmlNfc_i2c_reset(gpphTmlNfc_Context->pDevHandle, 2);
+        phTmlNfc_ConfigNciPktReTx(phTmlNfc_e_DisableRetrans, MODE_POWER_OFF);
+        (void)gpTransportObj->NfccReset(gpphTmlNfc_Context->pDevHandle,
+                                        MODE_FW_DWNLD_WITH_VEN);
         usleep(100 * 1000);
         break;
       }
diff --git a/pn8x/halimpl/tml/phTmlNfc.h b/pn8x/halimpl/tml/phTmlNfc.h
index 002889d..3e84359 100755
--- a/pn8x/halimpl/tml/phTmlNfc.h
+++ b/pn8x/halimpl/tml/phTmlNfc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2014 NXP Semiconductors
+ * Copyright 2010-2022 NXP
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -76,6 +76,15 @@ typedef struct phTmlNfc_TransactInfo {
   uint16_t wLength;        /* Data size of the Transaction*/
 } phTmlNfc_TransactInfo_t; /* Instance of Transaction structure */
 
+/*nfc state flags*/
+enum nfc_state_flags {
+  /*nfc in unknown state */
+  NFC_STATE_UNKNOWN = 0,
+  /*nfc booted in download mode */
+  NFC_STATE_FW_DWL = 0x1,
+  /*nfc booted in NCI mode */
+  NFC_STATE_NCI = 0x2,
+};
 /*
  * TML transreceive completion callback to Upper Layer
  *
@@ -229,4 +238,5 @@ void phTmlNfc_ConfigNciPktReTx(phTmlNfc_ConfigRetrans_t eConfig,
                                uint8_t bRetryCount);
 void phTmlNfc_set_fragmentation_enabled(phTmlNfc_i2cfragmentation_t enable);
 phTmlNfc_i2cfragmentation_t phTmlNfc_get_fragmentation_enabled();
+NFCSTATUS phTmlNfc_ConfigTransport();
 #endif /*  PHTMLNFC_H  */
diff --git a/pn8x/halimpl/tml/spi_spm.cc b/pn8x/halimpl/tml/spi_spm.cc
index 8373e50..a0f9015 100755
--- a/pn8x/halimpl/tml/spi_spm.cc
+++ b/pn8x/halimpl/tml/spi_spm.cc
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2014 NXP Semiconductors
+ * Copyright 2012-2021 NXP Semiconductors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,12 +19,12 @@
 #include <sys/types.h>
 #include <unistd.h>
 
+#include "NfccTransportFactory.h"
+#include "phNxpLog.h"
+#include "spi_spm.h"
 #include <errno.h>
 #include <fcntl.h>
 #include <sys/ioctl.h>
-#include "phNxpLog.h"
-#include "phTmlNfc_i2c.h"
-#include "spi_spm.h"
 
 /*******************************************************************************
 **
@@ -51,13 +51,13 @@ int phPalEse_spi_ioctl(phPalEse_ControlCode_t eControlCode, void* pDevHandle,
   switch (eControlCode) {
     case phPalEse_e_ChipRst:
       if (level == 1 || level == 0)
-        ret = ioctl((intptr_t)pDevHandle, P61_SET_SPI_PWR, level);
+          ret = gpTransportObj->EseReset(pDevHandle, (EseResetType)level);
       else
         ret = 0;
       break;
 
     case phPalEse_e_GetSPMStatus:
-      ret = ioctl((intptr_t)pDevHandle, P61_GET_PWR_STATUS, level);
+      ret = gpTransportObj->EseGetPower(pDevHandle, level);
       break;
 
     case phPalEse_e_SetPowerScheme:
@@ -72,7 +72,7 @@ int phPalEse_spi_ioctl(phPalEse_ControlCode_t eControlCode, void* pDevHandle,
       break;
 #endif
     case phPalEse_e_DisablePwrCntrl:
-      ret = ioctl((intptr_t)pDevHandle, P61_SET_SPI_PWR, 1);
+      ret = gpTransportObj->EseReset(pDevHandle, MODE_ESE_POWER_OFF);
       break;
     default:
       ret = -1;
diff --git a/pn8x/halimpl/tml/transport/NfccI2cTransport.cc b/pn8x/halimpl/tml/transport/NfccI2cTransport.cc
new file mode 100755
index 0000000..17cbee4
--- /dev/null
+++ b/pn8x/halimpl/tml/transport/NfccI2cTransport.cc
@@ -0,0 +1,533 @@
+/******************************************************************************
+ *  Copyright 2020-2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <errno.h>
+#include <fcntl.h>
+#include <hardware/nfc.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/select.h>
+#include <termios.h>
+#include <unistd.h>
+
+#include "phNxpNciHal_utils.h"
+#include <NfccI2cTransport.h>
+#include <phNfcStatus.h>
+#include <phNxpLog.h>
+#include <string.h>
+
+#define CRC_LEN 2
+#define NORMAL_MODE_HEADER_LEN 3
+#define FW_DNLD_HEADER_LEN 2
+#define FW_DNLD_LEN_OFFSET 1
+#define NORMAL_MODE_LEN_OFFSET 2
+#define FRAGMENTSIZE_MAX PHNFC_I2C_FRAGMENT_SIZE
+extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
+extern phTmlNfc_Context_t *gpphTmlNfc_Context;
+/*******************************************************************************
+**
+** Function         Close
+**
+** Description      Closes NFCC device
+**
+** Parameters       pDevHandle - device handle
+**
+** Returns          None
+**
+*******************************************************************************/
+void NfccI2cTransport::Close(void *pDevHandle) {
+  if (NULL != pDevHandle) {
+    close((intptr_t)pDevHandle);
+  }
+  sem_destroy(&mTxRxSemaphore);
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         OpenAndConfigure
+**
+** Description      Open and configure NFCC device
+**
+** Parameters       pConfig     - hardware information
+**                  pLinkHandle - device handle
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - open_and_configure operation success
+**                  NFCSTATUS_INVALID_DEVICE - device open operation failure
+**
+*******************************************************************************/
+NFCSTATUS NfccI2cTransport::OpenAndConfigure(pphTmlNfc_Config_t pConfig,
+                                             void **pLinkHandle) {
+  int nHandle;
+
+  NXPLOG_TML_D("%s Opening port=%s\n", __func__, pConfig->pDevName);
+  /* open port */
+  nHandle = open((const char *)pConfig->pDevName, O_RDWR);
+  if (nHandle < 0) {
+    NXPLOG_TML_E("_i2c_open() Failed: retval %x", nHandle);
+    *pLinkHandle = NULL;
+    return NFCSTATUS_INVALID_DEVICE;
+  }
+
+  *pLinkHandle = (void *)((intptr_t)nHandle);
+  if (0 != sem_init(&mTxRxSemaphore, 0, 1)) {
+    NXPLOG_TML_E("%s Failed: reason sem_init : retval %x", __func__, nHandle);
+  }
+  /*Reset PN54X*/
+  NfccReset((void *)((intptr_t)nHandle), MODE_POWER_OFF);
+  usleep(10 * 1000);
+  NfccReset((void *)((intptr_t)nHandle), MODE_POWER_ON);
+
+  return NFCSTATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         Flushdata
+**
+** Description      Reads payload of FW rsp from NFCC device into given buffer
+**
+** Parameters       pDevHandle - valid device handle
+**                  pBuffer    - buffer for read data
+**                  numRead    - number of bytes read by calling function
+**
+** Returns          always returns -1
+**
+*******************************************************************************/
+int NfccI2cTransport::Flushdata(void* pDevHandle, uint8_t* pBuffer, int numRead) {
+  int retRead = 0;
+  uint16_t totalBtyesToRead = pBuffer[FW_DNLD_LEN_OFFSET] + FW_DNLD_HEADER_LEN + CRC_LEN;
+  /* we shall read totalBtyesToRead-1 as one byte is already read by calling function*/
+  retRead = read((intptr_t)pDevHandle, pBuffer + numRead, totalBtyesToRead - 1);
+  if (retRead > 0) {
+    numRead += retRead;
+    phNxpNciHal_print_packet("RECV", pBuffer, numRead);
+  } else if (retRead == 0) {
+    NXPLOG_TML_E("%s _i2c_read() [pyld] EOF", __func__);
+  } else {
+    if (bFwDnldFlag == false) {
+      NXPLOG_TML_D("%s _i2c_read() [hdr] received", __func__);
+      phNxpNciHal_print_packet("RECV", pBuffer - numRead, NORMAL_MODE_HEADER_LEN);
+    }
+    NXPLOG_TML_E("%s _i2c_read() [pyld] errno : %x", __func__, errno);
+  }
+  SemPost();
+  return -1;
+}
+
+/*******************************************************************************
+**
+** Function         Read
+**
+** Description      Reads requested number of bytes from NFCC device into given
+**                  buffer
+**
+** Parameters       pDevHandle       - valid device handle
+**                  pBuffer          - buffer for read data
+**                  nNbBytesToRead   - number of bytes requested to be read
+**
+** Returns          numRead   - number of successfully read bytes
+**                  -1        - read operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::Read(void *pDevHandle, uint8_t *pBuffer,
+                           int nNbBytesToRead) {
+  int ret_Read;
+  int ret_Select;
+  int numRead = 0;
+  struct timeval tv;
+  fd_set rfds;
+  uint16_t totalBtyesToRead = 0;
+
+  UNUSED(nNbBytesToRead);
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+
+  if (bFwDnldFlag == false) {
+    totalBtyesToRead = NORMAL_MODE_HEADER_LEN;
+  } else {
+    totalBtyesToRead = FW_DNLD_HEADER_LEN;
+  }
+
+  /* Read with 2 second timeout, so that the read thread can be aborted
+     when the NFCC does not respond and we need to switch to FW download
+     mode. This should be done via a control socket instead. */
+  FD_ZERO(&rfds);
+  FD_SET((intptr_t)pDevHandle, &rfds);
+  tv.tv_sec = 2;
+  tv.tv_usec = 1;
+
+  ret_Select =
+      select((int)((intptr_t)pDevHandle + (int)1), &rfds, NULL, NULL, &tv);
+  if (ret_Select < 0) {
+    NXPLOG_TML_D("%s errno : %x", __func__, errno);
+    return -1;
+  } else if (ret_Select == 0) {
+    NXPLOG_TML_D("%s Timeout", __func__);
+    return -1;
+  } else {
+    ret_Read = read((intptr_t)pDevHandle, pBuffer, totalBtyesToRead - numRead);
+    if (ret_Read > 0 && !(pBuffer[0] == 0xFF && pBuffer[1] == 0xFF)) {
+      SemTimedWait();
+      numRead += ret_Read;
+    } else if (ret_Read == 0) {
+      NXPLOG_TML_E("%s [hdr]EOF", __func__);
+      return -1;
+    } else {
+      NXPLOG_TML_E("%s [hdr] errno : %x", __func__, errno);
+      NXPLOG_TML_E(" %s pBuffer[0] = %x pBuffer[1]= %x", __func__, pBuffer[0],
+                   pBuffer[1]);
+      return -1;
+    }
+
+    if (bFwDnldFlag == false) {
+      totalBtyesToRead = NORMAL_MODE_HEADER_LEN;
+#if(NXP_EXTNS == TRUE)
+      if (gpphTmlNfc_Context->tReadInfo.pContext != NULL &&
+              !memcmp(gpphTmlNfc_Context->tReadInfo.pContext, "MinOpen", 0x07) &&
+              !pBuffer[0] && pBuffer[1]) {
+        return Flushdata(pDevHandle, pBuffer, numRead);
+      }
+#endif
+    } else {
+      totalBtyesToRead = FW_DNLD_HEADER_LEN;
+    }
+
+    if (numRead < totalBtyesToRead) {
+      ret_Read = read((intptr_t)pDevHandle, (pBuffer + numRead), totalBtyesToRead - numRead);
+
+      if (ret_Read != totalBtyesToRead - numRead) {
+        SemPost();
+        NXPLOG_TML_E("%s [hdr] errno : %x", __func__, errno);
+        return -1;
+      } else {
+        numRead += ret_Read;
+      }
+    }
+    if (bFwDnldFlag == true) {
+      totalBtyesToRead = pBuffer[FW_DNLD_LEN_OFFSET] + FW_DNLD_HEADER_LEN + CRC_LEN;
+    } else {
+      totalBtyesToRead = pBuffer[NORMAL_MODE_LEN_OFFSET] + NORMAL_MODE_HEADER_LEN;
+    }
+    if ((totalBtyesToRead - numRead) != 0) {
+      ret_Read = read((intptr_t)pDevHandle, (pBuffer + numRead), totalBtyesToRead - numRead);
+      if (ret_Read > 0) {
+        numRead += ret_Read;
+      } else if (ret_Read == 0) {
+        SemPost();
+        NXPLOG_TML_E("%s [pyld] EOF", __func__);
+        return -1;
+      } else {
+        if (bFwDnldFlag == false) {
+          NXPLOG_TML_D("_i2c_read() [hdr] received");
+          phNxpNciHal_print_packet("RECV", pBuffer, NORMAL_MODE_HEADER_LEN);
+        }
+        SemPost();
+        NXPLOG_TML_E("%s [pyld] errno : %x", __func__, errno);
+        return -1;
+      }
+    } else {
+      NXPLOG_TML_E("%s _>>>>> Empty packet recieved !!", __func__);
+    }
+  }
+  SemPost();
+  return numRead;
+}
+
+/*******************************************************************************
+**
+** Function         Write
+**
+** Description      Writes requested number of bytes from given buffer into
+**                  NFCC device
+**
+** Parameters       pDevHandle       - valid device handle
+**                  pBuffer          - buffer for read data
+**                  nNbBytesToWrite  - number of bytes requested to be written
+**
+** Returns          numWrote   - number of successfully written bytes
+**                  -1         - write operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::Write(void *pDevHandle, uint8_t *pBuffer,
+                            int nNbBytesToWrite) {
+  int ret;
+  int numWrote = 0;
+  int numBytes = nNbBytesToWrite;
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+  if (fragmentation_enabled == I2C_FRAGMENATATION_DISABLED &&
+      nNbBytesToWrite > FRAGMENTSIZE_MAX) {
+    NXPLOG_TML_D(
+        "%s data larger than maximum I2C  size,enable I2C fragmentation",
+        __func__);
+    return -1;
+  }
+  while (numWrote < nNbBytesToWrite) {
+    if (fragmentation_enabled == I2C_FRAGMENTATION_ENABLED &&
+        nNbBytesToWrite > FRAGMENTSIZE_MAX) {
+      if (nNbBytesToWrite - numWrote > FRAGMENTSIZE_MAX) {
+        numBytes = numWrote + FRAGMENTSIZE_MAX;
+      } else {
+        numBytes = nNbBytesToWrite;
+      }
+    }
+    SemTimedWait();
+    ret = write((intptr_t)pDevHandle, pBuffer + numWrote, numBytes - numWrote);
+    SemPost();
+    if (ret > 0) {
+      numWrote += ret;
+      if (fragmentation_enabled == I2C_FRAGMENTATION_ENABLED &&
+          numWrote < nNbBytesToWrite) {
+        usleep(500);
+      }
+    } else if (ret == 0) {
+      NXPLOG_TML_D("%s EOF", __func__);
+      return -1;
+    } else {
+      NXPLOG_TML_D("%s errno : %x", __func__, errno);
+      if (errno == EINTR || errno == EAGAIN) {
+        continue;
+      }
+      return -1;
+    }
+  }
+
+  return numWrote;
+}
+
+/*******************************************************************************
+**
+** Function         Reset
+**
+** Description      Reset NFCC device, using VEN pin
+**
+** Parameters       pDevHandle     - valid device handle
+**                  eType          - reset level
+**
+** Returns           0   - reset operation success
+**                  -1   - reset operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::NfccReset(void *pDevHandle, NfccResetType eType) {
+  int ret = -1;
+  NXPLOG_TML_D("%s, VEN eType %ld", __func__, eType);
+
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+
+  ret = ioctl((intptr_t)pDevHandle, NFC_SET_PWR, eType);
+  if (ret < 0) {
+    NXPLOG_TML_E("%s :failed errno = 0x%x", __func__, errno);
+  }
+  if ((eType != MODE_FW_DWNLD_WITH_VEN && eType != MODE_FW_DWND_HIGH) &&
+      ret == 0) {
+    EnableFwDnldMode(false);
+  }
+  if ((((eType == MODE_FW_DWNLD_WITH_VEN) || (eType == MODE_FW_DWND_HIGH)) && (ret == 0))) {
+    EnableFwDnldMode(true);
+  }
+
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         EseReset
+**
+** Description      Request NFCC to reset the eSE
+**
+** Parameters       pDevHandle     - valid device handle
+**                  eType          - EseResetType
+**
+** Returns           0   - reset operation success
+**                  else - reset operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::EseReset(void *pDevHandle, EseResetType eType) {
+  int ret = -1;
+  NXPLOG_TML_D("%s, eType %ld", __func__, eType);
+
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+  ret = ioctl((intptr_t)pDevHandle, ESE_SET_PWR, eType);
+  if (ret < 0) {
+    NXPLOG_TML_E("%s :failed errno = 0x%x", __func__, errno);
+  }
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         EseGetPower
+**
+** Description      Request NFCC to reset the eSE
+**
+** Parameters       pDevHandle     - valid device handle
+**                  level          - reset level
+**
+** Returns           0   - reset operation success
+**                  else - reset operation failure
+**
+*******************************************************************************/
+int NfccI2cTransport::EseGetPower(void *pDevHandle, long level) {
+  return ioctl((intptr_t)pDevHandle, ESE_GET_PWR, level);
+}
+
+/*******************************************************************************
+**
+** Function         GetPlatform
+**
+** Description      Get platform interface type (i2c or i3c) for common mw
+**
+** Parameters       pDevHandle     - valid device handle
+**
+** Returns           0   - i2c
+**                   1   - i3c
+**
+*******************************************************************************/
+int NfccI2cTransport::GetPlatform(void *pDevHandle) {
+  int ret = -1;
+  NXPLOG_TML_D("%s ", __func__);
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+  ret = ioctl((intptr_t)pDevHandle, NFC_GET_PLATFORM_TYPE);
+  NXPLOG_TML_D("%s :platform = %d", __func__, ret);
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         GetNfcState
+**
+** Description      Get NFC state
+**
+** Parameters       pDevHandle     - valid device handle
+** Returns           0   - unknown
+**                   1   - FW DWL
+**                   2 	 - NCI
+**
+*******************************************************************************/
+int NfccI2cTransport::GetNfcState(void *pDevHandle) {
+  int ret = NFC_STATE_UNKNOWN;
+  NXPLOG_TML_D("%s ", __func__);
+  if (NULL == pDevHandle) {
+    return ret;
+  }
+  ret = ioctl((intptr_t)pDevHandle, NFC_GET_NFC_STATE);
+  NXPLOG_TML_D("%s :nfc state = %d", __func__, ret);
+  return ret;
+}
+/*******************************************************************************
+**
+** Function         EnableFwDnldMode
+**
+** Description      updates the state to Download mode
+**
+** Parameters       True/False
+**
+** Returns          None
+*******************************************************************************/
+void NfccI2cTransport::EnableFwDnldMode(bool mode) { bFwDnldFlag = mode; }
+
+/*******************************************************************************
+**
+** Function         IsFwDnldModeEnabled
+**
+** Description      Returns the current mode
+**
+** Parameters       none
+**
+** Returns           Current mode download/NCI
+*******************************************************************************/
+bool_t NfccI2cTransport::IsFwDnldModeEnabled(void) { return bFwDnldFlag; }
+
+/*******************************************************************************
+**
+** Function         SemPost
+**
+** Description      sem_post 2c_read / write
+**
+** Parameters       none
+**
+** Returns          none
+*******************************************************************************/
+void NfccI2cTransport::SemPost() {
+  int sem_val = 0;
+  sem_getvalue(&mTxRxSemaphore, &sem_val);
+  if (sem_val == 0) {
+    sem_post(&mTxRxSemaphore);
+  }
+}
+
+/*******************************************************************************
+**
+** Function         SemTimedWait
+**
+** Description      Timed sem_wait for avoiding i2c_read & write overlap
+**
+** Parameters       none
+**
+** Returns          Sem_wait return status
+*******************************************************************************/
+int NfccI2cTransport::SemTimedWait() {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  long sem_timedout = 500 * 1000 * 1000;
+  int s = 0;
+  struct timespec ts;
+  clock_gettime(CLOCK_REALTIME, &ts);
+  ts.tv_sec += 0;
+  ts.tv_nsec += sem_timedout;
+  while ((s = sem_timedwait(&mTxRxSemaphore, &ts)) == -1 && errno == EINTR) {
+    continue; /* Restart if interrupted by handler */
+  }
+  if (s != -1) {
+    status = NFCSTATUS_SUCCESS;
+  } else if (errno == ETIMEDOUT && s == -1) {
+    NXPLOG_TML_E("%s :timed out errno = 0x%x", __func__, errno);
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         GetIrqState
+**
+** Description      Get state of IRQ GPIO
+**
+** Parameters       pDevHandle - valid device handle
+**
+** Returns          The state of IRQ line i.e. +ve if read is pending else Zer0.
+**                  In the case of IOCTL error, it returns -ve value.
+**
+*******************************************************************************/
+int NfccI2cTransport::GetIrqState(void *pDevHandle) {
+  int ret = -1;
+
+  NXPLOG_TML_D("%s Enter",__func__);
+  if (NULL != pDevHandle) {
+    ret = ioctl((intptr_t)pDevHandle, NFC_GET_IRQ_STATE);
+  }
+  NXPLOG_TML_D("%s exit: state = %d", __func__, ret);
+  return ret;
+}
diff --git a/pn8x/halimpl/tml/transport/NfccI2cTransport.h b/pn8x/halimpl/tml/transport/NfccI2cTransport.h
new file mode 100755
index 0000000..ae684b8
--- /dev/null
+++ b/pn8x/halimpl/tml/transport/NfccI2cTransport.h
@@ -0,0 +1,266 @@
+/******************************************************************************
+ *
+ *  Copyright 2020-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#pragma once
+#include <NfccTransport.h>
+
+#define NFC_MAGIC 0xE9
+/*
+ * NFCC power control via ioctl
+ * NFC_SET_PWR(0): power off
+ * NFC_SET_PWR(1): power on
+ * NFC_SET_PWR(2): reset and power on with firmware download enabled
+ */
+#define NFC_SET_PWR _IOW(NFC_MAGIC, 0x01, long)
+/*
+ * 1. SPI Request NFCC to enable ESE power, only in param
+ *   Only for SPI
+ *   level 1 = Enable power
+ *   level 0 = Disable power
+ * 2. NFC Request the eSE cold reset, only with MODE_ESE_COLD_RESET
+ */
+#define ESE_SET_PWR _IOW(NFC_MAGIC, 0x02, long)
+
+/*
+ * SPI or DWP can call this ioctl to get the current
+ * power state of ESE
+ */
+#define ESE_GET_PWR _IOR(NFC_MAGIC, 0x03, long)
+
+/*
+ * get platform interface type(i2c or i3c) for common MW
+ * return 0 - i2c, 1 - i3c
+ */
+#define NFC_GET_PLATFORM_TYPE _IO(NFC_MAGIC, 0x04)
+/*
+ * get boot state
+ * return unknown, fw dwl, fw teared, nci
+ */
+#define NFC_GET_NFC_STATE _IO(NFC_MAGIC, 0x05)
+
+/* NFC HAL can call this ioctl to get the current IRQ state */
+#define NFC_GET_IRQ_STATE _IO(NFC_MAGIC, 0x06)
+
+extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
+
+class NfccI2cTransport : public NfccTransport {
+ private:
+  bool_t bFwDnldFlag = false;
+  sem_t mTxRxSemaphore;
+  /*****************************************************************************
+   **
+   ** Function         SemTimedWait
+   **
+   ** Description      Timed sem_wait for avoiding i2c_read & write overlap
+   **
+   ** Parameters       none
+   **
+   ** Returns          Sem_wait return status
+   ****************************************************************************/
+  int SemTimedWait();
+
+  /*****************************************************************************
+   **
+   ** Function         SemPost
+   **
+   ** Description      sem_post 2c_read / write
+   **
+   ** Parameters       none
+   **
+   ** Returns          none
+   ****************************************************************************/
+  void SemPost();
+
+  int Flushdata(void* pDevHandle, uint8_t* pBuffer, int numRead);
+
+ public:
+  /*****************************************************************************
+  **
+  ** Function         Close
+  **
+  ** Description      Closes NFCC device
+  **
+  ** Parameters       pDevHandle - device handle
+  **
+  ** Returns          None
+  **
+  *****************************************************************************/
+  void Close(void *pDevHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         OpenAndConfigure
+   **
+   ** Description      Open and configure NFCC device
+   **
+   ** Parameters       pConfig     - hardware information
+   **                  pLinkHandle - device handle
+   **
+   ** Returns          NFC status:
+   **                  NFCSTATUS_SUCCESS - open_and_configure operation success
+   **                  NFCSTATUS_INVALID_DEVICE - device open operation failure
+   **
+   ****************************************************************************/
+  NFCSTATUS OpenAndConfigure(pphTmlNfc_Config_t pConfig, void **pLinkHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         Read
+   **
+   ** Description      Reads requested number of bytes from NFCC device into
+   *given
+   **                  buffer
+   **
+   ** Parameters       pDevHandle       - valid device handle
+   **                  pBuffer          - buffer for read data
+   **                  nNbBytesToRead   - number of bytes requested to be read
+   **
+   ** Returns          numRead   - number of successfully read bytes
+   **                  -1        - read operation failure
+   **
+   ****************************************************************************/
+  int Read(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToRead);
+
+  /*****************************************************************************
+  **
+  ** Function         Write
+  **
+  ** Description      Writes requested number of bytes from given buffer into
+  **                  NFCC device
+  **
+  ** Parameters       pDevHandle       - valid device handle
+  **                  pBuffer          - buffer for read data
+  **                  nNbBytesToWrite  - number of bytes requested to be written
+  **
+  ** Returns          numWrote   - number of successfully written bytes
+  **                  -1         - write operation failure
+  **
+  *****************************************************************************/
+  int Write(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToWrite);
+
+  /*****************************************************************************
+   **
+   ** Function         Reset
+   **
+   ** Description      Reset NFCC device, using VEN pin
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  level          - reset level
+   **
+   ** Returns           0   - reset operation success
+   **                  -1   - reset operation failure
+   **
+   ****************************************************************************/
+  int NfccReset(void *pDevHandle, NfccResetType eType);
+
+  /*****************************************************************************
+   **
+   ** Function         EseReset
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  eType          - EseResetType
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  int EseReset(void *pDevHandle, EseResetType eType);
+
+  /*****************************************************************************
+   **
+   ** Function         EseGetPower
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  level          - reset level
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  int EseGetPower(void *pDevHandle, long level);
+
+  /*****************************************************************************
+   **
+   ** Function         GetPlatform
+   **
+   ** Description      Get platform interface type (i2c or i3c) for common mw
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **
+   ** Returns           0   - i2c
+   **                   1   - i3c
+   **
+   ****************************************************************************/
+  int GetPlatform(void *pDevHandle);
+
+  /*****************************************************************************
+  **
+  ** Function         GetNfcState
+  **
+  ** Description      Get Nfc state
+  **
+  ** Parameters       pDevHandle     - valid device handle
+  ** Returns           0   - unknown
+  **                   1   - FW DWL
+  **                   2   - NCI
+  **
+  *****************************************************************************/
+  int GetNfcState(void *pDevHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         EnableFwDnldMode
+   **
+   ** Description      updates the state to Download mode
+   **
+   ** Parameters       True/False
+   **
+   ** Returns          None
+   ****************************************************************************/
+  void EnableFwDnldMode(bool mode);
+
+  /*****************************************************************************
+   **
+   ** Function         IsFwDnldModeEnabled
+   **
+   ** Description      Returns the current mode
+   **
+   ** Parameters       none
+   **
+   ** Returns           Current mode download/NCI
+   ****************************************************************************/
+  bool_t IsFwDnldModeEnabled(void);
+
+  /*******************************************************************************
+   **
+   ** Function         GetIrqState
+   **
+   ** Description      Get state of IRQ GPIO
+   **
+   ** Parameters       pDevHandle - valid device handle
+   **
+   ** Returns          The state of IRQ line i.e. +ve if read is pending else Zer0.
+   **                  In the case of IOCTL error, it returns -ve value.
+   **
+   *******************************************************************************/
+  int GetIrqState(void *pDevHandle);
+};
diff --git a/pn8x/halimpl/tml/transport/NfccSpiTransport.cc b/pn8x/halimpl/tml/transport/NfccSpiTransport.cc
new file mode 100755
index 0000000..8b13d61
--- /dev/null
+++ b/pn8x/halimpl/tml/transport/NfccSpiTransport.cc
@@ -0,0 +1,533 @@
+/******************************************************************************
+ *  Copyright 2020-2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <errno.h>
+#include <fcntl.h>
+#include <hardware/nfc.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/select.h>
+#include <termios.h>
+#include <unistd.h>
+
+#include "phNxpNciHal_utils.h"
+#include <NfccSpiTransport.h>
+#include <phNfcStatus.h>
+#include <phNxpLog.h>
+#include <string.h>
+
+#define CRC_LEN 2
+#define NORMAL_MODE_HEADER_LEN 3
+#define FW_DNLD_HEADER_LEN 2
+#define FW_DNLD_LEN_OFFSET 1
+#define NORMAL_MODE_LEN_OFFSET 2
+#define FRAGMENTSIZE_MAX PHNFC_I2C_FRAGMENT_SIZE
+extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
+extern phTmlNfc_Context_t *gpphTmlNfc_Context;
+/*******************************************************************************
+**
+** Function         Close
+**
+** Description      Closes NFCC device
+**
+** Parameters       pDevHandle - device handle
+**
+** Returns          None
+**
+*******************************************************************************/
+void NfccSpiTransport::Close(void *pDevHandle) {
+  if (NULL != pDevHandle) {
+    close((intptr_t)pDevHandle);
+  }
+  sem_destroy(&mTxRxSemaphore);
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         OpenAndConfigure
+**
+** Description      Open and configure NFCC device
+**
+** Parameters       pConfig     - hardware information
+**                  pLinkHandle - device handle
+**
+** Returns          NFC status:
+**                  NFCSTATUS_SUCCESS - open_and_configure operation success
+**                  NFCSTATUS_INVALID_DEVICE - device open operation failure
+**
+*******************************************************************************/
+NFCSTATUS NfccSpiTransport::OpenAndConfigure(pphTmlNfc_Config_t pConfig,
+                                             void **pLinkHandle) {
+  int nHandle;
+
+  NXPLOG_TML_D("%s Opening port=%s\n", __func__, pConfig->pDevName);
+  /* open port */
+  nHandle = open((const char *)pConfig->pDevName, O_RDWR);
+  if (nHandle < 0) {
+    NXPLOG_TML_E("_i2c_open() Failed: retval %x", nHandle);
+    *pLinkHandle = NULL;
+    return NFCSTATUS_INVALID_DEVICE;
+  }
+
+  *pLinkHandle = (void *)((intptr_t)nHandle);
+  if (0 != sem_init(&mTxRxSemaphore, 0, 1)) {
+    NXPLOG_TML_E("%s Failed: reason sem_init : retval %x", __func__, nHandle);
+  }
+  /*Reset PN54X*/
+  NfccReset((void *)((intptr_t)nHandle), MODE_POWER_OFF);
+  usleep(10 * 1000);
+  NfccReset((void *)((intptr_t)nHandle), MODE_POWER_ON);
+
+  return NFCSTATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         Flushdata
+**
+** Description      Reads payload of FW rsp from NFCC device into given buffer
+**
+** Parameters       pDevHandle - valid device handle
+**                  pBuffer    - buffer for read data
+**                  numRead    - number of bytes read by calling function
+**
+** Returns          always returns -1
+**
+*******************************************************************************/
+int NfccSpiTransport::Flushdata(void* pDevHandle, uint8_t* pBuffer, int numRead) {
+  int retRead = 0;
+  uint16_t totalBtyesToRead = pBuffer[FW_DNLD_LEN_OFFSET] + FW_DNLD_HEADER_LEN + CRC_LEN;
+  /* we shall read totalBtyesToRead-1 as one byte is already read by calling function*/
+  retRead = read((intptr_t)pDevHandle, pBuffer + numRead, totalBtyesToRead - 1);
+  if (retRead > 0) {
+    numRead += retRead;
+    phNxpNciHal_print_packet("RECV", pBuffer, numRead);
+  } else if (retRead == 0) {
+    NXPLOG_TML_E("%s _i2c_read() [pyld] EOF", __func__);
+  } else {
+    if (bFwDnldFlag == false) {
+      NXPLOG_TML_D("%s _i2c_read() [hdr] received", __func__);
+      phNxpNciHal_print_packet("RECV", pBuffer - numRead, NORMAL_MODE_HEADER_LEN);
+    }
+    NXPLOG_TML_E("%s _i2c_read() [pyld] errno : %x", __func__, errno);
+  }
+  SemPost();
+  return -1;
+}
+
+/*******************************************************************************
+**
+** Function         Read
+**
+** Description      Reads requested number of bytes from NFCC device into given
+**                  buffer
+**
+** Parameters       pDevHandle       - valid device handle
+**                  pBuffer          - buffer for read data
+**                  nNbBytesToRead   - number of bytes requested to be read
+**
+** Returns          numRead   - number of successfully read bytes
+**                  -1        - read operation failure
+**
+*******************************************************************************/
+int NfccSpiTransport::Read(void *pDevHandle, uint8_t *pBuffer,
+                           int nNbBytesToRead) {
+  int ret_Read;
+  int ret_Select;
+  int numRead = 0;
+  struct timeval tv;
+  fd_set rfds;
+  uint16_t totalBtyesToRead = 0;
+
+  UNUSED(nNbBytesToRead);
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+
+  if (bFwDnldFlag == false) {
+    totalBtyesToRead = NORMAL_MODE_HEADER_LEN;
+  } else {
+    totalBtyesToRead = FW_DNLD_HEADER_LEN;
+  }
+
+  /* Read with 2 second timeout, so that the read thread can be aborted
+     when the NFCC does not respond and we need to switch to FW download
+     mode. This should be done via a control socket instead. */
+  FD_ZERO(&rfds);
+  FD_SET((intptr_t)pDevHandle, &rfds);
+  tv.tv_sec = 2;
+  tv.tv_usec = 1;
+
+  ret_Select =
+      select((int)((intptr_t)pDevHandle + (int)1), &rfds, NULL, NULL, &tv);
+  if (ret_Select < 0) {
+    NXPLOG_TML_D("%s errno : %x", __func__, errno);
+    return -1;
+  } else if (ret_Select == 0) {
+    NXPLOG_TML_D("%s Timeout", __func__);
+    return -1;
+  } else {
+    ret_Read = read((intptr_t)pDevHandle, pBuffer, totalBtyesToRead - numRead);
+    if (ret_Read > 0 && !(pBuffer[0] == 0xFF && pBuffer[1] == 0xFF)) {
+      SemTimedWait();
+      numRead += ret_Read;
+    } else if (ret_Read == 0) {
+      NXPLOG_TML_E("%s [hdr]EOF", __func__);
+      return -1;
+    } else {
+      NXPLOG_TML_E("%s [hdr] errno : %x", __func__, errno);
+      NXPLOG_TML_E(" %s pBuffer[0] = %x pBuffer[1]= %x", __func__, pBuffer[0],
+                   pBuffer[1]);
+      return -1;
+    }
+
+    if (bFwDnldFlag == false) {
+      totalBtyesToRead = NORMAL_MODE_HEADER_LEN;
+#if(NXP_EXTNS == TRUE)
+      if (gpphTmlNfc_Context->tReadInfo.pContext != NULL &&
+              !memcmp(gpphTmlNfc_Context->tReadInfo.pContext, "MinOpen", 0x07) &&
+              !pBuffer[0] && pBuffer[1]) {
+        return Flushdata(pDevHandle, pBuffer, numRead);
+      }
+#endif
+    } else {
+      totalBtyesToRead = FW_DNLD_HEADER_LEN;
+    }
+
+    if (numRead < totalBtyesToRead) {
+      ret_Read = read((intptr_t)pDevHandle, (pBuffer + numRead), totalBtyesToRead - numRead);
+
+      if (ret_Read != totalBtyesToRead - numRead) {
+        SemPost();
+        NXPLOG_TML_E("%s [hdr] errno : %x", __func__, errno);
+        return -1;
+      } else {
+        numRead += ret_Read;
+      }
+    }
+    if (bFwDnldFlag == true) {
+      totalBtyesToRead = pBuffer[FW_DNLD_LEN_OFFSET] + FW_DNLD_HEADER_LEN + CRC_LEN;
+    } else {
+      totalBtyesToRead = pBuffer[NORMAL_MODE_LEN_OFFSET] + NORMAL_MODE_HEADER_LEN;
+    }
+    if ((totalBtyesToRead - numRead) != 0) {
+      ret_Read = read((intptr_t)pDevHandle, (pBuffer + numRead), totalBtyesToRead - numRead);
+      if (ret_Read > 0) {
+        numRead += ret_Read;
+      } else if (ret_Read == 0) {
+        SemPost();
+        NXPLOG_TML_E("%s [pyld] EOF", __func__);
+        return -1;
+      } else {
+        if (bFwDnldFlag == false) {
+          NXPLOG_TML_D("_i2c_read() [hdr] received");
+          phNxpNciHal_print_packet("RECV", pBuffer, NORMAL_MODE_HEADER_LEN);
+        }
+        SemPost();
+        NXPLOG_TML_E("%s [pyld] errno : %x", __func__, errno);
+        return -1;
+      }
+    } else {
+      NXPLOG_TML_E("%s _>>>>> Empty packet recieved !!", __func__);
+    }
+  }
+  SemPost();
+  return numRead;
+}
+
+/*******************************************************************************
+**
+** Function         Write
+**
+** Description      Writes requested number of bytes from given buffer into
+**                  NFCC device
+**
+** Parameters       pDevHandle       - valid device handle
+**                  pBuffer          - buffer for read data
+**                  nNbBytesToWrite  - number of bytes requested to be written
+**
+** Returns          numWrote   - number of successfully written bytes
+**                  -1         - write operation failure
+**
+*******************************************************************************/
+int NfccSpiTransport::Write(void *pDevHandle, uint8_t *pBuffer,
+                            int nNbBytesToWrite) {
+  int ret;
+  int numWrote = 0;
+  int numBytes = nNbBytesToWrite;
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+  if (fragmentation_enabled == I2C_FRAGMENATATION_DISABLED &&
+      nNbBytesToWrite > FRAGMENTSIZE_MAX) {
+    NXPLOG_TML_D(
+        "%s data larger than maximum I2C  size,enable I2C fragmentation",
+        __func__);
+    return -1;
+  }
+  while (numWrote < nNbBytesToWrite) {
+    if (fragmentation_enabled == I2C_FRAGMENTATION_ENABLED &&
+        nNbBytesToWrite > FRAGMENTSIZE_MAX) {
+      if (nNbBytesToWrite - numWrote > FRAGMENTSIZE_MAX) {
+        numBytes = numWrote + FRAGMENTSIZE_MAX;
+      } else {
+        numBytes = nNbBytesToWrite;
+      }
+    }
+    SemTimedWait();
+    ret = write((intptr_t)pDevHandle, pBuffer + numWrote, numBytes - numWrote);
+    SemPost();
+    if (ret > 0) {
+      numWrote += ret;
+      if (fragmentation_enabled == I2C_FRAGMENTATION_ENABLED &&
+          numWrote < nNbBytesToWrite) {
+        usleep(500);
+      }
+    } else if (ret == 0) {
+      NXPLOG_TML_D("%s EOF", __func__);
+      return -1;
+    } else {
+      NXPLOG_TML_D("%s errno : %x", __func__, errno);
+      if (errno == EINTR || errno == EAGAIN) {
+        continue;
+      }
+      return -1;
+    }
+  }
+
+  return numWrote;
+}
+
+/*******************************************************************************
+**
+** Function         NfccReset
+**
+** Description      Reset NFCC device, using VEN pin
+**
+** Parameters       pDevHandle     - valid device handle
+**                  eType          - reset level
+**
+** Returns           0   - reset operation success
+**                  -1   - reset operation failure
+**
+*******************************************************************************/
+int NfccSpiTransport::NfccReset(void *pDevHandle, NfccResetType eType) {
+  int ret = -1;
+  NXPLOG_TML_D("%s, VEN eType %ld", __func__, eType);
+
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+
+  ret = ioctl((intptr_t)pDevHandle, NFC_SET_PWR, eType);
+  if (ret < 0) {
+    NXPLOG_TML_E("%s :failed errno = 0x%x", __func__, errno);
+  }
+  if ((eType != MODE_FW_DWNLD_WITH_VEN && eType != MODE_FW_DWND_HIGH) &&
+      ret == 0) {
+    EnableFwDnldMode(false);
+  }
+  if ((((eType == MODE_FW_DWNLD_WITH_VEN) || (eType == MODE_FW_DWND_HIGH)) && (ret == 0))) {
+    EnableFwDnldMode(true);
+  }
+
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         EseReset
+**
+** Description      Request NFCC to reset the eSE
+**
+** Parameters       pDevHandle     - valid device handle
+**                  eType          - EseResetType
+**
+** Returns           0   - reset operation success
+**                  else - reset operation failure
+**
+*******************************************************************************/
+int NfccSpiTransport::EseReset(void *pDevHandle, EseResetType eType) {
+  int ret = -1;
+  NXPLOG_TML_D("%s, eType %ld", __func__, eType);
+
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+  ret = ioctl((intptr_t)pDevHandle, ESE_SET_PWR, eType);
+  if (ret < 0) {
+    NXPLOG_TML_E("%s :failed errno = 0x%x", __func__, errno);
+  }
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         EseGetPower
+**
+** Description      Request NFCC to reset the eSE
+**
+** Parameters       pDevHandle     - valid device handle
+**                  level          - reset level
+**
+** Returns           0   - reset operation success
+**                  else - reset operation failure
+**
+*******************************************************************************/
+int NfccSpiTransport::EseGetPower(void *pDevHandle, long level) {
+  return ioctl((intptr_t)pDevHandle, ESE_GET_PWR, level);
+}
+
+/*******************************************************************************
+**
+** Function         GetPlatform
+**
+** Description      Get platform interface type (i2c or i3c) for common mw
+**
+** Parameters       pDevHandle     - valid device handle
+**
+** Returns           0   - i2c
+**                   1   - i3c
+**
+*******************************************************************************/
+int NfccSpiTransport::GetPlatform(void *pDevHandle) {
+  int ret = -1;
+  NXPLOG_TML_D("%s ", __func__);
+  if (NULL == pDevHandle) {
+    return -1;
+  }
+  ret = ioctl((intptr_t)pDevHandle, NFC_GET_PLATFORM_TYPE);
+  NXPLOG_TML_D("%s :platform = %d", __func__, ret);
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function         GetNfcState
+**
+** Description      Get NFC state
+**
+** Parameters       pDevHandle     - valid device handle
+** Returns           0   - unknown
+**                   1   - FW DWL
+**                   2 	 - NCI
+**
+*******************************************************************************/
+int NfccSpiTransport::GetNfcState(void *pDevHandle) {
+  int ret = NFC_STATE_UNKNOWN;
+  NXPLOG_TML_D("%s ", __func__);
+  if (NULL == pDevHandle) {
+    return ret;
+  }
+  ret = ioctl((intptr_t)pDevHandle, NFC_GET_NFC_STATE);
+  NXPLOG_TML_D("%s :nfc state = %d", __func__, ret);
+  return ret;
+}
+/*******************************************************************************
+**
+** Function         EnableFwDnldMode
+**
+** Description      updates the state to Download mode
+**
+** Parameters       True/False
+**
+** Returns          None
+*******************************************************************************/
+void NfccSpiTransport::EnableFwDnldMode(bool mode) { bFwDnldFlag = mode; }
+
+/*******************************************************************************
+**
+** Function         IsFwDnldModeEnabled
+**
+** Description      Returns the current mode
+**
+** Parameters       none
+**
+** Returns           Current mode download/NCI
+*******************************************************************************/
+bool_t NfccSpiTransport::IsFwDnldModeEnabled(void) { return bFwDnldFlag; }
+
+/*******************************************************************************
+**
+** Function         SemPost
+**
+** Description      sem_post 2c_read / write
+**
+** Parameters       none
+**
+** Returns          none
+*******************************************************************************/
+void NfccSpiTransport::SemPost() {
+  int sem_val = 0;
+  sem_getvalue(&mTxRxSemaphore, &sem_val);
+  if (sem_val == 0) {
+    sem_post(&mTxRxSemaphore);
+  }
+}
+
+/*******************************************************************************
+**
+** Function         SemTimedWait
+**
+** Description      Timed sem_wait for avoiding i2c_read & write overlap
+**
+** Parameters       none
+**
+** Returns          Sem_wait return status
+*******************************************************************************/
+int NfccSpiTransport::SemTimedWait() {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  long sem_timedout = 500 * 1000 * 1000;
+  int s = 0;
+  struct timespec ts;
+  clock_gettime(CLOCK_REALTIME, &ts);
+  ts.tv_sec += 0;
+  ts.tv_nsec += sem_timedout;
+  while ((s = sem_timedwait(&mTxRxSemaphore, &ts)) == -1 && errno == EINTR) {
+    continue; /* Restart if interrupted by handler */
+  }
+  if (s != -1) {
+    status = NFCSTATUS_SUCCESS;
+  } else if (errno == ETIMEDOUT && s == -1) {
+    NXPLOG_TML_E("%s :timed out errno = 0x%x", __func__, errno);
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         GetIrqState
+**
+** Description      Get state of IRQ GPIO
+**
+** Parameters       pDevHandle - valid device handle
+**
+** Returns          The state of IRQ line i.e. +ve if read is pending else Zer0.
+**                  In the case of IOCTL error, it returns -ve value.
+**
+*******************************************************************************/
+int NfccSpiTransport::GetIrqState(void *pDevHandle) {
+  int ret = -1;
+
+  NXPLOG_TML_D("%s Enter",__func__);
+  if (NULL != pDevHandle) {
+    ret = ioctl((intptr_t)pDevHandle, NFC_GET_IRQ_STATE);
+  }
+  NXPLOG_TML_D("%s exit: state = %d", __func__, ret);
+  return ret;
+}
diff --git a/pn8x/halimpl/tml/transport/NfccSpiTransport.h b/pn8x/halimpl/tml/transport/NfccSpiTransport.h
new file mode 100755
index 0000000..c7d6644
--- /dev/null
+++ b/pn8x/halimpl/tml/transport/NfccSpiTransport.h
@@ -0,0 +1,266 @@
+/******************************************************************************
+ *
+ *  Copyright 2020-2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#pragma once
+#include <NfccTransport.h>
+
+#define NFC_MAGIC 0xE9
+/*
+ * NFCC power control via ioctl
+ * NFC_SET_PWR(0): power off
+ * NFC_SET_PWR(1): power on
+ * NFC_SET_PWR(2): reset and power on with firmware download enabled
+ */
+#define NFC_SET_PWR _IOW(NFC_MAGIC, 0x01, long)
+/*
+ * 1. SPI Request NFCC to enable ESE power, only in param
+ *   Only for SPI
+ *   level 1 = Enable power
+ *   level 0 = Disable power
+ * 2. NFC Request the eSE cold reset, only with MODE_ESE_COLD_RESET
+ */
+#define ESE_SET_PWR _IOW(NFC_MAGIC, 0x02, long)
+
+/*
+ * SPI or DWP can call this ioctl to get the current
+ * power state of ESE
+ */
+#define ESE_GET_PWR _IOR(NFC_MAGIC, 0x03, long)
+
+/*
+ * get platform interface type(i2c or i3c) for common MW
+ * return 0 - i2c, 1 - i3c
+ */
+#define NFC_GET_PLATFORM_TYPE _IO(NFC_MAGIC, 0x04)
+/*
+ * get boot state
+ * return unknown, fw dwl, fw teared, nci
+ */
+#define NFC_GET_NFC_STATE _IO(NFC_MAGIC, 0x05)
+
+/* NFC HAL can call this ioctl to get the current IRQ state */
+#define NFC_GET_IRQ_STATE _IO(NFC_MAGIC, 0x06)
+
+extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
+
+class NfccSpiTransport : public NfccTransport {
+ private:
+  bool_t bFwDnldFlag = false;
+  sem_t mTxRxSemaphore;
+  /*****************************************************************************
+   **
+   ** Function         SemTimedWait
+   **
+   ** Description      Timed sem_wait for avoiding i2c_read & write overlap
+   **
+   ** Parameters       none
+   **
+   ** Returns          Sem_wait return status
+   ****************************************************************************/
+  int SemTimedWait();
+
+  /*****************************************************************************
+   **
+   ** Function         SemPost
+   **
+   ** Description      sem_post 2c_read / write
+   **
+   ** Parameters       none
+   **
+   ** Returns          none
+   ****************************************************************************/
+  void SemPost();
+
+  int Flushdata(void* pDevHandle, uint8_t* pBuffer, int numRead);
+
+ public:
+  /*****************************************************************************
+  **
+  ** Function         Close
+  **
+  ** Description      Closes NFCC device
+  **
+  ** Parameters       pDevHandle - device handle
+  **
+  ** Returns          None
+  **
+  *****************************************************************************/
+  void Close(void *pDevHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         OpenAndConfigure
+   **
+   ** Description      Open and configure NFCC device
+   **
+   ** Parameters       pConfig     - hardware information
+   **                  pLinkHandle - device handle
+   **
+   ** Returns          NFC status:
+   **                  NFCSTATUS_SUCCESS - open_and_configure operation success
+   **                  NFCSTATUS_INVALID_DEVICE - device open operation failure
+   **
+   ****************************************************************************/
+  NFCSTATUS OpenAndConfigure(pphTmlNfc_Config_t pConfig, void **pLinkHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         Read
+   **
+   ** Description      Reads requested number of bytes from NFCC device into
+   *given
+   **                  buffer
+   **
+   ** Parameters       pDevHandle       - valid device handle
+   **                  pBuffer          - buffer for read data
+   **                  nNbBytesToRead   - number of bytes requested to be read
+   **
+   ** Returns          numRead   - number of successfully read bytes
+   **                  -1        - read operation failure
+   **
+   ****************************************************************************/
+  int Read(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToRead);
+
+  /*****************************************************************************
+  **
+  ** Function         Write
+  **
+  ** Description      Writes requested number of bytes from given buffer into
+  **                  NFCC device
+  **
+  ** Parameters       pDevHandle       - valid device handle
+  **                  pBuffer          - buffer for read data
+  **                  nNbBytesToWrite  - number of bytes requested to be written
+  **
+  ** Returns          numWrote   - number of successfully written bytes
+  **                  -1         - write operation failure
+  **
+  *****************************************************************************/
+  int Write(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToWrite);
+
+  /*****************************************************************************
+   **
+   ** Function         NfccReset
+   **
+   ** Description      Reset NFCC device, using VEN pin
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  level          - reset level
+   **
+   ** Returns           0   - reset operation success
+   **                  -1   - reset operation failure
+   **
+   ****************************************************************************/
+  int NfccReset(void *pDevHandle, NfccResetType eType);
+
+  /*****************************************************************************
+   **
+   ** Function         EseReset
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  eType          - EseResetType
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  int EseReset(void *pDevHandle, EseResetType eType);
+
+  /*****************************************************************************
+   **
+   ** Function         EseGetPower
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  level          - reset level
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  int EseGetPower(void *pDevHandle, long level);
+
+  /*****************************************************************************
+   **
+   ** Function         GetPlatform
+   **
+   ** Description      Get platform interface type (i2c or i3c) for common mw
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **
+   ** Returns           0   - i2c
+   **                   1   - i3c
+   **
+   ****************************************************************************/
+  int GetPlatform(void *pDevHandle);
+
+  /*****************************************************************************
+  **
+  ** Function         GetNfcState
+  **
+  ** Description      Get Nfc state
+  **
+  ** Parameters       pDevHandle     - valid device handle
+  ** Returns           0   - unknown
+  **                   1   - FW DWL
+  **                   2   - NCI
+  **
+  *****************************************************************************/
+  int GetNfcState(void *pDevHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         EnableFwDnldMode
+   **
+   ** Description      updates the state to Download mode
+   **
+   ** Parameters       True/False
+   **
+   ** Returns          None
+   ****************************************************************************/
+  void EnableFwDnldMode(bool mode);
+
+  /*****************************************************************************
+   **
+   ** Function         IsFwDnldModeEnabled
+   **
+   ** Description      Returns the current mode
+   **
+   ** Parameters       none
+   **
+   ** Returns           Current mode download/NCI
+   ****************************************************************************/
+  bool_t IsFwDnldModeEnabled(void);
+
+  /*******************************************************************************
+   **
+   ** Function         GetIrqState
+   **
+   ** Description      Get state of IRQ GPIO
+   **
+   ** Parameters       pDevHandle - valid device handle
+   **
+   ** Returns          The state of IRQ line i.e. +ve if read is pending else Zer0.
+   **                  In the case of IOCTL error, it returns -ve value.
+   **
+   *******************************************************************************/
+  int GetIrqState(void *pDevHandle);
+};
diff --git a/pn8x/halimpl/tml/transport/NfccTransport.cc b/pn8x/halimpl/tml/transport/NfccTransport.cc
new file mode 100755
index 0000000..c4de05a
--- /dev/null
+++ b/pn8x/halimpl/tml/transport/NfccTransport.cc
@@ -0,0 +1,50 @@
+/******************************************************************************
+ *
+ *  Copyright 2020-2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <NfccTransport.h>
+
+int NfccTransport::NfccReset(__attribute__((unused)) void *pDevHandle,
+                             __attribute__((unused)) NfccResetType eType) {
+  return NFCSTATUS_SUCCESS;
+}
+
+int NfccTransport::EseReset(__attribute__((unused)) void *pDevHandle,
+                            __attribute__((unused)) EseResetType eType) {
+  return NFCSTATUS_SUCCESS;
+}
+int NfccTransport::EseGetPower(__attribute__((unused)) void *pDevHandle,
+                               __attribute__((unused)) long level) {
+  return NFCSTATUS_SUCCESS;
+}
+
+int NfccTransport::GetPlatform(__attribute__((unused)) void *pDevHandle) {
+  return 0x00;
+}
+
+int NfccTransport::GetNfcState(__attribute__((unused)) void *pDevHandle) {
+  return NFC_STATE_UNKNOWN;
+}
+
+void NfccTransport::EnableFwDnldMode(__attribute__((unused)) bool mode) {
+  return;
+}
+int NfccTransport::GetIrqState(__attribute__((unused)) void *pDevHandle) {
+  return -1;
+}
+
+bool_t NfccTransport::IsFwDnldModeEnabled(void) { return false; }
diff --git a/pn8x/halimpl/tml/transport/NfccTransport.h b/pn8x/halimpl/tml/transport/NfccTransport.h
new file mode 100755
index 0000000..4240427
--- /dev/null
+++ b/pn8x/halimpl/tml/transport/NfccTransport.h
@@ -0,0 +1,246 @@
+/******************************************************************************
+ *
+ *  Copyright 2020-2022 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#pragma once
+#include <phNfcTypes.h>
+#include <phTmlNfc.h>
+
+enum NfccResetType : long {
+  MODE_POWER_OFF = 0x00,
+  MODE_POWER_ON,
+  MODE_FW_DWNLD_WITH_VEN,
+  MODE_ISO_RST,
+  MODE_FW_DWND_HIGH,
+  MODE_POWER_RESET,
+  MODE_FW_GPIO_LOW
+};
+
+enum EseResetCallSrc : long {
+  SRC_SPI = 0x0,
+  SRC_NFC = 0x10,
+};
+
+enum EseResetType : long {
+  MODE_ESE_POWER_ON = 0,
+  MODE_ESE_POWER_OFF,
+  MODE_ESE_POWER_STATE,
+  /*Request from eSE HAL/Service*/
+  MODE_ESE_COLD_RESET,
+  MODE_ESE_RESET_PROTECTION_ENABLE,
+  MODE_ESE_RESET_PROTECTION_DISABLE,
+  /*Request from NFC HAL/Service*/
+  MODE_ESE_COLD_RESET_NFC = MODE_ESE_COLD_RESET | SRC_NFC,
+  MODE_ESE_RESET_PROTECTION_ENABLE_NFC =
+      MODE_ESE_RESET_PROTECTION_ENABLE | SRC_NFC,
+  MODE_ESE_RESET_PROTECTION_DISABLE_NFC =
+      MODE_ESE_RESET_PROTECTION_DISABLE | SRC_NFC,
+};
+
+extern phTmlNfc_i2cfragmentation_t fragmentation_enabled;
+
+class NfccTransport {
+public:
+  /*****************************************************************************
+   **
+   ** Function         Close
+   **
+   ** Description      Closes NFCC device
+   **
+   ** Parameters       pDevHandle - device handle
+   **
+   ** Returns          None
+   **
+   *****************************************************************************/
+  virtual void Close(void *pDevHandle) = 0;
+
+  /*****************************************************************************
+   **
+   ** Function         OpenAndConfigure
+   **
+   ** Description      Open and configure NFCC device and transport layer
+   **
+   ** Parameters       pConfig     - hardware information
+   **                  pLinkHandle - device handle
+   **
+   ** Returns          NFC status:
+   **                  NFCSTATUS_SUCCESS - open_and_configure operation success
+   **                  NFCSTATUS_INVALID_DEVICE - device open operation failure
+   **
+   ****************************************************************************/
+  virtual NFCSTATUS OpenAndConfigure(pphTmlNfc_Config_t pConfig,
+                                     void **pLinkHandle) = 0;
+
+  /*****************************************************************************
+   **
+   ** Function         Read
+   **
+   ** Description      Reads requested number of bytes from NFCC device into
+   **                 given buffer
+   **
+   ** Parameters       pDevHandle       - valid device handle
+   **                  pBuffer          - buffer for read data
+   **                  nNbBytesToRead   - number of bytes requested to be read
+   **
+   ** Returns          numRead   - number of successfully read bytes
+   **                  -1        - read operation failure
+   **
+   ****************************************************************************/
+  virtual int Read(void *pDevHandle, uint8_t *pBuffer, int nNbBytesToRead) = 0;
+
+  /*****************************************************************************
+   **
+   ** Function         Write
+   **
+   ** Description      Writes requested number of bytes from given buffer into
+   **                  NFCC device
+   **
+   ** Parameters       pDevHandle       - valid device handle
+   **                  pBuffer          - buffer for read data
+   **                  nNbBytesToWrite  - number of bytes requested to be
+   *written
+   **
+   ** Returns          numWrote   - number of successfully written bytes
+   **                  -1         - write operation failure
+   **
+   *****************************************************************************/
+  virtual int Write(void *pDevHandle, uint8_t *pBuffer,
+                    int nNbBytesToWrite) = 0;
+
+  /*****************************************************************************
+   **
+   ** Function         Reset
+   **
+   ** Description      Reset NFCC device, using VEN pin
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  eType          - NfccResetType
+   **
+   ** Returns           0   - reset operation success
+   **                  -1   - reset operation failure
+   **
+   ****************************************************************************/
+  virtual int NfccReset(void *pDevHandle, NfccResetType eType);
+
+  /*****************************************************************************
+  **
+  ** Function         GetNfcState
+  **
+  ** Description      Get NFC state
+  **
+  ** Parameters       pDevHandle     - valid device handle
+  ** Returns           0   - unknown
+  **                   1   - FW DWL
+  **                   2   - NCI
+  **
+  *****************************************************************************/
+  virtual int GetNfcState(void *pDevHandle);
+  /*****************************************************************************
+   **
+   ** Function         EseReset
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  eType          - EseResetType
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  virtual int EseReset(void *pDevHandle, EseResetType eType);
+
+  /*****************************************************************************
+   **
+   ** Function         EseGetPower
+   **
+   ** Description      Request NFCC to reset the eSE
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **                  level          - reset level
+   **
+   ** Returns           0   - reset operation success
+   **                  else - reset operation failure
+   **
+   ****************************************************************************/
+  virtual int EseGetPower(void *pDevHandle, long level);
+
+  /*****************************************************************************
+   **
+   ** Function         GetPlatform
+   **
+   ** Description      Get platform interface type (i2c or i3c) for common mw
+   **
+   ** Parameters       pDevHandle     - valid device handle
+   **
+   ** Returns           0   - i2c
+   **                   1   - i3c
+   **
+   ****************************************************************************/
+  virtual int GetPlatform(void *pDevHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         EnableFwDnldMode
+   **
+   ** Description      updates the state to Download mode
+   **
+   ** Parameters       True/False
+   **
+   ** Returns          None
+   ****************************************************************************/
+  virtual void EnableFwDnldMode(bool mode);
+
+  /*****************************************************************************
+   **
+   ** Function         IsFwDnldModeEnabled
+   **
+   ** Description      Returns the current mode
+   **
+   ** Parameters       none
+   **
+   ** Returns          Current mode download/NCI
+   ****************************************************************************/
+  virtual bool_t IsFwDnldModeEnabled(void);
+
+  /*******************************************************************************
+   **
+   ** Function         GetIrqState
+   **
+   ** Description      Get state of IRQ GPIO
+   **
+   ** Parameters       pDevHandle - valid device handle
+   **
+   ** Returns          The state of IRQ line i.e. +ve if read is pending else
+   *Zer0.
+   **                  In the case of IOCTL error, it returns -ve value.
+   **
+   *******************************************************************************/
+  virtual int GetIrqState(void *pDevHandle);
+
+  /*****************************************************************************
+   **
+   ** Function         ~NfccTransport
+   **
+   ** Description      TransportLayer destructor
+   **
+   ** Parameters       none
+   **
+   ** Returns          None
+   ****************************************************************************/
+  virtual ~NfccTransport(){};
+};
diff --git a/pn8x/halimpl/utils/NxpNfcCapability.cpp b/pn8x/halimpl/utils/NxpNfcCapability.cpp
index 720ed08..fd8be4f 100644
--- a/pn8x/halimpl/utils/NxpNfcCapability.cpp
+++ b/pn8x/halimpl/utils/NxpNfcCapability.cpp
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright 2015,2021-2022 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -57,7 +57,11 @@ tNFC_chipType capability::getChipType(uint8_t* msg, uint16_t msg_len) {
         case 0x40:  // PN553 A0
         case 0x41:  // PN553 B0
           // NQ310
-          chipType = pn553;
+          if (msg[offsetFwVersion] == 0x12) {
+            chipType = pn557;
+          } else{
+            chipType = pn553;
+          }
           break;
 
         case 0x50:  // PN553 A0 + P73
@@ -72,9 +76,12 @@ tNFC_chipType capability::getChipType(uint8_t* msg, uint16_t msg_len) {
           }
           break;
 
-        case 0x61:
+        case 0x61:// PN7160 (no ECP support)
+        case 0x71:// PN7161 (ECP support)
           if (msg[offsetFwVersion] == 0x11) {
             chipType = pn553;
+          } else if (msg[offsetFwVersion] == 0x12) {
+            chipType = pn557;
           }
           break;
 
@@ -89,6 +96,7 @@ tNFC_chipType capability::getChipType(uint8_t* msg, uint16_t msg_len) {
 
         case 0x28:
         case 0x48:  // NQ210
+        case 0x88:
           chipType = pn548C2;
           break;
 
diff --git a/pn8x/halimpl/utils/phNxpConfig.h b/pn8x/halimpl/utils/phNxpConfig.h
index cc39097..81e0ff6 100755
--- a/pn8x/halimpl/utils/phNxpConfig.h
+++ b/pn8x/halimpl/utils/phNxpConfig.h
@@ -18,9 +18,9 @@
 
 /******************************************************************************
  *
- *  The original Work has been changed by NXP Semiconductors.
+ *  The original Work has been changed by NXP.
  *
- *  Copyright (C) 2013-2014 NXP Semiconductors
+ *  Copyright 2013-2014,2021-2022 NXP
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -107,6 +107,12 @@ int updateNxpConfigTimestamp();
 #define NAME_OFFHOST_ROUTE_ESE "OFFHOST_ROUTE_ESE"
 #define NAME_OFFHOST_ROUTE_UICC "OFFHOST_ROUTE_UICC"
 #define NAME_DEFAULT_ISODEP_ROUTE "DEFAULT_ISODEP_ROUTE"
+#if(NXP_EXTNS == TRUE)
+#define NAME_NXP_TRANSPORT "NXP_TRANSPORT"
+#define NAME_NXP_AGC_DEBUG_ENABLE "NXP_AGC_DEBUG_ENABLE"
+#define NAME_NXP_T4T_NFCEE_ENABLE "NXP_T4T_NFCEE_ENABLE"
+#define NAME_DEFAULT_T4TNFCEE_AID_POWER_STATE "DEFAULT_T4TNFCEE_AID_POWER_STATE"
+#endif
 
 /* default configuration */
 #define default_storage_location "/data/vendor/nfc"
diff --git a/pn8x/halimpl/utils/phNxpNciHal_utils.cc b/pn8x/halimpl/utils/phNxpNciHal_utils.cc
index 3ab9ba5..47c8085 100644
--- a/pn8x/halimpl/utils/phNxpNciHal_utils.cc
+++ b/pn8x/halimpl/utils/phNxpNciHal_utils.cc
@@ -1,6 +1,6 @@
 /*
  *
- *  Copyright (C) 2013-2014 NXP Semiconductors
+ *  Copyright 2013-2014,2021-2022 NXP
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -23,6 +23,10 @@
 #include <phNxpNciHal.h>
 #include <phNxpNciHal_utils.h>
 
+extern uint8_t discovery_cmd[50];
+extern uint8_t discovery_cmd_len;
+extern uint8_t nfcdep_detected;
+
 /*********************** Link list functions **********************************/
 
 /*******************************************************************************
@@ -457,6 +461,16 @@ void phNxpNciHal_print_packet(const char* pString, const uint8_t* p_data,
 *******************************************************************************/
 
 void phNxpNciHal_emergency_recovery(void) {
+  if (nfcFL.chipType == pn548C2 && nfcdep_detected && discovery_cmd_len != 0) {
+    pthread_t pthread;
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+    if (pthread_create(&pthread, &attr, (void *(*)(void *))phNxpNciHal_core_reset_recovery,
+                       NULL) == 0) {
+      return;
+    }
+  }
   NXPLOG_NCIHAL_E("%s: abort()", __func__);
   abort();
 }
